local std = stead
local iface = std '@iface'
local instead = std '@instead'

local function html_tag(nam)
	return function(s, str)
		if not str then return str end
		return '<'..nam..'>'..str..'</'..nam..'>'
	end
end

iface.center = html_tag('center')
iface.bold = html_tag('b')
iface.em = html_tag('i')
iface.img = function(s, str)
	if str then
--		instead.clear() -- always clear window on pictures
		return '<g:'..str..'>'
	end
end
instead.restart = instead_restart
instead.menu = instead_menu
instead.clear = instead_clear
instead.tiny = true -- minimal version
instead.run_js = instead_js
instead.savename = instead_savename

std.mod_start(function()
	local mp = std.ref '@metaparser'
	if mp then
		mp.msg.CUTSCENE_HELP = mp.msg.CUTSCENE_HELP:gsub("<", "&lt"):gsub(">", "&gt");
		std.rawset(mp, 'clear', function(self)
			self.text = ''
			-- uncomment to clear screen on move
			-- instead.clear();
		end)
		VerbExtend ({
			"#MetaSave",
			"*:MetaSave",
		}, mp)
		VerbExtend ({
			"#MetaLoad",
			"*:MetaLoad",
		}, mp)
		std.rawset(mp, 'MetaSave', function(self, w)
			instead.savename(w)
			instead.menu 'save'
		end)
		std.rawset(mp, 'MetaLoad', function(self, w)
			instead.savename(w)
			instead.menu 'load'
		end)
	end
end)
local std = stead

local instead = std.obj { nam = '@instead' }

instead.nosave = false
instead.noautosave = false
instead.tiny = true

function instead.mouse_filter()
	return 0
end

function instead.render_callback()
	return false
end

function instead.wait_use()
	return true
end

local iface = std '@iface'
local type = std.type

local dict = {}

local function get_bool(o, nam)
	if type(o[nam]) == 'boolean' then
		return o[nam]
	end
	if type(o[nam]) == 'function' then
		return o:nam()
	end
	return nil
end

instead.inv_delim = '\n'
instead.hinv_delim = ' | '
instead.ways_delim = ' | '

instead.notitle = false
instead.noways = false
instead.noinv = false
instead.nopic = false

instead.fading_value = 0

function instead.fading()
end

function instead.need_fading()
end

function instead.autosave(slot)
end

function instead.menu(n)
end

function instead.restart(v)
end

function instead.text_input()
	return false
end

function instead.atleast(...)
	return true
end

function instead.version(...)
end

function iface:title(str) -- hide title
	return str
end

function iface:img() return '' end

function iface:imgl() return '' end

function iface:imgr() return '' end

function iface:anchor() return '' end

function iface:nb(t)
	return t == '' and ' ' or t
end

std.stat = std.class({
	__stat_type = true;
}, std.obj);

std.menu = std.class({
	__menu_type = true;
	new = function(self, v)
		if type(v) ~= 'table' then
			std.err ("Wrong argument to std.menu:"..std.tostr(v), 2)
		end
		v = std.obj(v)
		std.setmt(v, self)
		return v
	end;
	inv = function(s, ...)
		local r, v
		if s.menu ~= nil then
			r, v = std.call(s, 'menu', ...) -- special method while in inv
		else
			r, v = std.call(s, 'act', ...) -- fallback to act
		end
		return true, false -- menu mode
	end;
}, std.obj);
std.setmt(std.phr, std.menu) -- make phrases menus
std.setmt(std.ref '@', std.menu) -- make xact menu

function iface:xref(str, o, ...)
	if type(str) ~= 'string' then
		std.err ("Wrong parameter to iface:xref: "..std.tostr(str), 2)
	end
	if not std.is_obj(o) or std.is_obj(o, 'stat') then
		return str
	end
	local a = { ... }
	local args = ''
	for i = 1, #a do
		if type(a[i]) ~= 'string' and type(a[i]) ~= 'number' then
			std.err ("Wrong argument to iface:xref: "..std.tostr(a[i]), 2)
		end
		args = args .. ' '..std.dump(a[i])
	end
	local xref = std.string.format("%s%s", std.deref_str(o), args)
	-- std.string.format("%s%s", iface:esc(std.deref_str(o)), iface:esc(args))

	if not dict[xref] then
		table.insert(dict, xref)
		dict[xref] = #dict
	end
	xref = std.tostr(dict[xref])

	return str..std.string.format("(%s)", xref)
end

local iface_cmd = iface.cmd -- save old

function iface:cmd(inp)
	local a = std.split(inp)
	if std.tonum(a[1]) then
		std.table.insert(a, 1, 'act')
	end
	if a[1] == 'act' or a[1] == 'use' or a[1] == 'go' then
		if a[1] == 'use' then
			local use = std.split(a[2], ',')
			for i = 1, 2 do
				local u = std.tonum(use[i])
				if u then
					use[i] = dict[u]
				end
			end
			a[2] = std.join(use, ',')
		elseif std.tonum(a[2]) then
			a[2] = dict[std.tonum(a[2])]
		end
		inp = std.join(a)
	end
	return iface_cmd(self, inp)
end

std.obj { -- input object
	nam = '@input';
};

-- some aliases
menu = std.menu
stat = std.stat

-- fake sound
local sound = std.obj {
	nam = '@snd';
}

sound.set = function() end
sound.play = function() end
sound.stop = function() end
sound.music = function() end
sound.stop_music = function() end
sound.music_fading = function() end
sound.new = function() return sound end

-- fake timer
std.obj {
	nam = '@timer';
	get = function(s)
		return s.__timer or 0;
	end;
	stop = function(s)
		return s:set(0)
	end;
	set = function(s, v)
		s.__timer = v
		return true
	end;
}

-- fake sprite
std.obj {
	nam = '@sprite';
	new = function() end;
	fnt = function() end;
	scr = function() end;
	direct = function() return false end;
	render_callback = instead.render_callback;
}
-- fake pixels
std.obj {
	nam = '@pixels';
	fnt = function() end;
	new = function() end;
}
-- fake themes
local theme = std.obj {
	nam = '@theme';
	{
		win = { gfx = {}};
		inv = { gfx = {}};
		menu = { gfx = {}};
		gfx = {};
		snd = {};
	};
}

function theme.restore()
end

function theme.set()
end

function theme.reset()
end

function theme.name()
end

function theme.get()
end

function theme.win.reset()
end

function theme.win.geom()
end

function theme.win.color()
end

function theme.win.font()
end

function theme.win.gfx.reset()
end

function theme.win.gfx.up()
end

function theme.win.gfx.down()
end

function theme.inv.reset()
end

function theme.inv.geom()
end

function theme.inv.color(f)
end

function theme.inv.font()
end

function theme.inv.mode()
end

function theme.inv.gfx.reset()
end

function theme.inv.gfx.up()
end

function theme.inv.gfx.down()
end

function theme.menu.reset()
end

function theme.menu.bw(w)
end

function theme.menu.color()
end

function theme.menu.font()
end

function theme.menu.gfx.reset()
end

function theme.menu.gfx.button()
end;

function theme.gfx.reset()
end

function theme.gfx.cursor()
end

function theme.gfx.mode()
end

function theme.gfx.pad()
end

function theme.gfx.bg()
end

function theme.snd.reset()
end

function theme.snd.click()
end


std.mod_init(function()
	std.rawset(_G, 'instead', instead)
end)
std.mod_start(function()
	dict = {}
	local mp = std.ref '@metaparser'
	if mp then
		mp.winsize = 0
		mp.prompt = false
	end
end)
std.mod_step(function(state)
	if state then
		dict = {}
	end
end)

require "ext/paths"
-- luacheck: read globals declare

local std = stead
local type = std.type
-- luacheck: read globals game
std.rawset(_G, 'std', stead)
-- luacheck: globals include
include = std.include
-- luacheck: globals loadmod
loadmod = std.loadmod
-- luacheck: globals rnd
rnd = std.rnd
-- luacheck: globals rnd_seed
rnd_seed = std.rnd_seed
-- luacheck: globals p
p = std.p
-- luacheck: globals pr
pr = std.pr
-- luacheck: globals pn
pn = std.pn
-- luacheck: globals pf
pf = std.pf
-- luacheck: globals obj
obj = std.obj
-- luacheck: globals stat
stat = std.stat
-- luacheck: globals room
room = std.room
-- luacheck: globals menu
menu = std.menu
-- luacheck: globals dlg
dlg = std.dlg
-- luacheck: globals me
me = std.me
-- luacheck: globals here
here = std.here
-- luacheck: globals from
from = std.from
-- luacheck: globals new
new = std.new
-- luacheck: globals delete
delete = std.delete
-- nameof = std.nameof
-- dispof = std.dispof
-- titleof = std.titleof
-- luacheck: globals gamefile
gamefile = std.gamefile
-- luacheck: globals player
player = std.player
-- luacheck: globals dprint
dprint = std.dprint

local function _pfn(f1, f2, ...)
	local a = {...}
	if type(f2) == 'string' then
		return function()
			f1()
			std.p(f2, std.unpack(a))
		end
	end
	if type(f2) ~= 'function' then
		return f1()
	end
	return function(f3, ...)
		return _pfn(function()
			f1()
			f2(std.unpack(a))
		end, f3, ...)
	end
end

-- luacheck: globals pfn
function pfn(f, ...)
	local a = {...}
	if type(f) == 'function' then
		return _pfn(function() end, f, ...)
	end
	return function()
		std.p(f, std.unpack(a))
	end
end

-- luacheck: globals from
function from(ww)
	local wh
	ww = ww or std.here()
	wh = std.ref(ww)
	if not std.is_obj(wh, 'room') then
		std.err("Wrong argument to from(): "..std.tostr(wh), 2)
	end
	return wh:from()
end;

local function walkroom(w)
	if std.is_tag(w) then
		local ww = std.here().way:lookup(w)
		if not ww then
			std.err("Can not found tag: "..std.tostr(w), 3)
		end
		return ww
	end
	return w
end

-- luacheck: globals visits
function visits(w)
	if not w then return std.here():visits() end
	return std.object(walkroom(w)):visits()
end

-- luacheck: globals visited
function visited(w)
	if not w then return std.here():visited() end
	return std.object(walkroom(w)):visited()
end

-- luacheck: globals walk
function walk(w, ...)
	local r, v = std.me():walk(walkroom(w), ...)
	if std.cctx() and type(r) == 'string' then
		std.p(r)
	end
	return r, v
end

-- luacheck: globals life_walk
function life_walk(w, ...)
	game:reaction(false)
	game:events(false, false)
	return walk(w, ...)
end

-- luacheck: globals walkin
function walkin(w, ...)
	local r, v = std.me():walkin(walkroom(w), ...)
	if std.cctx() and type(r) == 'string' then
		std.p(r)
	end
	return r, v
end

-- luacheck: globals walkout
function walkout(w, ...)
	local r, v = std.me():walkout(walkroom(w), ...)
	if std.cctx() and type(r) == 'string' then
		std.p(r)
	end
	return r, v
end

-- luacheck: globals walkback
function walkback(w, ...)
	return walkout(w, false, ...)
end

std.walkout = walkout
std.walkin = walkin
std.walk = walk

local function object(w)
	local o
	if std.is_tag(w) then
		o = std.here():lookup(w)
		if not o then
			o = std.me():lookup(w)
		end
		if not o then
			std.err("Wrong tag: "..w, 3)
		end
		return o
	end
	o = std.ref(w)
	if not o then
		std.err("Wrong object: "..std.tostr(w), 3)
	end
	return o
end
std.object = object

-- luacheck: globals _
_ = std.object

-- luacheck: globals for_all
for_all = std.for_all

-- luacheck: globals seen
function seen(w, ww)
	local wh
	ww = ww or std.here()
	if not std.is_obj(ww, 'list') then
		wh = std.ref(ww)
	else
		return ww:srch(w)
	end
	if not std.is_obj(wh) then
		std.err("Wrong 2-nd argument to seen(): "..std.tostr(ww), 2)
	end
	return wh:srch(w)
end

-- luacheck: globals lookup
function lookup(w, ww)
	local wh
	ww = ww or std.here()
	if not std.is_obj(ww, 'list') then
		wh = std.ref(ww)
	else
		return ww:lookup(w)
	end
	if not std.is_obj(wh) and not std.is_obj(wh, 'list') then
		std.err("Wrong 2-nd argument to lookup(): "..std.tostr(ww), 2)
	end
	return wh:lookup(w)
end

-- luacheck: globals ways
function ways(ww)
	local wh
	ww = ww or std.here()
	wh = std.ref(ww)
	if not std.is_obj(wh, 'room') then
		std.err("Wrong 2-nd argument to ways(): "..std.tostr(ww), 2)
	end
	return wh.way
end
std.ways = ways

-- luacheck: globals objs
function objs(ww)
	local wh
	ww = ww or std.here()
	wh = std.ref(ww)
	if not std.is_obj(wh) then
		std.err("Wrong 2-nd argument to objs(): "..std.tostr(ww), 2)
	end
	return wh.obj
end

-- luacheck: globals inspect
function inspect(w, ...)
	return std.me():inspect(std.object(w), ...)
end

-- luacheck: globals have
function have(w, ...)
	return std.me():have(std.object(w), ...)
end

-- luacheck: globals inroom
function inroom(w, ...)
	return std.object(w):inroom(...)
end

-- luacheck: globals where
function where(w, ...)
	return std.object(w):where(...)
end

-- luacheck: globals closed
function closed(w)
	return std.object(w):closed()
end

-- luacheck: globals disabled
function disabled(w)
	return std.object(w):disabled()
end

-- luacheck: globals enable
function enable(w)
	return std.object(w):enable()
end

-- luacheck: globals disable
function disable(w)
	return std.object(w):disable()
end

-- luacheck: globals open
function open(w)
	return std.object(w):open()
end

-- luacheck: globals close
function close(w)
	return std.object(w):close()
end

-- luacheck: globals actions
function actions(w, t, v)
	return std.object(w):actions(t, v)
end

-- luacheck: globals pop
function pop(w, ww)
	local wh = ww or std.here()
	if not std.is_obj(wh, 'dlg') then
		std.err("Call pop() in non-dialog object: "..std.tostr(wh), 2)
	end
	local r, v = wh:pop(w)
	if std.cctx() and type(r) == 'string' then
		std.p(r)
	end
	return r, v
end

-- luacheck: globals push
function push(w, ww)
	local wh = ww or std.here()
	if not std.is_obj(wh, 'dlg') then
		std.err("Call push() in non-dialog object: "..std.tostr(wh), 2)
	end
	local r, v = wh:push(w)
	if std.cctx() and type(r) == 'string' then
		std.p(r)
	end
	return r, v
end

-- luacheck: globals empty
function empty(w, ...)
	if not w then
		return std.here():empty()
	end
	return std.object(w):empty(...)
end

-- luacheck: globals lifeon
function lifeon(w, ...)
	return std 'game':lifeon(w and std.object(w), ...)
end

-- luacheck: globals lifeoff
function lifeoff(w, ...)
	return std 'game':lifeoff(w and std.object(w), ...)
end

-- luacheck: globals live
function live(...)
	return std 'game':live(...)
end

-- luacheck: globals change_pl
function change_pl(w, ...)
	return std 'game':set_pl(w and std.object(w), ...)
end

-- luacheck: globals player_moved
function player_moved(pl)
	pl = pl or std.me()
	pl = std.ref(pl)
	if not std.is_obj(pl, 'player') then
		std.err("Wrong argument to player_moved(): "..std.tostr(pl))
	end
	return std.me():moved()
end

-- luacheck: globals inv
function inv(pl)
	pl = pl or std.me()
	pl = std.ref(pl)
	if not std.is_obj(pl, 'player') then
		std.err("Wrong argument to inv(): "..std.tostr(pl))
	end
	return pl:inventory()
end

-- luacheck: globals remove
function remove(w, wh)
	local o = std.object(w)
	if not w then
		std.err("Wrong argument to remove(): "..std.tostr(w), 2)
	end
	wh = wh and std.object(wh)
	return o:remove(wh)
end

-- luacheck: globals purge
function purge(w)
	local o = std.object(w)
	if not w then
		std.err("Wrong argument to purge(): "..std.tostr(w), 2)
	end
	return o:purge()
end

local function __place(w, wh, remove)
	local o = std.object(w)
	if not o then
		std.err("Wrong argument to place(): "..std.tostr(w), 3)
	end
	if remove then
		o:remove() -- remove object from everywhere
	end
	wh = wh or std.here()
	if type(wh) ~= 'table' then
		wh = std.object(wh)
	end
	if o:type 'player' then
		if not std.is_obj(wh) then
			std.err("Wrong 2-nd argument to place(): "..std.tostr(wh), 3)
		end
		o:walk(wh, false, false)
		return o
	end
	if std.is_obj(wh) then
		wh.obj:add(o)
	elseif std.is_obj(wh, 'list') then
		wh:add(o)
	else
		std.err("Wrong 2-nd argument to place(): "..std.tostr(wh), 3)
	end
	return o
end

-- luacheck: globals replace
function replace(w, ww, wh)
	local o = std.object(w)
	if not o then
		std.err("Wrong argument to replace(): "..std.tostr(w), 2)
	end
	local oo = std.object(ww)
	if not oo then
		std.err("Wrong argument to replace(): "..std.tostr(ww), 2)
	end
	if not wh then -- replace all
		local l = {}
		o:where(l)
		for _, v in std.ipairs(l) do
			v.obj:replace(o, oo)
			if std.is_obj(v, 'room') then
				v.way:replace(o, oo)
			end
		end
		return oo
	end
	if type(wh) ~= 'table' then
		wh = std.object(wh)
	end
	if std.is_obj(wh) then
		local _, l = wh:lookup(o)
		if l then
			l:replace(o, oo)
			return oo
		end
	elseif std.is_obj(wh, 'list') then
		wh:replace(o, oo)
		return oo
	else
		std.err("Wrong 3-rd argument to replace(): "..std.tostr(wh), 3)
	end
end

-- luacheck: globals place
function place(w, wh)
	return __place(w, wh, true)
end

-- luacheck: globals put
function put(w, wh)
	return __place(w, wh, false)
end

-- luacheck: globals take
function take(w)
	local o = std.object(w)
	if o then
		o:actions('take', 1 + o:actions 'take')
	end
	return place(w, std.me():inventory())
end

-- luacheck: globals drop
function drop(w, wh)
	local o = std.object(w)
	if o then
		o:actions('drop', 1 + o:actions 'drop')
	end
	return place(w, wh)
end

-- luacheck: globals path
path = std.class({
	__path_type = true;
	new = function(_, t)
		if type(t) ~= 'table' then
			std.err("Wrong path argument. Use {} as path argument.", 2)
		end
		local n, s, w = t[1], t[2], t[3]

		if not w then
			s, w = n, s
			n = nil
		end

		local new = {
			before = s;
			walk = w;
		}

		for k, v in std.pairs(t) do
			if type(k) == 'string' then
				new[k] = v
			end
		end

		new.nam = n or new.nam

		return std.room(new)
	end;
	disp = function(s)
		local w = s.walk
		if type(w) == 'function' then
			w = w()
		end
		if disabled(w) or closed(w) then
			return false
		end
		if s.after ~= nil and visited(w) then
			return std.call(s, 'after')
		end
		return std.call(s, 'before')
	end;
	onwalk = function(s, _)
		local w = s.walk
		if type(w) == 'function' then
			w = w()
		end
		if not disabled(w) and not closed(w) then
			walk(w)
		end
		return false
	end;
}, std.room)

-- luacheck: globals time
function time(...)
	return std.ref 'game':time(...)
end

local xact = std.obj {
	nam = '@';
	{
		methods = {}
	};
	act = function(s, w, ...)
		if type(s.methods[w]) ~= 'function' then
			std.err ("Wrong method to xact", 2)
		end
		return s.methods[w](...)
	end
}

std.rawset(_G, 'xact', xact.methods)

std.mod_init(function()
	declare {
		game = std.ref 'game',
		pl = std.ref 'player',
	}
end)
-- luacheck: read globals iface

local std = stead
local type = std.type
local table = std.table

std.phrase_prefix = '-- '
std.phrase_show = true

local function phr_prefix(d, nr)
	if type(std.phrase_prefix) == 'string' then
		d = std.phrase_prefix .. d
	elseif type(std.phrase_prefix) == 'function' then
		d = std.phrase_prefix(nr) .. d
	end
	return d
end

std.dlg = std.class({
	__dlg_type = true;
	new = function(s, v)
		if v.current == nil then
			v.current = false
		end
		v.dlg_enter = v.enter
		v.enter = nil
		v.__stack = {}
		if type(v.phr) == 'table' then
			if not v.obj then v.obj = {} end
			if type(v.obj) == 'table' then
				table.insert(v.obj, 1, v.phr)
			end
		end
		v = std.room(v)
		std.setmt(v, s)
		v:__recreate()
		return v
	end;
	__recreate = function(s)
		for i = 1, #s.obj do
			if not std.is_obj(s.obj[i]) then
				s.obj[i] = std.phr(s.obj[i])
			end
		end
	end;
	with = function(self, ...)
		std.room.with(self, ...)
		self:__recreate()
		return self
	end;
	scene = function(s)
		local title, dsc, lact
		title = iface:title(std.titleof(s))
		dsc = std.call(s, 'dsc')
		if not std.me():moved() then
			s.__lact = std.game:lastreact() or s.__lact
			lact = iface:em(s.__lact)
		end
		return std.par(std.scene_delim, title or false, lact or false, dsc)
	end;
	ph_onact = function(_, w) -- show dsc by default
		if not std.phrase_show then
			return
		end
		local r, v = std.call(w, 'dsc')
		if type(r) == 'string' then
			return phr_prefix(r)
		end
		return r, v
	end;
	empty = function(s, w)
		if not w then
			if not s.current then
				return true
			end
			return s.current:empty()
		end
		w = s:lookup(w)
		if not w then
			return true
		end
		return w:empty()
	end;
	enter = function(s, ...)
		s.__llact = false
		s.__stack = {}
		s.current = nil
		s:for_each(function(self) self:open() end) -- open all phrases
		local r, v = std.call(s, 'dlg_enter', ...)
		if std.here() ~= s or #s.__stack > 0 then
			return r, v
		end
		local rr, vv = s:push(s.current)
		if not vv then
			std.err("Wrong dialog: "..std.tostr(s), 2)
		end
		return std.par(std.scene_delim, r or false, rr or false), v
	end;
	push = function(s, p)
		local c = s.current
		local r = s:select(p)
		local t
		if r ~= false then
			if c then
				table.insert(s.__stack, c)
			end
			if r.dsc ~= nil and r.ph_act == nil and r.next == nil then -- no rection
				t = std.call(r, 'dsc')
			end
			if s.current ~= r or std.me():moved() then
				return t
			end
			if r:empty() then
				local tt, vv = s:pop()
				t = std.par(std.scene_delim, t or false, tt or false)
				if not vv then
					tt = std.walkout(s:from())
					t = std.par(std.scene_delim, t or false, tt or false)
				end
			end
		end
		return t, r ~= false
	end;
	reset = function(s, phr)
		s.__stack = {}
		return s:push(phr)
	end;
	pop = function(s, phr)
		if #s.__stack == 0 then
			return false
		end

		if phr then
			local l = {}
			for i = 1, #s.__stack do
				table.insert(l, s.__stack[i])
				if s.stack[i] == phr then
					break
				end
			end
			s.__stack = l
		end
		local p
		while #s.__stack > 0 do
			p = table.remove(s.__stack, #s.__stack) -- remove top
			p = s:select(p)
			if not p then
				return false
			end
			if p:empty() then
				local r, v = std.call(p, 'onempty')
				if v then
					return r, p
				end
			else
				return false, p
			end
		end
		return false
	end;
	select = function(s, p)
		if #s.obj == 0 then
			return false
		end
		if not p then -- get first one
			p = s.obj[1]
		end

		local c = s:lookup(p)

		if not c then
			std.err("Wrong dlg:select argumant: "..std.tostr(p), 2)
		end

		c:select()

		-- if c:disabled() then -- select always enables phrase
		--	c:enable()
		-- end
		s.current = c
		return c
	end;
	srch = function(s, w)
		local oo = s.current -- lookup in current
		if not oo then
			return
		end
		local r, l, i = s:lookup(w)
		if not r then
			return
		end
		if not std.is_obj(r, 'phr') then -- simple object
			return std.room.srch(s, w)
		end
		w = oo.obj:for_each(function(v) -- aliases
			v = v:__alias()
			if not v:visible() then
				return
			end
			if v == r then
				return v
			end
		end)
		if not w then
			return
		end
		return r, l, i
	end;
	display = function(s)
		local deco = std.call(s, 'decor'); -- static decorations
		return std.par(std.scene_delim, deco or false, s:ph_display())
	end;
	ph_display = function(s)
		local r, nr
		nr = 1
		local oo = s.current
		if not oo then -- nothing to show
			return
		end

		oo:select() -- to recheck all

		for i = 1, #oo.obj do
			local o = oo.obj[i]
			o = o:__alias()
			if o:visible() then
				if r then
					r = r .. '^'
				end
				local d = std.call(o, 'dsc')
				if type(d) == 'string' then
					d = phr_prefix(d, nr)
					d = o:__xref(d, true)
					r = (r or '').. d
					nr = nr + 1
				end
			end
		end
		return r
	end;
}, std.room)

std.phr = std.class({
	__phr_type = true;
	new = function(s, t)
		local disabled
		local a = t
		local o = {
			obj = {}
		}
		for i = 1, #a do
			local v = a[i]
			if i == 1 and type(v) == 'boolean' then
				if not v then
					disabled = true
				else
					o.always = true
				end
			elseif type(v) == 'table' then
				if not std.is_obj(v, 'phr') then
					v = s:new(v)
				end
				table.insert(o.obj, v)
			elseif o.tag == nil and v ~= nil and std.is_tag(v) then
				o.tag = v
			elseif o.dsc == nil and v ~= nil then
				o.dsc = v
			elseif o.act == nil and v ~= nil then
				o.act = v
			end
		end

		for k, v in std.pairs(a) do
			if type(k) == 'string' then
				o[k] = v
			end
		end

--		if o.act == nil then
--			std.err("Wrong phrase (no act)", 2)
--		end
		o.ph_act = o.act
		o.act = nil

		disabled = disabled or (o.hidden == true)

		o = std.obj(o)
		std.setmt(o, s)
		if disabled then o = o:disable() end
		return o
	end,
	__alias = function(s)
		if s.alias ~= nil then
			local ss = std.here():lookup(s.alias)
			if not std.is_obj(ss) then
				std.err("Wrong alias: "..std.tostr(s.alias), 3)
			end
			s = ss
		end
		return s
	end;
	check = function(s)
--		s = s:__alias()
		if type(s.cond) == 'function' then
			if s:cond() then
				s:enable()
			else
				s:disable()
			end
		end
	end;
	empty = function(s)
		for i = 1, #s.obj do
			local o = s.obj[i]
			if not o:disabled() and not o:closed() then
				return false
			end
		end
		return true
	end;
	visible = function(s)
		return not s:disabled() and not s:closed()
	end;
	act = function(s, ...)
		local r, _
		local n = s
--		s = s:__alias()
		local onact, v = std.call(std.here(), 'ph_onact', s)
		if not v then
			return onact
		end
		local w = s:where()
		if w and w.only then -- only one choice
			for i = 1, #w.obj do
				local o = w.obj[i]
				if not o.always then
					o:close()
				end
			end
		elseif not s.always then
			s:close()
		end
		local cur = std.here().current

		r, _ = std.call(s, 'ph_act', ...)

		r = std.par(std.scene_delim, onact or false, r or false)

		if std.me():moved() or cur ~= std.here().current then
			return r, v
		end

		if std.is_tag(s.next) then
			n = s.next
		end

		cur:select() -- conditions

		local t

		local rr, vv = std.here():push(n)
		if not vv then
			t = std.walkout(std.here():from())
		end
		return std.par(std.scene_delim, r or false, rr or false, t or false), v
	end,
	select = function(s)
		if not s.always then
			s:close()
		end
		for i = 1, #s.obj do
			local o = s.obj[i]
			o = o:__alias()
			o:check()
		end
	end;
}, std.obj)
-- luacheck: globals sprite pixels
sprite = stead.ref '@sprite'
pixels = stead.ref '@pixels'
globals = {
	'stead',
	'LANG',
}
-- STEAD3 API

-- luacheck: globals iface init start stead
-- luacheck: read globals DEBUG doencfile instead_readdir instead_random table_get_maxn instead_srandom

stead = {
	space_delim = ' ',
	scene_delim = '^^',
	delim = '|',
	call_top = 0,
	call_ctx = { txt = nil, self = nil },
	objects = {};
	tags = {};
	next_dynamic = -1;
	max_dynamic = 32767;
	tables = {};
	functions = {};
	modules = {};
	includes = {};
	tostr = tostring;
	tonum = tonumber;
	type = type;
	setmt = setmetatable;
	getmt = getmetatable;
	table = table;
	math = math;
	newproxy = newproxy;
	pairs = pairs;
	ipairs = ipairs;
	rawset = rawset;
	rawget = rawget;
	rawequal = rawequal;
	pcall = pcall;
	io = io;
	os = os;
	readdir = instead_readdir,
	string = string;
	next = next;
	loadfile = loadfile;
	dofile = dofile;
	doencfile = doencfile;
	getinfo = debug.getinfo;
	__mod_hooks = {};
	files = {};
	busy = function() end;
	debug_xref = true;
	debug_save = false;
	random = instead_random;
	randomseed = instead_srandom;
}


local std = stead

std.strip_call = true

local error = error

function std.err(msg, lev)
	if std.noerror then
		std.dprint(msg)
	else
		error(msg, lev)
	end
end

function std.dprint(...)
	local a = { ... }
	for i = 1, #a do
		if i ~= 1 then
			std.io.stderr:write(' ')
		end
		std.io.stderr:write(std.tostr(a[i]))
	end
	std.io.stderr:write('\n')
	std.io.stderr:flush()
end

std.rnd = function(...)
	if std.random then
		return std.random(...)
	end
	return std.math.random(...);
end

std.rnd_seed = function(...)
	std.math.randomseed(...)
	if std.randomseed then
		return std.randomseed(...)
	end
end

function stead:abort()
	self.abort_cmd = true
end

function stead.savepath()
	return "./"
end

local table = std.table
local pairs = std.pairs
local ipairs = std.ipairs
local string = std.string
local rawset = std.rawset
local rawget = std.rawget
local type = std.type
local io = std.io;

if _VERSION == "Lua 5.1" then
	std.eval = loadstring
	std.unpack = unpack
	std.proxy = function(o)
		local oo = std.newproxy(true)
		local t = std.getmt(oo)
		t.__index = o
		t.__newindex = o
		t.__gc = function(_)
			o:__gc()
		end
		t.__tostring = function(_)
			return o:__tostring()
		end
		o.__proxy_type = true
		return oo
	end
else
	std.proxy = function(o)
		o.__proxy_type = true
		return o
	end
	std.eval = load
	std.unpack = table.unpack
	table.maxn = table_get_maxn
	string.gfind = string.gmatch
-- luacheck: push ignore math
	math.mod = math.fmod
	math.log10 = function(a)
		return std.math.log(a, 10)
	end
end

math.pow = function(num, n)
	return num ^ n
end

math.round = function(num, n)
	local m = 10 ^ (n or 0)
	return std.math.floor(num * m + 0.5) / m
end
-- luacheck: pop

local function __mod_callback_reg(f, hook, prio)
	if type(f) ~= 'function' then
		std.err ("Wrong parameter to mod_"..hook..".", 3);
	end

	if prio and type(prio) ~= 'number' then
		std.err ("Wrong prio parameter to mod_"..hook..".", 3);
	end

	if not std.__mod_hooks[hook] then
		std.__mod_hooks[hook] = {}
	end
	local i = { fn = f, prio = prio, unload = std.__in_include }
	table.insert(std.__mod_hooks[hook], i);
	std.sort(std.__mod_hooks[hook], function (a, b)
		a = a.prio or 0
		b = b.prio or 0
		if a == b then
			return nil
		end
		return a < b
	end)
--	f();
end

function std.mod_unload()
	local new = {}
	for k, v in pairs(std.__mod_hooks) do
		local list = {}
		for _, vv in ipairs(v) do
			if not vv.unload then
				table.insert(list, vv)
			end
		end
		new[k] = list
	end
	std.__mod_hooks = new
end

function std.mod_call(hook, ...)
	if not std.__mod_hooks[hook] then
		return
	end
	for _, v in ipairs(std.__mod_hooks[hook]) do
		local a, b = v.fn(...)
		if a ~= nil or b ~= nil then
			return a, b
		end
	end
end

function std.mod_call_rev(hook, ...)
	if not std.__mod_hooks[hook] then
		return
	end
	for i = #std.__mod_hooks[hook], 1, -1 do
		local v = std.__mod_hooks[hook][i]
		local a, b = v.fn(...)
		if a ~= nil or b ~= nil then
			return a, b
		end
	end
end

function std.mod_init(f, ...)
	__mod_callback_reg(f, 'init', ...)
	if std.initialized then -- require from game
		f(...)
	end
end

function std.mod_done(f, ...)
	__mod_callback_reg(f, 'done', ...)
end

function std.mod_start(f, ...)
	__mod_callback_reg(f, 'start', ...)
end

function std.mod_cmd(f, ...)
	__mod_callback_reg(f, 'cmd', ...)
end

function std.mod_step(f, ...)
	__mod_callback_reg(f, 'step', ...)
end

function std.mod_save(f, ...)
	__mod_callback_reg(f, 'save', ...)
end

function std.hook(o, f)
	local ff
	if type(o) ~= 'function' then
		ff = function()
			return o
		end
	else
		ff = o
	end
	return function(...)
		return f(ff, ...)
	end
end

local substs

local function xref_prep(str)
	local oo, self
	local a = {}
	local s = str
	local i = s:find('\001', 1, true)
	if not i then
		return str
	end
	oo = std.strip(s:sub(1, i - 1))
	s = s:sub(i + 1)
	if oo:find('@', 1, true) == 1 or oo:find('$', 1, true) then -- call '@' obj (aka xact) or '$' aka subst
		local o = std.split(oo)[1]
		local ii = oo:find("[ \t]")
		if ii then
			a = std.strip(oo:sub(ii))
			a = std.cmd_parse(a)
		end
		self = std.ref(o)
	else
		if oo:find("^# [0-9-]+") then
			self = std.ref(std.tonum(oo:sub(3)))
		elseif std.is_tag(oo) then -- #tag?
			self = std.here():lookup(oo)
		else
			self = std.ref(oo)
		end
	end
	if not std.is_obj(self) then
		if std.debug_xref then
			std.err("Wrong object in xref: "..std.tostr(oo), 2)
		else
			std.dprint("Wrong xref: "..std.tostr(oo))
			return s
		end
	end
	if type(self.nam) == 'string' and self.nam:find('$', 1, true) == 1 then -- subst
		table.insert(a, s)
		substs = true
		local r, v = std.method(self, 'act', std.unpack(a))
		if not v then
			return s
		end
		return std.tostr(r)
	end
	return iface:xref(s, self, std.unpack(a));
end

local fmt_refs

local function fmt_prep(str)
	local s = str:gsub("^{", ""):gsub("}$", "")
	s = s:gsub('\\?['..std.delim..']', { [std.delim] = '\001' });
	local l = s:find('\001', 1, true)
	if l == 1 then
		return str
	end
	if not l then
		s = s .. '\001'
	end
	l = s:find('\001', 1, true)
	table.insert(fmt_refs, s:sub(1, l - 1))
	local n = string.format("%d%s", #fmt_refs, std.delim)
	return "{"..n..s:sub(l + 1).."}"
end

local function fmt_post(str)
	local s = str:gsub("^{", ""):gsub("}$", ""):gsub('\\?['..std.delim..']',
		{ [std.delim] = '\001' } );
	local l = s:find('\001')
	if not l or l == 1 then
		return str
	end
	local n = std.tonum(s:sub(1, l - 1)) or 0
	if not fmt_refs[n] then
		return str
	end
	s = fmt_refs[n]..s:sub(l)
	return xref_prep(std.unesc(s))
end

function std.for_each_xref_outer(s, fn)
	local orig = s
	s = string.gsub(s, '\\?[\\{}]',
			{ ['{'] = '\001', ['}'] = '\002', [ '\\{' ] = '\\{', [ '\\}' ] = '\\}' });
	local start
	while true do
		start = s:find('\001')
		if not start then break end
		local idx = 1
		local n = start
		while idx > 0 do
			n = s:find('[\001\002]', n + 1)
			if not n then
				break
			end
			if s:sub(n, n) == '\001' then
				idx = idx + 1
			else
				idx = idx - 1
			end
		end
		if idx == 0 then
			local new = fn(s:sub(start, n):gsub('[\001\002]', {['\001'] = '{', ['\002'] = '}'}))
			if start == 1 then
				s = new..s:sub(n + 1)
			else
				s = s:sub(1, start - 1)..new..s:sub(n + 1)
			end
		else
			std.err("Unpaired '{' in:"..std.tostr(orig), 2)
			break
		end
	end
	s = s:gsub('[\001\002]', { ['\001'] = '{', ['\002'] = '}' });
	return s
end

function std.for_each_xref(s, fn)
	s = string.gsub(s, '\\?[\\{}]',
			{ ['{'] = '\001', ['}'] = '\002', [ '\\{' ] = '\\{', [ '\\}' ] = '\\}' });
	local function prep(str)
		str = str:gsub("[\001\002]", "")
		str = fn('{'..str..'}')
		return str
	end
	s = string.gsub(s, '(\001[^\001\002]+\002)', prep)
	s = s:gsub('[\001\002]', { ['\001'] = '{', ['\002'] = '}' });
	return s
end

std.fmt = function(str, fmt, state)
	if type(str) ~= 'string' then
		return
	end
	local s = str
	s = string.gsub(s, '[\t \n]+', std.space_delim);
	s = string.gsub(s, '\\?[\\^]', { ['^'] = '\n', ['\\^'] = '^'} ):gsub("\n[ \t]+", "\n")
	local first = true
	while true do
		fmt_refs = {}
		substs = false
		s = std.for_each_xref(s, fmt_prep) -- rename all {}
		if first and type(fmt) == 'function' then
			s = fmt(s, state)
		end
		s = std.for_each_xref(s, fmt_post) -- rename and xref
		if not substs then
			break
		end
		first = false
	end
	s = s:gsub('\\?'..'[{}]', { ['\\{'] = '{', ['\\}'] = '}' })
	if state then
		s = s:gsub('\\?'..std.delim, { ['\\'..std.delim] = std.delim })
	end
	return s
end


local lua_keywords = {
	["and"] = true,
	["break"] = true,
	["do"] = true,
	["else"] = true,
	["elseif"] = true,
	["end"] = true,
	["false"] = true,
	["for"] = true,
	["function"] = true,
	["goto"] = true,
	["if"] = true,
	["in"] = true,
	["local"] = true,
	["nil"] = true,
	["not"] = true,
	["or"] = true,
	["repeat"] = true,
	["return"] = true,
	["then"] = true,
	["true"] = true,
	["until"] = true,
	["while"] = true,
}

std.setmt(stead, {
	__call = function(_, k)
		return std.ref(k)
	end;
})


function std.is_system(v)
	if not std.is_obj(v) then
		return false
	end
	local n = v.nam
	if type(n) == 'string' then
		if n:byte(1) == 0x40 or n:byte(1) == 0x24 then
			return true
		end
	end
	return false
end

function std.is_obj(v, t)
	if type(v) ~= 'table' then
		return false
	end
	return v['__'..(t or 'obj')..'_type']
end

function std.class(self, inh)
--	self.__parent = function(s)
--		return inh
	--	end;
	self.nam = '*class*';
	self.__call = function(v, n, ...)
		if std.is_obj(v) and type(n) == 'string' then
			-- variable access
			return function(val)
				if std.game then
					rawset(v.__var, n, true)
					rawset(v.__ro, n, nil)
					return rawset(v, n, val or false)
				end
				return rawset(v.__ro, n, val or false)
			end
		end
		n = v:new(n, ...)
		std.setmt(n, v)
		return n
	end;
	self.__tostring = function(s)
		if not std.is_obj(s) then
			local os = self.__tostring
			self.__tostring = nil
			local t = std.tostr(s)
			self.__tostring = os
			return t
		end
		return std.dispof(s)
	end;
	self.__pow = function(s, b)
		if type(b) == 'string' or type(b) == 'number' then
			if std.is_tag(b) then
				return std.rawequal(s.tag, b)
			else
				return std.rawequal(s.nam, b)
			end
		end
		return std.rawequal(s, b)
	end;
	self.__dirty = function(s, v)
		local o = rawget(s, '__dirty_flag')
		if v ~= nil then
			if std.game then
				rawset(s, '__dirty_flag', v)
			end
			return s
		end
		return o
	end;
	self.__index = function(t, k)
		local ro = type(rawget(t, '__ro')) == 'table' and t.__ro
		local v
		if ro then
			v = rawget(ro, k)
		end
		if v == nil then
			return self[k]
		end
		if ro and std.game and type(v) == 'table' then
			-- make rw if simple table
			if type(v.__dirty) ~= 'function' then
				t.__var[k] = true
				rawset(t, k, v)
				ro[k] = nil
			end
		end
		return v
	end;
	self.__newindex = function(t, k, v)
		local ro = std.is_obj(t) and t.__ro

		if ro and not std.game then
			rawset(ro, k, v)
			return
		end

		t:__dirty(true)
		if ro then
			if (type(v) == 'function' and not std.functions[v]) then
				std.err("Wrong variable operation: "..std.tostr(k).. " at "..std.tostr(t), 2)
			end
			if std.nostrict or (type(k) == 'string' and k:find('^__')) or t.__var[k] or ro[k] ~= nil then
				t.__var[k] = true
			else
				std.err("Set unitialized variable: "..std.tostr(k).." at "..std.tostr(t), 2)
			end
			ro[k] = nil
		end
		if std.is_obj(v, 'list') and std.is_obj(t) then
			v:attach(t)
		end
		rawset(t, k, v)
	end
	std.setmt(self, inh or { __call = self.__call })
	return self
end

function std.is_tag(n)
	return type(n) == 'string' and n:byte(1) == 0x23
end

function std.sort(t, fn)
	local prio = {}
	local v
	for i = 1, #t do
		v = t[i]
		prio[i] = { v = v, i = i }
	end
	table.sort(prio, function(a, b)
		local r = fn(a.v, b.v)
		if type(r) == 'boolean' then
			return r
		end
		return a.i < b.i
	end)
	for i = 1, #prio do
		t[i] = prio[i].v
	end
end

std.list = std.class {
	__list_type = true;
	new = function(_, v)
		if type(v) ~= 'table' then
			std.err ("Wrong argument to std.list:"..std.tostr(v), 2)
		end
		if std.is_obj(v, 'list') then -- already list
			return v
		end
		v.__list = {} -- where is attached
		-- std.setmt(v, s)
		return v
	end;
	__ini = function(s, o)
		for i = 1, #s do
			local k = s[i]
			s[i] = std.ref(k)
			if not std.is_obj(s[i]) then
				if not o then
					std.err("Wrong item in list: "..std.tostr(k), 2)
				else
					std.err("Wrong item in list: "..std.tostr(k).." in "..std.dispof(o), 2)
				end
			end
			s:__attach(s[i])
		end
		if o then
			s:attach(o)
		end
		s:sort()
	end;
	sort = function(s)
		std.sort(s, function(a, b)
			local p1 = std.tonum(a.pri) or 0
			local p2 = std.tonum(b.pri) or 0
			if p1 == p2 then return nil end
			return p1 < p2
		end)
	end;
	display = function(s)
		local r
		for i = 1, #s do
			if r then
				r = r .. std.space_delim
			end
			local o = s[i]
			if o:visible() then
				local disp = o:display()
				local d = o:__xref(disp)
				if type(d) == 'string' then
					r = (r or '').. d
				end
				if not o:closed() then
					d = o.obj:display()
					if type(d) == 'string' then
						r = (r and (r .. std.space_delim) or '') .. d
					end
				end
			end
		end
		return r
	end;
	disable = function(s)
		for i = 1, #s do
			s[i]:disable()
		end
	end;
	enable = function(s)
		for i = 1, #s do
			s[i]:enable()
		end
	end;
	close = function(s)
		for i = 1, #s do
			s[i]:close()
		end
	end;
	open = function(s)
		for i = 1, #s do
			s[i]:open()
		end
	end;
	attach = function(s, o) -- attach to object
		s:detach(o)
		table.insert(s.__list, o)
	end;
	detach = function(s, o) -- detach from object
		for i = 1, #s.__list do
			if s.__list[i] == o then
				table.remove(s.__list, i)
				break
			end
		end
	end;
	__attach = function(s, o) -- attach object to list
		s:__detach(o)
		table.insert(o.__list, s)
	end;
	__detach = function(s, o) -- detach object from list
		for i = 1, #o.__list do
			if o.__list[i] == s then
				table.remove(o.__list, i)
				break
			end
		end
	end;
	add = function(s, n, pos)
		local o = s:lookup(n)
		if o then
			return o -- already here
		end
		if pos then
			if type(pos) ~= 'number' then
				std.err("Wrong parameter to list.add:"..std.tostr(pos), 2)
			end
			if pos > #s then
				pos = nil -- add to last position
			elseif pos < 0 then
				pos = #s + pos + 1
			end
			if pos and pos <= 0 then
				pos = 1
			end
		end
		o = std.ref(n)
		if not o then
			std.err("Wrong argument to list:add(): "..std.tostr(n), 2)
		end
		s:__dirty(true)
		s:__attach(o)
		if pos then
			table.insert(s, pos, o)
		else
			table.insert(s, o)
		end
		s:sort()
		return o
	end;
	for_each = function(s, fn, ...)
		if type(fn) ~= 'function' then
			std.err("Wrong parameter to list:for_each: "..std.tostr(fn), 2)
		end
		for i = 1, #s do
			local r, v = fn(s[i], ...)
			if r ~= nil or v ~= nil then
				return r, v
			end
		end
	end;
	lookup = function(s, n)
		local o, tag
		if std.is_tag(n) then
			tag = n
		else
			o = std.ref(n)
		end
		for i = 1, #s do
			if s[i] == o or (tag and s[i].tag == tag) then
				return s[i], i
			end
		end
	end;
	srch = function(s, n)
		local o, i = s:lookup(n)
		if not o or not o:visible() then
			return
		end
		return o, i
	end;
	empty = function(s)
		return (#s == 0)
	end;
	cat = function(s, from, pos)
		if not std.is_obj(from, 'list') then
			std.err("Wrong argument to list:cat(): "..std.tostr(from), 2)
		end
		if not pos then pos = #s + 1 end
		for _, v in ipairs(from) do
			s:add(v, pos)
			pos = pos + 1
		end
		return s
	end;
	zap = function(s) -- delete all objects
		local l = {}
		for i = 1, #s do
			table.insert(l, s[i])
		end
		for i = 1, #l do
			s:del(l[i])
		end
		return s
	end;
	del = function(s, n)
		local o, i = s:lookup(n)
		if i then
			s:__dirty(true)
			s:__detach(o)
			table.remove(s, i)
			s:sort()
			return o, i
		end
	end;
	replace = function(s, n, w)
		local o, i = s:del(n)
		if o then
			return s:add(w, i)
		end
	end;
	__dump = function(s, recurse)
		local rc
		for i = 1, #s do
			local v = s[i]
			if std.is_obj(v) and v:visible() then
				local vv, n
				if type(v.nam) == 'number' then
					n = '# '..std.tostr(v.nam)
				else
					n = v.nam
				end
				local disp = std.dispof(v)
				if disp then
					if rc then
						rc = rc .. std.delim
					else
						rc = ''
					end
					vv = '{'..std.esc(n)..std.delim..std.esc(disp)..'}'
					rc = rc .. vv
				end
				if recurse and not v:closed() then
					vv = v:__dump(recurse)
					if vv then
						if rc then rc = rc .. std.delim else rc = '' end
						rc = rc .. vv
					end
				end
			end
		end
		return rc
	end;
	__save = function(s, fp, n)
		if not s:__dirty() then
			return
		end
		fp:write(string.format("%s = std.list { ", n))
		for i = 1, #s do
			local vv = std.deref(s[i])
			if not vv then
				std.err ("Can not do deref on: "..std.tostr(s[i]), 2)
			end
			if i ~= 1 then
				fp:write(string.format(", "))
			end
			if type(vv) == 'number' then
				fp:write(string.format("%d", vv))
			else
				fp:write(string.format("%q", vv))
			end
		end
		fp:write(" }:__dirty(true)\n")

	end;
}
std.save_var = function(vv, fp, n)
	if type(vv) == 'boolean' or type(vv) == 'number' then
		fp:write(string.format("%s = ", n))
		fp:write(std.tostr(vv)..'\n')
	elseif type(vv) == 'string' then
		fp:write(string.format("%s = ", n))
		fp:write(string.format("%q\n", vv))
	elseif type(vv) == 'function' then
		if std.functions[vv] and std.functions[vv] ~= n then
			local k = std.functions[vv]
			fp:write(string.format("%s = %s\n", n, k))
		else
			std.err("Can not save variable (function): "..n, 2)
		end
	elseif type(vv) == 'table' then
		if std.tables[vv] and std.tables[vv] ~= n then
			local k = std.tables[vv]
			fp:write(string.format("%s = %s\n", n, k))
		elseif std.is_obj(vv) then
			local d = std.deref(vv)
			if not d then
				std.err("Can not deref object:"..std.tostr(vv), 2)
			end
			fp:write(string.format("%s = ", n))
			if type(d) == 'string' then
				fp:write(string.format("std %q\n", d))
			else
				fp:write(string.format("std(%d)\n", d))
			end
		elseif type(vv.__save) == 'function' then
			vv:__save(fp, n)
		else
			fp:write(string.format("%s = %s\n", n,  std.dump(vv, true)))
--			std.save_table(vv, fp, n)
		end
	elseif vv == nil then
		fp:write(string.format("%s = nil\n", n))
	elseif type(vv) == 'userdata' and type(vv.__save) == 'function' then
		vv:__save(fp, n)
	else
		std.err("Can not save var: "..n, 2)
	end
end

std.save_members = function(vv, fp, n)
	local l
	for k, v in pairs(vv) do
		if type(k) == 'number' then
			l = string.format("%s%s", n, std.varname(k))
			std.save_var(v, fp, l)
		elseif type(k) == 'string' then
			l = string.format("%s%s", n, std.varname(k))
			std.save_var(v, fp, l)
		end
	end
end

std.save_table = function(vv, fp, n)
	fp:write(string.format("%s = {}\n", n))
	std.save_members(vv, fp, n)
end

function std:reset(fn) -- reset state
	local reset
	if std.ref 'game'.__started or fn then
		self:done()
		self:init()
		reset = true
	end
	if fn ~= 'main3.lua' then
		std.startfile = fn -- another start file
	end
	if reset then
		std.dofile(fn or 'main3.lua')
	end
end

function std:load(fname) -- load save
	self:reset()
	std.ref 'game':__ini()

	local f, err = std.loadfile(fname) -- load all diffs
	if not f then
		std.err(err, 2)
	end

	local strict = std.nostrict; std.nostrict = true;
	if DEBUG then
		std.noerror = true
		local st, r = std.pcall(f)
		if not st then
			std.dprint(r)
		end
		std.noerror = false
	else
		f();
	end
	std.nostrict = strict

	std.ref 'game':__ini(true)
	std.ref 'game':__start(true)
	return self.game:lastdisp()
end

local function in_section(name, fn)
	name = "__in_"..name
	local old = std[name]
	std[name] = true
	local r, v = fn()
	std[name] = old or false
	return r, v
end

function std.gamefile(fn, reset) -- load game file
	if type(fn) ~= 'string' then
		std.err("Wrong paramter to stead:file: "..std.tostr(fn), 2)
	end
	if not fn:find("%.lua$") then
		fn = fn .. '.lua'
	end
	if reset then
		std:reset(fn)
		std.ref 'game':__ini()
		local r, v = std.ref 'game':__start()
		if type(r) == 'string' and std.cctx() then
			std.pr(r)
		end
		return r, v
	end
	std.game = nil
	in_section ('gamefile', function() std.dofile(fn) end)
	std.ref 'game':__ini()
	table.insert(std.files, fn) -- remember it
end

-- luacheck: no self

function std:save(fp)
	local close
	local name, name_tmp
	if type(fp) == 'string' then
		name, name_tmp = fp, fp .. '.tmp'
		fp = io.open(name_tmp, "wb");
		if not fp then
			return nil, false -- can create file
		end
		close = true
	end
	local n
	if std.type(std.savename) == 'function' then
		n = std.savename()
	end
	if std.type(n) == 'string' then
		fp:write("-- $Name: "..n:gsub("\n","\\n").."$\n");
	end
	fp:write("local std = stead\n");
	-- reset
	if std.startfile then
		fp:write(string.format("std:reset(%q)\n", std.startfile))
		fp:write(string.format("std 'game':ini()\n"))
	end
	-- files
	for i = 1, #std.files do
		fp:write(string.format("std.gamefile(%q)\n", std.files[i]))
	end

	std.busy(true)
	std.for_each_obj(function(v)
		if v.__dynamic then
			std.busy(true)
			v:save(fp, string.format("std(%s)", std.deref_str(v)))
		end
	end)

	std.mod_call('save', fp)

	std.for_each_obj(function(v)
		if not v.__dynamic then
			std.busy(true)
			v:save(fp, string.format("std(%s)", std.deref_str(v)))
		end
	end)
	if close then
		fp:flush();
		fp:close();
		std.os.remove(name);
		std.os.rename(name_tmp, name);
	end
	std.busy(false)
	return std.game:lastdisp() -- same scene
end

local rnd_seed = 1980 + 1978
function std:init()
	std.rawset(_G, 'iface', std.ref '@iface') -- force iface override
	std.world { nam = 'game', player = 'player', codepage = 'UTF-8',
		dsc = [[STEAD3, 2020 by Peter Kosyh^https://instead-hub.github.io^^]] };
	std.room { nam = 'main' }
	std.player { nam = 'player', room = 'main' }

	rnd_seed = (std.os.time(stead.os.date("*t")) + rnd_seed)
	std.rnd_seed(rnd_seed)

	std.mod_call('init') -- init modules
	std.initialized = true
end

function std:done()
	std.mod_call_rev('done')
	std.mod_unload() -- unload hooks from includes
	local objects = {}
	std.for_each_obj(function(v)
		local k = std.deref(v)
		if std.is_system(v) then
			objects[k] = v
		else
			std.dprint("Deleting "..k)
		end
	end)
	std.objects = objects
	std.tags = {}
	std.next_dynamic = -1
	std.files = {}
	std.startfile = false
--	std.modules = {}
	std.includes = {}
	std.initialized = false
	std.game = nil
	std.rawset(_G, 'init', nil)
	std.rawset(_G, 'start', nil)
end
-- luacheck: self

function std.for_all(fn, ...)
	if type(fn) ~= 'function' then
		std.err("Wrong 1-st argument to for_all(): "..std.tostr(fn), 2)
	end
	local a = {...}
	for i = 1, #a do
		fn(a[i])
	end
end

function std.for_each_obj(fn, ...)
	local oo = std.objects
	for _, v in pairs(oo) do
		if std.is_obj(v) then
			local a, b = fn(v, ...)
			if a ~= nil and b ~= nil then
				return a, b
			end
		end
	end
end

function std.dirty(o)
	if type(o) ~= 'table' or type(o.__dirty) ~= 'function' then
		return false
	end
	return o:__dirty()
end

function std.deref_str(o)
	local k = std.deref(o)
	if type(k) == 'number' then
		return std.tostr(k)
	elseif type(k) == 'string' then
		return std.string.format("%q", k)
	end
	return
end

function std.varname(k)
	if type(k) == 'number' then
		return string.format("[%d]", k)
	elseif type(k) == 'string' then
		if not lua_keywords[k] then
			return string.format(".%s", k)
		else
			return string.format("[%q]", k)
		end
	end
end

local function next_dynamic(n)
	if n then
		std.next_dynamic = n
	end
	std.next_dynamic = std.next_dynamic - 1
	if std.next_dynamic < -std.max_dynamic then
		std.next_dynamic = - 1
	end
	return std.next_dynamic
end

local function dyn_name()
	local oo = std.objects
	if not oo[std.next_dynamic] then
		local n = std.next_dynamic
		next_dynamic()
		return n
	end

	local on = std.next_dynamic
	local n = next_dynamic()

	while oo[n] and n ~= on do
		n = n - 1
		if n < -std.max_dynamic then
			n = -1
		end
	end

	if oo[n] then
		std.err("No free ids for dynamic objects", 2)
	end

	next_dynamic(n)

	return n
end

local function tag_name(t)
	local oo = std.objects
	local tt = std.tags[t] or {}
	local n = t:sub(2) .. '#'..std.tonum(#tt)
	if oo[n] then return #oo + 1 end -- collision
	table.insert(tt, n)
	std.tags[t] = tt
	return n
end

std.obj = std.class {
	__obj_type = true;
	type = function(self, t)
		return std.is_obj(self, t)
	end;
	with = function(self, ...)
		local a = {...}
		for i = 1, #a do
			if type(a[i]) == 'table' then
				for k = 1, #a[i] do
					table.insert(self.obj, a[i][k])
				end
			else
				table.insert(self.obj, a[i])
			end
		end
		return self
	end;
	new = function(self, v)
		if std.game and not std.__in_new and not std.__in_gamefile then
			std.err ("Use std.new() to create dynamic objects:"..std.tostr(v), 2)
		end
		local oo = std.objects
		if type(v) ~= 'table' then
			std.err ("Wrong argument to std.obj:"..std.tostr(v), 2)
		end
		if std.is_tag(v.nam) then
			rawset(v, 'tag', v.nam)
			rawset(v, 'nam', nil)
		end

		if v.nam == nil then
			if std.__in_new then
				rawset(v, 'nam', dyn_name())
			elseif std.is_tag(v.tag) then
				rawset(v, 'nam', tag_name(v.tag))
			else
				rawset(v, 'nam', #oo + 1)
			end
			rawset(v, '__autoname', true)
		elseif type(v.nam) ~= 'string' and type(v.nam) ~= 'number' then
			std.err ("Wrong .nam in object.", 2)
--		elseif type(v.nam) == 'string' and v.nam:find('#[0-9]+$') then
--			std.err ("You can not use #<number> in object name: "..v.nam, 2)
		end

		if oo[v.nam] and not std.is_system(oo[v.nam]) then
			if v.nam ~= 'main' and v.nam ~= 'player' and v.nam ~= 'game' then
				std.err ("Duplicated object: "..v.nam, 2)
			end
		end
		local ro = {}
		local vars = {}
		local raw = {}
		for i = 1, #v do
			if type(v[i]) ~= 'table' then
				std.err("Wrong declaration: "..std.tostr(v[i]), 2)
			end
			local var = (v[i].__var_type == true) -- raw or var mode
			for key, val in pairs(v[i]) do
				if type(key) ~= 'string' then
					std.err("Wrong var name: "..std.tostr(key), 2)
				end
				raw[key] = not var
				rawset(v, key, val)
			end
		end
		for _ = 1, #v do
			table.remove(v, 1)
		end
		if not v.obj then
			rawset(v, 'obj', {})
		end
		if type(v.obj) ~= 'table' then
			std.err ("Wrong .obj attr in object:" .. v.nam, 2)
		end
		v.obj = std.list(v.obj)
--		v.obj:attach(v)
		for key, val in pairs(v) do
			if not std.nostrict_new and type(self[key]) == 'function' and type(val) ~= 'function' then
				std.err("Overwrited object method: '"..std.tostr(key).. "' in: "..std.tostr(v.nam), 2)
			end
			if not raw[key] then
				ro[key] = val
				rawset(v, key, nil)
			end
		end
		rawset(v, '__ro', ro)
		rawset(v, '__var', vars)
		rawset(v, '__list', {}) -- in what list(s)
		oo[ro.nam] = v
		-- std.setmt(v, self)
		if std.__in_init then
			table.insert(std.__in_init, v)
		end
		return v
	end;
	actions = function(s, t, v)
		t = t or 'act'
		if type(t) ~= 'string' then
			std.err("Wrong argument to obj:actions(): "..std.tostr(t), 2)
		end
		local ov = s['__nr_'..t] or 0
		if type(v) == 'number' or v == false then
			s['__nr_'..t] = v or nil
		end
		return ov
	end;
	__renam = function(s, new)
		local oo = std.objects
		if new == s.nam then
			return
		end
		if oo[new] then
			std.err ("Duplicated obj name: "..std.tostr(new), 2)
		end
		oo[s.nam] = nil
		oo[new] = s
		rawset(s, 'nam', new)
		return s
	end;
	__ini = function(s, ...)
		for _, v in pairs(s) do
			if std.is_obj(v, 'list') then
				v:__ini(s)
			end
		end
		for _, v in pairs(s.__ro) do
			if std.is_obj(v, 'list') then
				v:__ini(s)
			end
		end
		return std.call(s, 'ini', ...)
	end;
	inroom = function(s, r)
		local rooms = r or {}
		local ww = {}
		local o
		if type(rooms) ~= 'table' then
			std.err("Wrong argument to room: "..std.tostr(r), 2)
		end
		s:where(ww)
		while #ww > 0 do
			local nww = {}
			for _, v in ipairs(ww) do
				if std.is_obj(v, 'room') then
					if not o then
						o = v
					end
					table.insert(rooms, v)
				else
					v:where(nww)
				end
			end
			ww = nww
		end
		return o
	end;
	__where = function(s) -- lists
		local list = s.__list
		local r = { }
		for i = 1, #list do
			table.insert(r, list[i])
		end
		return r
	end;
	where = function(s, w)
		local list = s.__list
		local r = w or { }
		local o
		if type(r) ~= 'table' then
			std.err("Wrong argument to obj:where: "..std.tostr(w), 2)
		end
		for i = 1, #list do
			local l = list[i]
			local ll = l.__list

			for k = 1, #ll do
				local oo = ll[k]
				if std.is_obj(oo) and oo:lookup(s) then
					o = o or oo
					if o and not w then
						break
					end
					table.insert(r, oo)
				end
			end
		end
		return o
	end;
	purge = function(s)
		local list = s:__where()
		for i = 1, #list do
			list[i]:del(s)
		end
		return s
	end;
	remove = function(s, w)
		if w then
			w = std.ref(w)
			if not w then
				std.err ("Wrong where in obj:remove()", 2)
			end
			local o, l = w:lookup(s)
			if not o then
				return o
			end
			l:del(o)
			return o, { w }
		end
		local where = {}
		s:where(where)
		for i = 1, #where do
			local o = where[i]
			local _, l = o:lookup(s)
			if l then
				l:del(s)
			end
		end
		return s, where
	end;
	close = function(s)
		s.__closed = true
		return s
	end;
	open = function(s)
		s.__closed = nil
		return s
	end;
	closed = function(s)
		return s.__closed or false
	end;
	disable = function(s)
		s.__disabled = true
		return s
	end;
	enable = function(s)
		s.__disabled = nil
		return s
	end;
	disabled = function(s)
		return s.__disabled or false
	end;
	empty = function(s)
		for i = 1, #s.obj do
			local o = s.obj[i]
			if not o:disabled() then
				return false
			end
		end
		return true
	end;
	save = function(s, fp, n)
		if std.debug_save then
			std.dprint("Saving: "..std.nameof(s))
		end
		if s.__dynamic then -- create
			local nn = std.functions[s.__dynamic.fn]
			if not nn then
				std.err("Error while saving dynamic object: "..std.tostr(s), 2)
			end
			local arg = s.__dynamic.arg
			local l = ''
			for i = 1, #arg do
				if arg[i] == s then
					std.err("Error while saving dynamic object: "..std.tostr(s).." Argument is self-obj.", 2)
				end
				l = l .. ', '..std.dump(arg[i], true, true) -- strict, nested
			end
			if type(s.nam) == 'number' then
				l = string.format("std.new(%s%s):__renam(%d)\n", nn, l, s.nam)
			else
				l = string.format("std.new(%s%s)\n", nn, l, s.nam)
			end
			fp:write(l)
		end
		for k, _ in pairs(s.__ro) do
			local o = s.__ro[k]
			if std.dirty(o) then
				local l = string.format("%s%s", n, std.varname(k))
				std.save_var(s[k], fp, l)
			end
		end
		for k, _ in pairs(s.__var) do
			local l = string.format("%s%s", n, std.varname(k))
			std.save_var(s[k], fp, l)
		end
	end;
	display = function(self)
		local d = std.call(self, 'dsc')
		return d
	end;
	__xref = function(self, text, force)
		if type(text) ~= 'string' then
			return
		end

		local nam = self.nam

		if type(nam) == 'number' then
			nam = '# '..std.tostr(nam)
		end
		local rep = false
		local s = std.for_each_xref_outer(text, function(str)
			rep = true
			local s = str:gsub("^{", ""):gsub("}$", "")
			local test = string.gsub(s, '\\?[\\{}'..std.delim..']',
				{ ['{'] = '\001', ['}'] = '\003',
				  [std.delim] = '\002' });
			while true do
				local sub = test:gsub("\001[^\001\003]+\003", "")
				if sub == test then
					break
				end
				test = sub
			end
			local a = test:find('\002', 1, true)
			if not a or test:byte(a) == 1 then -- need to be |
				return '{'..(std.esc(nam)..std.delim..s)..'}'
			end
			return str
		end)
		if not rep and force then -- nothing todo?
			return '{'..(std.esc(nam)..std.delim..s)..'}'
		end
		return s;
	end;
	visible = function(s)
		return not s:disabled()
	end;
	srch = function(s, w)
		local o, l, idx

		if not s:visible() or s:closed() then
			return
		end

		l = s.obj

		o, idx = l:srch(w)

		if o then
			return o, l, idx
		end

		for i = 1, #s.obj do
			local v = s.obj[i]
			o, l, i = v:srch(w)
			if o then
				return o, l, i
			end
		end
	end;
	lookup = function(s, w)
		local l = s.obj
		local o, idx = l:lookup(w)
		if o then
			return o, l, idx
		end
		for i = 1, #s.obj do
			local v = s.obj[i]
			o, l, i = v:lookup(w)
			if o then
				return o, l, i
			end
		end
	end;
	for_each = function(s, fn, ...)
		local r, v
		for i = 1, #s.obj do
			r, v = fn(s.obj[i], ...)
			if r ~= nil then
				return r, v
			end
			if v ~= false then -- recurse
				r, v = s.obj[i]:for_each(fn, ...)
			end
			if r ~= nil then
				return r, v
			end
		end
	end;
	__dump = function(s)
		if not s:visible() or s:closed() then
			return
		end
		return s.obj:__dump(true)
	end;
	lifeon = function(s)
		local game = std.ref 'game'
		game:lifeon(s)
		return s
	end;
	lifeoff = function(s)
		local game = std.ref 'game'
		game:lifeoff(s)
		return s
	end;
	live = function(s)
		local game = std.ref 'game'
		return game:live(s)
	end;
};

function std.var(v)
	if type(v) ~= 'table' then
		std.err("Wrong std.var() argument", 2)
	end
	v.__var_type = true
	return v
end

std.room = std.class({
	__room_type = true;
	from  = function(s)
		return s.__from or s
	end;
	new = function(_, v)
		if type(v) ~= 'table' then
			std.err ("Wrong argument to std.room:"..std.tostr(v), 2)
		end
		if not v.way then
			rawset(v, 'way',  {})
		end
		if type(v.way) ~= 'table' then
			std.err ("Wrong .way attr in object:" .. v.nam, 2)
		end
		v.way = std.list(v.way)
--		v.way:attach(v)
		v = std.obj(v)
		-- std.setmt(v, self)
		return v
	end;
	visited = function(s)
		return s.__visits
	end;
	visits = function(s)
		return s.__visits or 0
	end;
	srch = function(self, w)
		local r, v, i = std.obj.srch(self, w)
		if std.is_obj(r) then
			return r, v, i
		end
		r, v = self.way:lookup(w)
		if not std.is_obj(r) or r:disabled() or r:closed() then
			return
		end
		return r, self.way, v
	end;
	lookup = function(self, w)
		local r, v, i = std.obj.lookup(self, w)
		if std.is_obj(r) then
			return r, v, i
		end
		r, v = self.way:lookup(w)
		if std.is_obj(r) then
			return r, self.way, v
		end
		return
	end;
	scene = function(s)
		local title, dsc
		title = iface:title(std.titleof(s))
		dsc = std.call(s, 'dsc')
		return std.par(std.scene_delim, title or false, dsc)
	end;
	display = function(s)
		local deco = std.call(s, 'decor'); -- static decorations
		return std.par(std.scene_delim, deco or false, s.obj:display())
	end;
	visible = function(s)
		return not s:disabled() and not s:closed()
	end;
	__dump = function(s)
		return s.way:__dump()
	end;
}, std.obj);

std.world = std.class({
	__game_type = true;
	new = function(_, v)
		if type(v) ~= 'table' then
			std.err ("Wrong argument to std.pl:"..std.tostr(v), 2)
		end
		if not v.player then
			v.player = 'player'
		end
		if v.lifes == nil then
			rawset(v, 'lifes', {})
		end
		v.lifes = std.list(v.lifes)
		v = std.obj(v)
		-- std.setmt(v, self)
		return v
	end;
	time = function(s, t)
		local ov = s.__time or 0
		if t ~= nil then
			if type(t) ~= 'number' then
				std.err ("Wrong parameter to game:time: "..stead.tostr(t), 2)
			end
			s.__time = t
		end
		return ov
	end;
	__ini =  function(s, load)
		return s:ini(load)
	end;
	__start = function(s, load)
		std.mod_call('start', load)
		if type(std.rawget(_G, 'start')) == 'function' then
			start(load) -- start after load
		end
		s.__started = true
		if load ~= true then
			if std.game.player.room.__from then -- already entered
				return nil, true
			end
			local r, v = std.game.player:walk(std.game.player.room, false)
			return r, v
		end
	end;
	ini = function(s, load)
		if s.__in_ini then
			return -- break recursion
		end
		s.__in_ini = true std.obj.__ini(s, load) s.__in_ini = false

		s.player = std.ref(s.player) -- init game
		if not s.player then
			std.err ("Wrong player", 2)
		end

		std.for_each_obj(function(v)
			rawset(v, '__list', {}) -- reset all links
		end)

		std.for_each_obj(function(v) -- call ini of all objects
			if v ~= s then
				v:__ini(load)
			end
		end)

		if not std.game then
			if type(std.rawget(_G, 'init')) == 'function' then
				std.__in_init = {}
				init()
				for _, v in ipairs(std.__in_init) do
					v:__ini(load)
				end
				std.__in_init = false
			end
			std.game = s
		end

		local d = std.method(s, 'dsc')
		return std.fmt(d)
	end;
	lifeon = function(s, w, ...)
		if not w then
			s.__lifeoff = nil
			return
		end
		return s.lifes:add(w, ...)
	end;
	lifeoff = function(s, w)
		if not w then
			s.__lifeoff = true
			return
		end
		return s.lifes:del(w)
	end;
	live = function(s, w)
		if not w then
			return not s.__lifeoff
		end
		return s.lifes:lookup(w)
	end;
	set_pl = function(s, w)
		if not std.is_obj(w, 'player') then
			std.err("Wrong parameter to game:set_pl(): "..std.tostr(w), 2)
		end
		s.player = w
		w:need_scene(true)
	end;
	life = function(s)
		local av, vv
		s:events(false, false)
		if s.__lifeoff then
			return
		end
		local ll = {}

		for i = 1, #s.lifes do
			table.insert(ll, s.lifes[i])
		end

		for i = 1, #ll do
			local v, pre, st
			local o = ll[i]
			if not o:disabled() then
				v, st, pre = std.call(o, 'life');
				av, vv = s:events()
				if pre then -- hi-pri msg
					av = std.par(std.space_delim, av or false, v)
				else
					vv = std.par(std.space_delim, vv or false, v)
				end
				s:events(av or false, vv or false)
				if st == false then -- break cycle
					break
				end
			end
		end
	end;
	step = function(s)
		s:life()
		s.__time = s:time() + 1
	end;
	lastdisp = function(s, str)
		local ov = s.__lastdisp
		if str ~= nil then
			s.__lastdisp = str
		end
		return ov
	end;
	display = function(s, state)
		local l, av, pv
		local reaction = s:reaction() or nil
		if state then
			reaction = iface:em(reaction)
			av, pv = s:events()
			av = iface:em(av)
			pv = iface:em(pv)
			l = s.player:look() -- objects [and scene]
		end
		l = std.par(std.scene_delim, reaction or false,
			    av or false, l or false,
			    pv or false) or ''
		return l
	end;
	lastreact = function(s, t)
		local o = s.__lreaction
		if t == nil then
			return o
		end
		s.__lreaction = t or nil
		return o
	end;
	reaction = function(s, t)
		local o = s.__reaction
		if t == nil then
			return o
		end
		s.__reaction = t or nil
		return o
	end;
	events = function(s, av, pv)
		local oa = s.__aevents
		local op = s.__pevents
		if av ~= nil then
			s.__aevents = av or nil
		end
		if pv ~= nil then
			s.__pevents = pv or nil
		end
		return oa, op
	end;
	cmd = function(s, cmd)
		local r, v
		if not std.is_obj(s.player) then
			std.err("Wrong player object.", 2)
		end
		s.player:moved(false)
		s.player:need_scene(false)
		std.abort_cmd = false
		r, v = std.mod_call('cmd', cmd)
			-- luacheck: push ignore
		if r ~= nil or v ~= nil then
			-- luacheck: pop
		elseif cmd[1] == nil or cmd[1] == 'look' then
			if not s.__started then
				r, v = s:__start()
			else
				s.player:need_scene(true)
				v = true
			end
--			r, v = s.player:look()
		elseif cmd[1] == 'act' then
			if #cmd < 2 then
				return nil, false
			end
			local o = std.ref(cmd[2]) -- on what?
			if std.is_system(o) then
				local a = {}
				for i = 3, #cmd do
					table.insert(a, cmd[i])
				end
				r, v = std.call(o, 'act', std.unpack(a))
			else
				o = s.player:inspect(o)
				if not o then
					return nil, false -- wrong input
				end
				r, v = s.player:take(o)
				if not r and not v then
					r, v = s.player:action(o)
				end
			end
			-- if s.player:search(o)
		elseif cmd[1] == 'use' then
			if #cmd < 2 then
				return nil, false
			end
			local o1 = std.ref(cmd[2])
			local o2 = std.ref(cmd[3])
			o1 = s.player:srch(o1)

			if not o1 then
				return nil, false -- wrong input
			end
			if o1 == o2 or not o2 then -- inv?
				if not o1 then
					return nil, false -- wrong input
				end
				r, v = s.player:useit(o1)
			else
				r, v = s.player:useon(o1, o2)
			end
		elseif cmd[1] == 'go' then
			if #cmd < 2 then
				return nil, false
			end
			local o = std.ref(cmd[2])
			if not o then
				return nil, false -- wrong input
			end
			r, v = s.player:go(o)
		elseif cmd[1] == 'inv' then -- show inv
			r = s.player:__dump() -- just info
			v = nil
		elseif cmd[1] == 'way' then -- show ways
			r = s.player:where():__dump()
			v = nil
		elseif cmd[1] == 'save' then -- todo
			if #cmd < 2 then
				return nil, false
			end
			r = std:save(cmd[2])
			v = true
			std.abort()
		elseif cmd[1] == 'load' then -- todo
			if #cmd < 2 then
				return nil, false
			end
			r = std:load(cmd[2])
			v = true
			std.abort()
		end
		if r == nil and v == nil then
			v = false -- no reaction
		end

		if v == false or std.abort_cmd then
			if cmd[1] == 'save' then
				std.mod_call('step', nil)
			else
				std.mod_call('step', v)
			end
			return r, v
		end
-- v is true or nil
		s = std.game -- after reset game is recreated
		s:reaction(r or false)

		if v then
			s:step()
		end
		std.mod_call('step', v)
		r = s:display(v)
		if v then
			s:lastreact(s:reaction() or false)
			s:lastdisp(r)
		end
		return r, v
	end;
	aftertak = function(s, w) -- standard take action
		w = std.ref(w)
		local o = w:remove()
		s.player:inventory():add(o)
	end;
}, std.obj);

std.player = std.class ({
	__player_type = true;
	new = function(_, v)
		if type(v) ~= 'table' then
			std.err ("Wrong argument to std.pl:"..std.tostr(v), 2)
		end
		if not v.room then
			v.room = 'main'
		end
		v = std.obj(v)
		-- std.setmt(v, self)
		return v
	end;
	__ini = function(s, ...)
		s.room = std.ref(s.room)
		if not s.room then
			std.err ("Wrong player location: "..std.tostr(s), 2)
		end
		std.obj.__ini(s, ...)
	end;
	moved = function(s, v)
		local ov = s.__moved or false
		if v == nil then
			return ov
		end
		if type(v) ~= 'boolean' then
			std.err("Wrong parameter to player:moved: "..std.tostr(v), 2)
		end
		if v == false then v = nil end
		s.__moved = v
		return ov
	end;
	need_scene = function(s, v)
		local ov = s.__need_scene or false
		if v == nil then
			return ov
		end
		if type(v) ~= 'boolean' then
			std.err("Wrong parameter to player:need_scene: "..std.tostr(v), 2)
		end
		if v == false then v = nil end
		s.__need_scene = v
		return ov
	end;
	look = function(s)
		local scene
		local r = s:where()
		if s:need_scene() then
			scene = r:scene()
		end
		return std.par(std.scene_delim, scene or false, r:display())
	end;
	inspect = function(s, w)
		local r, v, i
		r, v, i = s:where():srch(w)
		if r ~= nil then
			return r, v, i
		end
		r, v, i = s:srch(w)
		if r ~= nil then
			return r, v, i
		end
		return
	end;
	lookup = function(self, w)
		local r, v, i = std.obj.lookup(self, w)
		if std.is_obj(r) then
			return r, v, i
		end
		r, v = self:inventory():lookup(w)
		if std.is_obj(r) then
			return r, self:inventory(), v
		end
		return
	end;
	have = function(s, w)
		local o, i = s:inventory():lookup(w)
		if not o then
			return o, i
		end
		if o:disabled() then
			return
		end
		return o, i
	end;
	useit = function(s, w, ...)
		return s:call('inv', w, ...)
	end;
	useon = function(s, w1, w2)
		w1 = std.ref(w1)
		w2 = std.ref(w2)

		if w2 and w1 ~= w2 then
			return s:call('use', w1, w2)
		end
		-- inv mode?
		return s:call('inv', w1, w2)
	end;
	call = function(_, m, w1, w2, ...)
		local w
		if type(m) ~= 'string' then
			std.err ("Wrong method in player.call: "..std.tostr(m), 2)
		end

		w = std.ref(w1)
		if not std.is_obj(w) then
			std.err ("Wrong parameter to player.call: "..std.tostr(w1), 2)
		end

		local r, v, t, _
		r, v = std.call(std.ref 'game', 'on'..m, w, w2, ...)
		t = std.par(std.scene_delim, false, r)
		if v == false then
			return t or r, true, false
		end

		if m == 'use' and w2 then
			r, v = std.call(w2, 'used', w, ...)
			t = std.par(std.scene_delim, t or false, r)
			if v == true then -- false from used --> pass to use
				w2['__nr_used'] = (w2['__nr_used'] or 0) + 1
				r, _ = std.call(std.ref 'game', 'afteruse', w, w2, ...)
				t = std.par(std.scene_delim, t or false, r)
				return t or r, true -- stop chain
			end
		end

		r, v = std.call(w, m, w2, ...)
		t = std.par(std.scene_delim, t or false, r)
		if v == true then
			w['__nr_'..m] = (w['__nr_'..m] or 0) + 1
			r, _ = std.call(std.ref 'game', 'after'..m, w, w2, ...)
			t = std.par(std.scene_delim, t or false, r)
			return t or r, true
		end
		if r == true and v == false then
			return r, v -- menu hack
		end
		if not v and not r then -- no reaction
			r, v = std.call(std.ref 'game', m, w, w2, ...)
			t = std.par(std.scene_delim, t or false, r)
			if not v then
				return
			end
		end
		return t or r, true
	end;
	action = function(s, w, ...)
		return s:call('act', w, ...)
	end;
	inventory = function(s)
		return s.obj
	end;
	take = function(s, w, ...)
		return s:call('tak', w, ...)
	end;
	walkin = function(s, w, ...)
		return s:walk(w, false, true, ...)
	end;
	walkout = function(s, w, ...)
		if w == nil then
			w = s:where():from()
		end
		return s:walk(w, true, false, ...)
	end;
	walk = function(s, w, doexit, doenter, dofrom)
		local noexit = (doexit == false)
		local noenter = (doenter == false)
		local nofrom = (dofrom == false)
		local moved = s:moved()
		if moved then
			s:moved(false)
		end
		local ww = w
		w = std.ref(w)
		if not w then
			std.err("Wrong parameter to walk: "..std.tostr(ww))
		end

--		if w == std.here() then -- nothing todo
--			return
--		end

		local inwalk = w

		local r, v, t, _
		local f = s:where()

		r, v = std.call(std.ref 'game', 'onwalk', f, inwalk)

		t = std.par(std.scene_delim, false, r)

		if v == false or s:moved() then -- stop walk
			if not s:moved() then s:moved(moved) end
			return t, true
		end

		r, v = std.call(inwalk, 'onwalk', f)

		t = std.par(std.scene_delim, t or false, r)

		if v == false or s:moved() then -- stop walk
			if not s:moved() then s:moved(moved) end
			return t, true
		end

		if not noexit and not s.__in_onexit then
			s.__in_onexit = true
			r, v = std.call(s:where(), 'onexit', inwalk)
			s.__in_onexit = false
			t = std.par(std.scene_delim, t or false, r)
			if v == false or s:moved() then
				if not s:moved() then s:moved(moved) end
				return t, true
			end
		end

		if not noenter then
			r, v = std.call(inwalk, 'onenter', s:where())
			t = std.par(std.scene_delim, t or false, r)
			if v == false or s:moved() then
				if not s:moved() then s:moved(moved) end
				return t, true
			end
		end

		if not noexit and not s.__in_exit then
			s.__in_exit = true
			r, _ = std.call(s:where(), 'exit', inwalk)
			s.__in_exit = false
			t = std.par(std.scene_delim, t or false, r)
			if s:moved() then
				return t, true
			end
		end
		-- enter is done
		s.room = inwalk
		if not nofrom and (f ~= inwalk or not s.room.__from) then -- brake self-recursion
			s.room.__from = f
		end
		if not noenter then
			r, _ = std.call(inwalk, 'enter', f)
			t = std.par(std.scene_delim, t or false, r)
			if s:moved() then
				return t, true
			end
		end
		s:where().__visits = (s:where().__visits or 0) + 1
		s:need_scene(true)
		s:moved(true)
		if not s.__in_afterwalk then
			s.__in_afterwalk = true
			r, _ = std.call(std.ref 'game', 'afterwalk', f, inwalk)
			s.__in_afterwalk = false
			t = std.par(std.scene_delim, t or false, r)
		end
		return t, true
	end;
	go = function(s, w)
		local r
		r = s:where():srch(w)
		if not std.is_obj(r, 'room') then
			return nil, false
		end
		return s:walk(w)
	end;
	where = function(s, where)
		if type(where) == 'table' then
			table.insert(where, std.ref(s.room))
		end
		return std.ref(s.room)
	end;
}, std.obj);

-- merge strings with "space" as separator
std.par = function(space, ...)
	local res
	local a = { ... };
	for i = 1, #a do
		if type(a[i]) == 'string' then
			if res == nil then
				res = ""
			else
				res = res .. space;
			end
			res = res .. a[i];
		end
	end
	return res;
end
-- add to not nill string any string
std.cat = function(v,...)
	if not v then
		return nil
	end
	if type(v) ~= 'string' then
		std.err("Wrong parameter to std.cat: "..std.tostr(v), 2);
	end
	local a = { ... }
	for i = 1, #a do
		if type(a[i]) == 'string' then
			v = v .. a[i];
		end
	end
	return v;
end

std.cctx = function()
	return std.call_ctx[std.call_top];
end

std.callpush = function(v)
	std.call_top = std.call_top + 1;
	std.call_ctx[std.call_top] = { txt = nil, self = v };
end

std.callpop = function()
	std.call_ctx[std.call_top] = nil;
	std.call_top = std.call_top - 1;
	if std.call_top < 0 then
		std.err ("callpush/callpop mismatch")
	end
end

std.pclr = function()
	std.cctx().txt = nil
end

std.pget = function()
	return std.cctx().txt;
end

std.pr = function(...)
	local a = {...}
	if std.cctx() == nil then
		error ("Call from global context.", 2);
	end
	for i = 1, #a do
		std.cctx().txt = std.par('', std.cctx().txt or false, std.tostr(a[i]));
	end
--	std.cctx().txt = std.cat(std.cctx().txt, std.space_delim);
end

std.p = function(...)
	std.pr(...)
	std.cctx().txt = std.cat(std.cctx().txt, std.space_delim);
end

std.pn = function(...)
	std.pr(...)
	std.cctx().txt = std.cat(std.cctx().txt, '^');
end

std.pf = function(fmt, ...)
	if type(fmt) ~= 'string' then
		std.err("Wrong argument to std.pf: "..std.tostr(fmt))
	end
	std.pr(string.format(fmt, ...))
end

function std.strip(s)
	if type(s) ~= 'string' and type(s) ~= 'number' then
		return
	end
	s = tostring(s)
	s = s:gsub("^[ \t]*", ""):gsub("[ \t]*$", "")
	return s
end

function std.join(a, sep)
	sep = sep or ' '
	local rc
	for i = 1, #a do
		if type(a[1]) == 'string' then
			rc = (rc and rc .. sep or '') .. a[i]
		end
	end
	return rc
end

function std.split(s, separator)
	local sep, fields = separator or " ", {}
	local pattern = string.format("([^%s]+)", sep)
	if type(s) ~= 'string' and type(s) ~= 'number' then
		return fields
	end
	s = tostring(s)
	s:gsub(pattern, function(c) fields[#fields+1] = std.strip(c) end)
	return fields
end

function std.esc(s, sym)
	sym = sym or std.delim
	if type(s) ~= 'string' then return s end
	s = s:gsub("\\?["..sym.."]", { [sym] = '\\'..sym, ['\\'..sym] = '\\\\'..sym})
	return s
end

function std.unesc(s, sym)
	sym = sym or std.delim
	s = s:gsub("\\?[\\"..sym.."]", { ['\\'..sym] = sym, ['\\\\'] = '\\' })
	return s
end

function std.is_proxy(t)
	return (type(t) == 'userdata') or (type(t) == 'table' and t.__proxy_type)
end

local function __dump(t, strict, nested)
	local rc = '';
	if type(t) == 'string' then
		rc = string.format("%q", t):gsub("\\\n", "\\n")
	elseif type(t) == 'number' then
		rc = std.tostr(t)
	elseif type(t) == 'boolean' then
		rc = std.tostr(t)
	elseif type(t) == 'function' then
		if std.functions[t] then
			local k = std.functions[t]
			return string.format("%s", k)
		elseif strict then
			std.err("Can not save undeclared function", 2)
		end
	elseif type(t) == 'table' and not t.__visited then
		if std.tables[t] and nested then
			local k = std.tables[t]
			return string.format("%s", k)
		elseif std.is_obj(t) then
			local d = std.deref(t)
			if type(d) == 'number' then
				rc = string.format("std(%d)", d)
			elseif type(d) == 'string' then
				rc = string.format("std %q", d)
			end
			return rc
		end
		if strict and std.getmt(t) then
			std.err("Can not save classes", 2)
		end
		t.__visited = true
		local nkeys = {}
		local keys = {}
		for k, v in pairs(t) do
			if strict and type(k) ~= 'number' and type(k) ~= 'string' then
				std.err("Wrong key type in table: "..type(k), 2)
			end
			if type(k) ~= 'string' or k:find("__", 1, true) ~= 1 then
				if (type(v) ~= 'function' or std.functions[v]) and not std.is_proxy(v) then
					if type(k) == 'number' then
						table.insert(nkeys, { key = k, val = v })
					elseif type(k) == 'string' then
						table.insert(keys, { key = k, val = v })
					end
				elseif strict then
					std.err("Can not save table item ("..std.tostr(k)..") with type: "..type(v), 2)
				end
			end
		end
		table.sort(nkeys, function(a, b) return a.key < b.key end)
		rc = "{ "
		local n, v
		for k = 1, #nkeys do
			v = nkeys[k]
			if v.key == k then
				rc = rc .. __dump(v.val, strict, true)..", "
			else
				n = k
				break
			end
		end
		if n then
			for k = n, #nkeys do
				v = nkeys[k]
				rc = rc .. "["..std.tostr(v.key).."] = "..__dump(v.val, strict, true)..", "
			end
		end
		for k = 1, #keys do
			v = keys[k]
			if type(v.key) == 'string' then
				if v.key:find("^[a-zA-Z_]+[a-zA-Z0-9_]*$") and not lua_keywords[v.key] then
					rc = rc .. v.key .. " = "..__dump(v.val, strict, true)..", "
				else
					rc = rc .. "[" .. string.format("%q", v.key) .. "] = "..__dump(v.val, strict, true)..", "
				end
			else
				rc = rc .. std.tostr(v.key) .. " = "..__dump(v.val, strict, true)..", "
			end
		end
		rc = rc:gsub(",[ \t]*$", "") .. " }"
	elseif type(t) == 'table' then -- visited!
		std.err("Can not save table with cross-references.", 2)
	end
	return rc
end

local function cleardump(t)
	if type(t) ~= 'table' or not t.__visited then
		return
	end
	t.__visited = nil
	for _, v in pairs(t) do
		cleardump(v)
	end
end

function std.dump(t, strict, nested)
	local rc = __dump(t, strict, nested)
	cleardump(t)
	return rc
end

local function clone(src)
	if type(src) ~= 'table' then return src end
	if std.is_obj(src) then return src end
	if src.__visited then
		std.err("Recursive tables not supported by std.clone")
	end
	src.__visited = true
	local dst = {}
	for k, _ in pairs(src) do
		if k ~= '__visited' then
			dst[std.clone(k)] = clone(src[k])
		end
	end
	return dst
end

function std.clone(src)
	cleardump(src)
	local t = clone(src)
	cleardump(src)
	return t
end

function std.new(fn, ...)
	if not std.game then
		std.err ("You can not use new() from global context.", 2)
	end
	if type(fn) ~= 'function' then
		std.err ("Wrong parameter to std.new", 2)
	end
	if not std.functions[fn] then
		std.err ("Function is not declared in 1-st argument of std.new", 2)
	end
	local arg = std.clone({...})

	local o = in_section ('new', function() return fn(std.unpack(arg)) end)

	if type(o) ~= 'table' then
		std.err ("Constructor did not return object:"..std.functions[fn], 2)
	end
	rawset(o, '__dynamic', { fn = fn, arg = {...} })
	if std.game then
		o:__ini() -- do initialization
	end
	return o
end

function std.delete(s)
	s = std.ref(s)
	if std.is_obj(s) then
		if type(s.nam) == 'number' and not s.__dynamic then -- static objects
			std.objects[s.nam] = false
		else
			std.objects[s.nam] = nil
		end
	else
		std.err("Delete non object table", 2)
	end
end

function std.nameof(o)
	o = std.ref(o)
	if not std.is_obj(o) then
		std.err("Wrong parameter to std.nameof: "..std.tostr(o), 2)
		return
	end
	return o.nam
end
function std.dispof(o)
	o = std.ref(o)
	if not std.is_obj(o) then
		std.err("Wrong parameter to std.dispof", 2)
		return
	end
	if o.disp ~= nil then
		local d = std.call(o, 'disp')
		return d
	end
	if o.__autoname then
		if std.is_tag(o.tag) then
			o = o.tag:sub(2)
			return o
		end
		if type(o.nam) == 'number' then
			return std.tostr(o.nam)
		end
		std.err("No nam nor disp are specified for obj: "..std.tostr(o.nam), 2)
	end
	return o.nam
end

function std.titleof(o)
	o = std.ref(o)
	if not std.is_obj(o) then
		std.err("Wrong parameter to std.titleof", 2)
		return
	end
	if o.title ~= nil then
		return std.call(o, 'title')
	end
	return std.dispof(o)
end

function std.ref(o)
	if type(o) == 'table' then
		if not std.is_obj(o) then
			std.err("Reference to wrong object: "..std.tostr(o), 2)
		end
		return o
	end
	local oo = std.objects
	if oo[o] then
		return oo[o]
	end
	if std.noerror then
		std.dprint("Reference to non-existing object: ", std.tostr(o))
		return {} -- give fake object
	end
end

function std.deref(o)
	if std.is_obj(o) then
		return o.nam
	elseif std.ref(o) then
		return o
	end
end

std.method = function(v, n, ...)
	if type(v) ~= 'table' then
		std.err ("Call on non table object:"..std.tostr(n), 2);
	end
	if v[n] == nil then
		return
	end
	if type(v[n]) == 'string' then
		return v[n], true;
	end
	if type(v[n]) == 'function' then
		std.callpush(v, ...)
		local c
		local a, b = v[n](v, ...);
		c = b
		if b == nil and (type(a) == 'boolean' or a == nil) then
			a, b = std.pget(), a
			c = b
		end
		if b == nil then
			b = true -- the fact of call
		end
		std.callpop()
		return a, b, c
	end
	if type(v[n]) == 'boolean' or type(v[n]) == 'table' then
		return v[n], true
	end
	std.err ("Method not string nor function:"..std.tostr(n), 2);
end

std.call = function(o, n, ...)
	if type(o) ~= 'table' then
		std.err("Call on non table object: "..std.tostr(n), 2)
	end
	local r, v, c = std.method(o, n, ...)
	if std.strip_call and type(r) == 'string' then
		r = r:gsub("^[%^\n\r\t ]+", "") -- extra heading ^ and spaces
		r = r:gsub("[%^\n\r\t ]+$", "") -- extra trailing ^ and spaces
		return r, v, c
	end
	return r or nil, v, c
end

local function get_token(inp)
	local q, k
	local rc = ''
	k = 1
	if inp:sub(1, 1) == '"' then
		q = true
		k = k + 1
	end
	while true do
		local c = inp:sub(k, k)
		if c == '' then
			if q then
				return nil -- error
			end
			break
--			return rc, k
		end
		if c == '"' and q then
			k = k + 1
			break
		end
		if not q and (c == ' ' or c == ',' or c == '\t') then
			break
		end
		if q and c == '\\' then
			k = k + 1
			c = inp:sub(k, k)
			rc = rc .. c
		else
			rc = rc .. c
		end
		k = k + 1
	end
	if not q then
		if std.tonum(rc) then
			rc = std.tonum(rc)
		elseif rc == 'true' then
			rc = true
		elseif rc == 'false' then
			rc = false
		end
	end
	return rc, k
end

local function cmd_parse(inp)
	local cmd = {}
	if type(inp) ~= 'string' then
		return false
	end
	if inp:find("^save[ \t]+") then
		cmd[1] = 'save'
		cmd[2] = inp:gsub("^save[ \t]+", "")
		return cmd
	elseif inp:find("^load[ \t]+") then
		cmd[1] = 'load'
		cmd[2] = inp:gsub("^load[ \t]+", "")
		return cmd
	end
	inp = inp:gsub("[ \t]*$", "")
	while true do
		inp = inp:gsub("^[ ,\t]*","")
		local v, i = get_token(inp)
		if v == nil or v == '' then
			break
		end
		inp = inp:sub(i)
		table.insert(cmd, v)
	end
	return cmd
end

std.cmd_parse = cmd_parse

function std.me()
	return std.ref(std.ref 'game'.player)
end

function std.here()
	return std.ref(std.me().room)
end

function std.cacheable(n, f)
	return function(...)
		local s = std.cache[n]
		if s ~= nil then
			if s == -1 then s = nil end
			return s
		end
		std.cache[n] = -1
		s = f(...)
		if s ~= nil then
			std.cache[n] = s
		end
		return s
	end
end

local iface = std.obj {
	nam = '@iface';
	cmd = function(_, inp)
		local cmd = std.cmd_parse(inp)
		if std.debug_input then
			std.dprint("* input: ", inp)
		end
		if not cmd then
			return "Error in cmd arguments", false
		end

		std.cmd = cmd
		std.cache = {}
		local r, v = std.ref 'game':cmd(cmd)
		if r == true and v == false then
			return nil, true -- hack for menu mode
		end
		r = iface:fmt(r, v) -- to force fmt
		if std.debug_output then
			std.dprint("* output: ", r, v)
		end
		return r, v
	end;
	xref = function(_, str, obj)
		obj = std.ref(obj)
		if not obj then
			return str;
		end
		return std.cat(str, "("..std.deref(obj)..")");
	end;
	title = function(_, str)
		return "[ "..std.tostr(str).." ]"
	end;
	raw_mode = function(s, v)
		local ov = s.__raw
		if v ~= nil then
			s.__raw = v or nil
		end
		return ov
	end;
	fmt = function(self, str, state)
		if self:raw_mode() or type(str) ~= 'string' then
			return str
		end
		str = std.fmt(str, std.format, state)

		return std.cat(str, '\n')
	end;
	em = function(_, str)
		return str
	end;
};

local function fmt_stub(_, str)
	return str
end

iface.em = fmt_stub
iface.center = fmt_stub
iface.just = fmt_stub
iface.left = fmt_stub
iface.right = fmt_stub
iface.bold = fmt_stub
iface.top = fmt_stub
iface.bottom = fmt_stub
iface.middle = fmt_stub
iface.nb = fmt_stub
iface.anchor = fmt_stub
iface.img = fmt_stub
iface.imgl = fmt_stub
iface.imgr = fmt_stub
iface.under = fmt_stub
iface.st = fmt_stub
iface.tab = fmt_stub
iface.y = function() return '' end

function std.loadmod(f)
	if std.game and not std.__in_gamefile then
		std.err("Use loadmod() only in global context", 2)
	end
	if type(f) ~= 'string' then
		std.err("Wrong argument to loadmod(): "..std.tostr(f), 2)
	end
	if not f:find("%.lua$") then
		f = f .. '.lua'
	end
	if not std.modules[f] then
		std.modules[f] = true
		std.dofile(f)
	end
end

function std.include(f)
	if std.game and not std.__in_gamefile then
		std.err("Use include() only in global context", 2)
	end
	if type(f) ~= 'string' then
		std.err("Wrong argument to include(): "..std.tostr(f), 2)
	end
	if not f:find("%.lua$") then
		f = f .. '.lua'
	end
	if not std.includes[f] then
		std.includes[f] = true
		in_section('include', function()
			std.dofile(f)
		end)
	end
end

function std.abort()
	std.abort_cmd = true
end

function std.nop()
	std.abort()
	if std.cctx() then
		std.pr(std.game:lastdisp())
	end
	return std.game:lastdisp(), true
end

-- require "ext/gui"
require "declare"
require "dlg"
require "stdlib"
-- luacheck: globals const global declare

local declarations = {}
local variables = {}
local std = stead

local type = std.type
local rawget = std.rawget
local rawset = std.rawset
local pairs = std.pairs
local table = std.table
local next = std.next

local function __declare_one(k, v, t)
	local link

	if type(k) ~= 'string' then -- k:find("^[a-zA-Z_][a-zA-Z0-9_]*$") then
		std.err ("Wrong declaration name: "..k, 3)
	end
	if declarations[k] then
		std.err ("Duplicate declaration: "..k, 3)
	end

	link = rawget(_G, k)

	declarations[k] = { value = v, type = t, link = link }

	if link and v ~= link then
		std.err("Overwite global declaration: "..std.tostr(k), 3)
	end

	if t == 'global' then
		if type(v) == 'function' and not std.functions[v] then
			std.err("Use declare to declare function: "..k, 3)
		end
		rawset(_G, k, v)
		variables[k] = true
	end
	if type(v) == 'function' and not std.functions[v] then
		std.functions[v] = k
	end
	if std.__in_init and std.is_obj(v, 'list') then
		table.insert(v.__in_init, v)
	end
end

local function __declare(n, t)
	if stead.game then
		std.err ("Use "..t.." only in global context", 2)
	end
	if type(n) == 'string' then
		return function(v)
			if v == nil then
				v = false
--				std.err("Wrong declaration: "..std.tostr(t), 2)
			end
			__declare_one(n, v, t)
		end
	end
	if type(n) ~= 'table' then
		std.err ("Wrong parameter to "..n, 2)
	end
	for k, v in std.pairs(n) do
		__declare_one(k, v, t)
	end
	return n
end

function std.const(n)
	return __declare(n, 'const')
end

function std.global(n)
	return __declare(n, 'global')

end

function std.declare(n)
	return __declare(n, 'declare')
end

local function do_depends(t, tables, deps)
	if type(t) ~= 'table' then return end
	if tables[t] then
		deps[t] = tables[t]
	end
	for _, v in pairs(t) do
		if type(v) == 'table' and not std.getmt(v) then
			do_depends(v, tables, deps)
		end
	end
end

local function makedeps(nam, depends, deps)
	local ndeps = {}
	local rc = false

	local t = rawget(_G, nam)
	if type(t) ~= 'table' then
		return
	end
	if type(depends[nam]) ~= 'table' then
		return
	end
	local d = depends[nam]
	for k, v in pairs(d) do
		local dd = depends[v]
		if dd and k ~= t then
			ndeps[k] = v
			rc = rc or makedeps(v, depends, deps)
		end
	end
	if not next(ndeps) then
		depends[nam] = nil
		table.insert(deps, t)
		rc = true
	else
		depends[nam] = ndeps
	end
	return rc
end

local function mod_save(fp)
	-- save global variables
	std.tables = {}
	local tables = {}
	local deps = {}
	for k, v in pairs(declarations) do -- name all table variables
		local o = rawget(_G, k) or v.value
		if type(o) == 'table' then
			if not tables[o] then
				tables[o] = k
			end
		end
	end

	for k, _ in pairs(variables) do
		local d = {}
		local o = rawget(_G, k)
		do_depends(o, tables, d)
		if k == tables[o] then -- self depend
			d[o] = nil
		end
		if next(d) then
			deps[k] = d
		end
	end

	std.tables = tables -- save all depends

	for k, _ in pairs(variables) do -- write w/o deps
		local o = rawget(_G, k)
		if not deps[k] then
			std.save_var(o, fp, k)
		end
	end
	for k, _ in pairs(variables) do
		local d = {}
		while makedeps(k, deps, d) do
			for i=1, #d do
				std.save_var(d[i], fp, k)
			end
			d = {}
		end
	end
end

local function mod_init()
	std.setmt(_G, {
	__index = function(_, n)
		local d = declarations[n]
		if d then --
			if std.game and (d.type ~= 'const') then
				rawset(_, n, d.value)
			end
			return d.value
		end
		local f = std.getinfo(2, "S").source
		std.err ("Uninitialized global variable: "..n.." in "..f, 2)
	end;
	__newindex = function(t, k, v)
		if not std.game and std.is_obj(v) then -- autodeclare objects
			__declare_one(k, v, 'declare')
		end
		local d = declarations[k]
		if d then
			if v == d.value then
				return --nothing todo
			end
			if not std.game then
				d.value = v
				return
			end
			if d.type == 'const' then
				std.err ("Modify read-only constant: "..k, 2)
			else
				d.value = v
				rawset(t, k, v)
			end
			return
		end
		if std.game or type(v) ~= 'function' then
			local f = std.getinfo(2, "S").source
			if f ~= '=[C]' then
				std.err ("Set uninitialized variable: "..k.." in "..f, 2)
			end
		end
		rawset(t, k, v)
	end
	})
end

std.obj {
	nam = '@declare';
	ini = function(_, ...)
-- init all list objs
		for _, v in pairs(declarations) do
			if std.is_obj(v.value, 'list') then
				v.value:__ini(...)
			end
		end
	end;
	declarations = function()
		return declarations;
	end;
	variables = function()
		return variables
	end;
}

local function mod_done()
	std.setmt(_G, {})
	local decl = {}
	for k, v in pairs(declarations) do
		local o = std.rawget(_G, k) or v.value
		if std.is_system(o) then -- save system declarations
			decl[k] = v
		elseif not v.link then
			rawset(_G, k, nil)
		end
	end
	std.tables = {}
	std.functions = {}
	declarations = decl
	variables = {}
end

std.mod_init(mod_init)
std.mod_done(mod_done)
std.mod_save(mod_save)

const = std.const
global = std.global
declare = std.declare
-- luacheck: globals prefs

local std = stead

local preferences = std.obj {
	nam = '@prefs',
	load = function(_)
		local name = std.savepath() .. '/prefs';
		local f, err = std.loadfile(name);
		if not f then
			return false, err
		end
		local strict = std.nostrict; std.nostrict = true
		f();
		std.nostrict = strict
		return true
	end,
	store = function(s)
		return s:save()
	end,
	save = function(s) -- save prefs on every save
		local name = std.savepath() .. '/prefs';
		local name_tmp = name..'.tmp'
		local fp, _ = std.io.open(name_tmp, "wb");
		if not fp then
			return false
		end
		std.obj.save(s, fp, 'std "@prefs"')
		fp:flush();
		fp:close();
		std.os.remove(name)
		return std.os.rename(name_tmp, name);
	end,
	purge = function(_)
		local name = std.savepath() .. '/prefs';
		return std.os.remove(name);
	end
};

local loaded

std.mod_start(function()
	loaded = prefs:load()
end)

std.mod_done(function()
	if loaded then
		prefs:store()
		loaded = false
	end
end)

prefs = preferences
-- luacheck: globals timer
timer = stead.ref '@timer'
local std = stead
local type = std.type
local iface = std.ref '@iface'

-- luacheck: globals fmt

fmt = std.obj {
	nam = '@format';
	para = false;
	nopara = '_';
	para_space = '    ';
	quotes = true;
	dash = true;
	filter = nil;
}

std.obj {
	nam = '$fmt';
	act = function(_, w, ...)
		if type(w) ~= 'string' or not fmt[w] then
			return w
		end
		return fmt[w](...)
	end
}

std.format = function(r, state)
	local utf8 = (std.ref 'game'.codepage == 'UTF-8' or std.ref 'game'.codepage == 'utf-8')

	if type(r) ~= 'string' then
		return r
	end

	if type(fmt.filter) == 'function' then
		r = fmt.filter(r, state)
	end

	if utf8 then
		if fmt.dash then
			r = r:gsub("%-%-%-*", { ['--'] = '—' })
			r = r:gsub("[ \t]+—", iface:nb('').."—"); -- do not break dash
			r = r:gsub("^([^ \t]*)—[ \t]+", "%1— ");
			r = r:gsub("(\n[^ \t]*)—[ \t]+", "%1— ");
		end
		if fmt.quotes then
			r = r:gsub('_"','«'):gsub('"_',"»");
			r = r:gsub('"([^"]*)"','«%1»');
			r = r:gsub(',,','„'):gsub("''",'”');
		end
	end
	if not state then
		return r
	end

	if fmt.para then
		r = r:gsub('\n([^\n])', '\001%1'):gsub('\001[ \t]*'..fmt.nopara,'\n'):
			gsub('\001[ \t]*', '\n'..iface:nb(fmt.para_space));
		r = r:gsub('^[ \t]*', '\001'):gsub('\001[ \t]*'..fmt.nopara,''):
			gsub('\001[ \t]*', iface:nb(fmt.para_space));
	end
	return r
end

function fmt.em(str)
	return iface:em(str)
end

function fmt.c(str)
	return iface:center(str)
end

function fmt.j(str)
	return iface:just(str)
end

function fmt.l(str)
	return iface:left(str)
end

function fmt.r(str)
	return iface:right(str)
end

function fmt.b(str)
	return iface:bold(str)
end

function fmt.top(str)
	return iface:top(str)
end

function fmt.bottom(str)
	return iface:bottom(str)
end

function fmt.middle(str)
	return iface:middle(str)
end

function fmt.nb(str)
	return iface:nb(str)
end

function fmt.anchor(str)
	return iface:anchor(str)
end

function fmt.img(str)
	return iface:img(str)
end

function fmt.imgl(str)
	return iface:imgl(str)
end

function fmt.imgr(str)
	return iface:imgr(str)
end

function fmt.u(str)
	return iface:under(str)
end

function fmt.st(str)
	return iface:st(str)
end

function fmt.tab(str, al)
	return iface:tab(str, al)
end

function fmt.y(str, al)
	return iface:y(str, al)
end
-- luacheck: globals theme
theme = stead.ref '@theme'
local std = stead

std.mod_step(function(state)
	if not state then
		return
	end
	if std.here().nolife and std.game:live() then
		std.game:lifeoff()
	elseif not std.game:live() and not std.here().nolife then
		std.game:lifeon()
	end
end)

std.mod_done(function()
	if not std.game:live() then
		std.game:lifeon()
	end
end)
local std = stead
local input = std.ref '@input'
local instead = std.ref '@instead'

-- luacheck: no self
function input:event(...)
-- luacheck: self
	local a
	for _, v in std.ipairs {...} do
		a = (a and (a..', ') or ' ') .. std.dump(v)
	end
	return '@user_event'.. a or ''
end

std.mod_cmd(function(cmd)
	if cmd[1] ~= '@user_event' then
		return
	end
	local r, v =  std.call(instead, 'onevent', cmd[2])
	if not r and not v then -- nothing todo
		return nil, false
	end
	return r, v
end)
-- luacheck: globals snd
snd = stead.ref '@snd'local std = stead

std.mod_step(function(state)
	if not state then
		return
	end
	if std.here().noinv and not std.me().__inv_disabled then
		std.me():close()
		std.me().__inv_disabled = true
	elseif std.me().__inv_disabled and not std.here().noinv then
		std.me():open()
		std.me().__inv_disabled = nil
	end
end)

std.mod_done(function()
	if std.me().__inv_disabled then
		std.me():open()
		std.me().__inv_disabled = nil
	end
end)
-- luacheck: globals snapshots

local std = stead

local SNAPSHOT = false
local INWRITE = false

local snap = std.obj {
	nam = '@snapshots';
	data = {};
	save = function(s, ...)
		if INWRITE then return end
		return std.obj.save(s, ...)
	end;
	write = function(s, name)
		name = name or 'default'
		local fp = { -- fake file object
			data = '';
			write = function(self, str)
				self.data = self.data .. str
			end;
		}
		INWRITE = true std:save(fp) INWRITE = false
		s.data[name] = fp.data
	end;
	make = function(_, name)
		SNAPSHOT = name or 'default'
	end;
	exists = function(s, name)
		name = name or 'default'
		return s.data[name]
	end;
	remove = function(s, name)
		name = name or 'default'
		s.data[name] = nil
	end;
	restore = function(s, name) -- like std:load()
		name = name or 'default'
		if not s:exists(name) then
			return false
		end
		std:reset()
		std.ref 'game':__ini()
		local f, err = std.eval(s.data[name])
		if not f then
			std.err(err, 2)
		end
		f();
		std.ref 'game':__ini()
		std.ref 'game':__start(true)
		return std.nop()
	end;
}

snapshots = snap

std.mod_cmd(function()
	if SNAPSHOT then
		snap:write(SNAPSHOT)
		SNAPSHOT = nil
	end
end)

-- std.mod_done(function()
-- end)
local std = stead
local instead = std.ref '@instead'
-- luacheck: read globals instead_savepath
-- luacheck: read globals instead_gamepath
-- luacheck: read globals instead_exepath
-- luacheck: globals io
instead.savepath = instead_savepath
std.savepath = instead_savepath
instead.gamepath = instead_gamepath
instead.exepath = instead_exepath

io.open = stead.hook(io.open, function(f, path, acc, ...)
	if std.type(path) == 'string' and path:sub(1, 1) ~= '/' and not
		(path:sub(2, 2) == ':' and path:find("^[A-Z]", 1) == 1) then
		path = instead.gamepath()..'/'..path
	end
	return f(path, acc, ...)
end)
This code uses dictionary files from the http://aot.ru project that is
covered by the terms of the LGPL license.

Dictionary files:
https://sourceforge.net/p/seman/svn/HEAD/tree/trunk/Dicts/Morph/Russian/

License:
https://sourceforge.net/p/seman/svn/HEAD/tree/trunk/copying
--luacheck: no self

local curdir = std.getinfo(1).source:gsub("^(.+[\\/])[^\\/]+$", "%1"):gsub("^@", "");

local mrd = {
	lang = false;
	words = {};
	dirs = {''};
	dict_file = 'dict.mrd';
}

local msg = dprint or print
local function debug(...)
	if DEBUG then
		dprint(...)
	end
end
local function cache_add(cache, key, val)
	table.insert(cache.list, 1, key)
	local len = #cache.list
	if len > (cache.len or 128) then
		local okey = cache.list[len]
		table.remove(cache.list, len)
		cache.hash[okey] = nil
	end
	cache.hash[key] = val
end

local function split(str, sep)
	local words = {}
	if not str then
		return words
	end
	for w in str:gmatch(sep or "[^ \t]+") do
		table.insert(words, w)
	end
	return words
end

local function empty(l)
	l = l:gsub("[ \t]+", "")
	return l == ""
end

function mrd:gramtab(path)
	local f, e = io.open(path or 'rgramtab.tab', 'rb')
	if not f then
		return false, e
	end
	self.gram = {
		an = {}; -- by ancodes
		t = {}; -- by types
	}
	for l in f:lines() do
		if not l:find("^[ \t]*//") and not empty(l) then -- not comments
			local w = split(l)
			if #w < 3 then
				msg("Skipping gram: "..l)
			else
				local a = split(w[4], '[^,]+')
				local an = {}
				for _, v in ipairs(a) do
					an[v] = true
				end
				an.t = w[3] -- type
				self.gram.an[w[1]] = an;
				self.gram.t[w[3]] = an;
			end
		end
	end
	f:close()
end

local function section(f, fn, ...)
	local n = f:read("*line")
	n = n and tonumber(n)
	if not n then
		return false
	end
	if n == 0 then
		return true
	end
	for l in f:lines() do -- skip accents
		if fn then fn(l, ...) end
		n = n - 1
		if n == 0 then
			break
		end
	end
	return true
end

local flex_filter

local function flex_fn(l, flex, an)
	l = l:gsub("//.*$", "")
	local fl = {}
	for w in l:gmatch("[^%%]+") do
		local ww = split(w, "[^%*]+")
		if #ww > 3 or #ww < 1 then
			msg("Skip lex: ", w, l);
		else
			local f = { }
			if #ww == 1 then
				f.an = ww[1]
				f.post = ''
			else
				f.post = ww[1]
				f.an = ww[2]
			end
			f.pre = ww[3] or ''
			local a = an[f.an]
			if not a then
				msg("Gram not found. Skip lex: "..f.an)
			else
				f.an_name = f.an
				f.an = a
				if flex_filter(f) then
					f.filter = true
				end
				table.insert(fl, f)
			end
		end
	end
	table.insert(flex, fl)
end

local function pref_fn(l, pref)
	local p = split(l, "[^,]+")
	table.insert(pref, p)
end

--[[
local function dump(vv)
	local s = ''
	if type(vv) ~= 'table' then
		return string.format("%s", tostring(vv))
	end
	for k, v in pairs(vv) do
		s = s .. string.format("%s = %s ", k, v)
	end
	return s
end

local function gram_dump(v)
	for _, f in ipairs(v.flex) do
		local tt = v.pref .. f.pre .. v.t .. f.post
		print("=== ", tt)
		for _, v in pairs(f.an) do
			print(_, v)
		end
	end
end
]]--
local busy_cnt = 0

local function word_fn(l, self, dict)
	local norm = mrd.lang.norm
	local words = self.words
	local words_list = self.words_list
	local w = split(l)
	if #w ~= 6 then
		msg("Skipping word: "..l)
		return
	end
	if w[1] == '#' then w[1] = '' end
	local nflex = tonumber(w[2]) or false
	local an = w[5]
	if an == '-' then an = false end
	local an_name = an
	local npref = tonumber(w[6]) or false
	if not nflex then
		msg("Skipping word:"..l)
		return
	end
	nflex = self.flex[nflex + 1]
	if not nflex then
		msg("Wrong paradigm number for word: "..l)
		return
	end
	if an then
		an = self.gram.an[an]
		if not an then
			msg("Wrong ancode for word: "..l)
			return
		end
	end
	if npref then
		npref = self.pref[npref + 1]
		if not npref then
			msg("Wrong prefix for word: "..l)
			return
		end
	end
	local t = w[1]
	local num = 0
	local used = false
	for _, v in ipairs(nflex) do
		if v.filter then
		for _, pref in ipairs(npref or { '' }) do
			local tt = norm(pref .. v.pre .. t .. v.post)
--			if tt == 'ЗАКРЕПЛЕН' then
--				gram_dump { t = t, pref = pref, flex = nflex, an = v.an }
--			end
			if not dict or dict[tt] then
				local a = {}
				for kk, _ in pairs(an or {}) do
					a[kk] = an[kk]
				end
				for kk, _ in pairs(v.an) do
					a[kk] = v.an[kk]
				end
				local wds = words[tt] or {}
				table.insert(wds,
					{ t = t, pref = pref, flex = nflex, an = a })
				nflex.used = true
				used = true
				if npref then
					npref.used = true
				end
				num = num + 1
				if #wds == 1 then
					words[tt] = wds
				end
			end
		end
		end
	end
	if used then
		table.insert(words_list, { t = w[1], flex = nflex, pref = npref, an = an_name })
	end
	self.words_nr = self.words_nr + num
	busy_cnt = busy_cnt + 1
	if busy_cnt > 1000 then
		if std then std.busy(true) end
		busy_cnt = 0
	end
	return
end

function mrd:load(path, dict)
	local f, e = io.open(path or 'morphs.mrd', 'rb')
	if not f then
		return false, e
	end
	local flex = {}
	flex_filter = mrd.lang.flex_filter
	if not section(f, flex_fn, flex, self.gram.an) then
		return false, "Error in section 1"
	end
	self.flex = flex
	if not section(f) then
		return false, "Error in section 2"
	end
	if not section(f) then
		return false, "Error in section 3"
	end
	local pref = {}
	if not section(f, pref_fn, pref) then
		return false, "Error in section 4"
	end
	self.pref = pref
	self.words_nr = 0
	self.words = {}
	self.words_list = {}
--	collectgarbage("stop")
	if not section(f, word_fn, self, dict) then
--		collectgarbage("restart")
		return false, "Error in section 4"
	end
--	collectgarbage("restart")
	msg("Generated: "..tostring(self.words_nr).." word(s)");
	local crc = f:read("*line")
	if crc then crc = tonumber(crc) end
	f:close()
	if std then std.busy(false) end
	return true, crc
end

function mrd:dump(path, crc)
	local f, e = io.open(path or 'dict.mrd', 'wb')
	if not f then
		return false, e
	end
	local n = 0
	for _, v in ipairs(self.flex) do
		if v.used then
			v.norm_no = n
			n = n + 1
		end
	end
	f:write(string.format("%d\n", n))
	for _, v in ipairs(self.flex) do
		if v.used then
			local s = ''
			for _, vv in ipairs(v) do
				s = s .. '%'
				if vv.post == '' then
					s = s..vv.an_name
				else
					s = s..vv.post..'*'..vv.an_name
				end
				if vv.pre ~= '' then
					s = s .. '*'..vv.pre
				end
			end
			f:write(s.."\n")
		end
	end
	f:write("0\n")
	f:write("0\n")
	n = 0
	for _, v in ipairs(self.pref) do
		if v.used then
			v.norm_no = n
			n = n + 1
		end
	end
	f:write(string.format("%d\n", n))
	for _, v in ipairs(self.pref) do
		if v.used then
			local s = ''
			for _, vv in ipairs(v) do
				if s ~= '' then s = s .. ',' end
				s = s .. vv
			end
			f:write(s.."\n")
		end
	end
	f:write(string.format("%d\n", #self.words_list))
	for _, v in ipairs(self.words_list) do
		local s
		if v.t == '' then
			s = '#'
		else
			s = v.t
		end
		s = s ..' '..tostring(v.flex.norm_no)
		s = s..' - -'
		if v.an then
			s = s .. ' '..v.an
		else
			s = s .. ' -'
		end
		if v.pref then
			s = s ..' '..tostring(v.pref.norm_no)
		else
			s = s .. ' -'
		end
		f:write(s..'\n')
	end
	if crc then
		f:write(string.format("%d\n", crc))
	end
	f:close()
end

local function gram2an(g)
	local a = {}
	for _, v in ipairs(g) do
		if v:sub(1, 1) == '~' then
			a[v:sub(2)] = false
		else
			a[v] = true
		end
	end
	a.t = nil
	return a
end

local lookup_cache = {
	hash = {};
	list = {};
	len = 512;
}

local function hint_append(hint, h)
	if h == "" or not h then return hint end
	if hint == "" or not hint then return h end
	return hint .. ',' .. h
end

function mrd:lookup(w, g)
	local key  = ""
	for _, v in ipairs(g or {}) do
		key = hint_append(key, v)
	end
	key = w .. '/'..key
	local cc = lookup_cache.hash[key]
	if cc then
		return cc.w, cc.g
	end
	w, g = self:__lookup(w, g)
	cache_add(lookup_cache, key, { w = w, g = g })
	return w, g
end

function mrd:__lookup(w, g)
	local ow = w
	local cap, upper = self.lang.is_cap(w)
	local tt = self.lang.upper(self.lang.norm(w))
	w = self.words[tt]
	if not w then
		return false, "No word in dictionary"
	end
	local res = {}

	local gram_compat = self.lang.gram_compat
	local gram_score = self.lang.gram_score

	for _, v in ipairs(w) do
		local flex = v.flex
		local score = gram_score(v.an, g)
		local t = v.an.t
		for _, f in ipairs(flex) do
			if gram_compat(v.an, f.an, gram2an(g)) then
				local sc = gram_score(f.an, g)
				if sc >= 0 then
					if t ~= f.an.t then sc = sc - 1 end -- todo
--[[
				local tt = v.pref .. f.pre .. v.t .. f.post
				if tt == 'ЛЕВЫЙ' or tt == 'ЛЕВОГО' or tt == 'ШЛЕМОМ' then
					print ("======looking for:", g.noun)
					for _, v in pairs(g) do
						print(_, v)
					end
					print ("======looking got:", score + sc, sc)
					print(tt, v.t, score + sc)
					for _, v in pairs(f.an) do
						print(_, v)
					end
				end
]]--
					table.insert(res, { score = score + sc, pos = #res, word = v, flex = f })
				end
			end
		end
	end
	if #res == 0 then
		return ow, gram2an(g) -- false, "No gram"
	end
	table.sort(res, function(a, b)
		if a.score == b.score then
			return a.pos < b.pos
		end
		return a.score > b.score
	end)

--[[
	for i = 1, #res do
		local w = res[i]
		local tt = self.lang.lower(w.word.pref .. w.flex.pre .. w.word.t .. w.flex.post)
		print(i, "res: ", tt, w.score)
		if tt == 'красный' or tt == 'красного' then
			for _, v in pairs(w.flex.an) do
				print(_, v)
			end
		end
--		print(tt, w.score)
	end
]]--
	w = res[1]
	local gram = {}
	for k, v in pairs(w.flex.an) do
		gram[k] = v
	end

	for k, v in pairs(w.word.an) do
		gram[k] = v
	end

	w = self.lang.lower(w.word.pref .. w.flex.pre .. w.word.t .. w.flex.post)
	if upper then
		w = self.lang.upper(w)
	elseif cap then
		w = self.lang.cap(w)
	end

	return w, gram
end
local word_match = "[^ \t,%-!/:%+&]+"
local missed_words = {}

local word_cache = { list = {}, hash = {} }

function mrd:word(w, ob)
	local cache = word_cache
	if ob then
		if not ob.__word_cache then
			std.rawset(ob, '__word_cache', {
					list = {},
					hash = {},
					len = 32,
				})
		end
		cache = ob.__word_cache
	end
	local key = w
	local c = cache.hash[key]
	if c then
		return std.clone(c[1]), std.clone(c[2])
	end
	local ow = w
	local s, _ = w:find("/[^/]*$")
	local g = {}
	local grams = {}
	local hints = ''
	if s then
		hints = w:sub(s + 1)
		w = w:sub(1, s - 1)
		g = split(hints, "[^, ]+")
	end
	local found = true
	local noun = false
	local lang = self.lang
	w = w:gsub(word_match,
		function(t)
			if noun then return t end
			local ww, gg
			if ob then
				ww, gg = self:dict(ob.__dict, t..'/'..hints)
			end
			if not ww then
				ww, gg = self:dict(game.__dict, t..'/'..hints)
			end
			if not ww then
				ww, gg = self:dict(self.__dict, t..'/'..hints)
			end
			noun = gg and gg[lang.gram_t.noun]
			if not ww then
				ww, gg = self:lookup(t, g)
				noun = gg and gg.t == lang.gram_t.noun
			end
			if gg and (gg[lang.gram_t.proper] or gg[lang.gram_t.surname]) then
				noun = false
			end
			if not ww then
				found = false
			else
				table.insert(grams, gg)
			end
			return ww or t
		end)
	if not found then
		if DEBUG and not tonumber(w) and not missed_words[w] then
			missed_words[w] = true
			debug("Can not find word: '"..ow.."'")
		end
	end
	cache_add(cache, key, { w, grams })
	return w, grams
end

function mrd:file(f, dict)
	dict = dict or {}
	local ff, e = io.open(f, "rb")
	if not ff then
		return false, e
	end
	debug("Added file: ", f)
	for l in ff:lines() do
		for w in l:gmatch('%-"[^"]+"') do
			w = w:gsub('^%-"', ""):gsub('"$', "")
			local words = split(w, '[^|]+')
			for _, word in ipairs(words) do
				word = word:gsub("/[^/]*$", "")
				for ww in word:gmatch(word_match) do
					local t = self.lang.upper(self.lang.norm(ww))
					if not dict[t] and not t:find("%*$") then
						dict[t] = true;
						debug("mrd: Added word: ", ww)
					end
				end
			end
		end
	end
	ff:close()
	return dict
end

local function str_hint(str)
--	str = str:gsub("^%+", "")
	local s, _ = str:find("/[^/]*$")
	if not s then
		return str, ""
	end
	if s == 1 then
		return "", str:sub(2)
	end
	return str:sub(1, s - 1), str:sub(s + 1)
end

local function str_strip(str)
	return std.strip(str)
end

local function str_split(str, delim)
	local a = std.split(str, delim)
	for k, _ in ipairs(a) do
		a[k] = str_strip(a[k])
	end
	return a
end

function mrd:dict(dict, word)
	if not dict then return end
	local tab = {}
	local wrd, hints = str_hint(word)
	hints = str_split(hints, ",")
	local tt = dict[wrd]

	if not tt then
		return
	end

	for _, v in ipairs(tt) do
		local whints = {}
		local w, h = str_hint(v)
		local hh = str_split(h, ",")
		for _, vv in ipairs(hh) do
			whints[vv] = true
		end
		local t = { w, score = 0, pos = #tab, w = w }
		for _, hv in ipairs(hints) do
			if hv:sub(1, 1) ~= '~' then
				if whints[hv] then
					t.score = t.score + 1
				end
			else
				if whints[str_strip(hv:sub(2))] then
					t.score = t.score - 1
				end
			end
		end
		t.hints = str_split(hint_append(tt.hints, h), ",")
		if mrd.lang.gram_t.nom and whints[mrd.lang.gram_t.nom] then
			t.score = t.score + 0.5
		end
		table.insert(tab, t)
	end
	if #tab == 0 then
		return
	end
	table.sort(tab,
		function(a, b)
			if a.score == b.score then
				return a.pos < b.pos
			end
			return a.score > b.score
		end)
	if tab[1].score > 0 then
		return tab[1].w, gram2an(tab[1].hints)
	end
end

function mrd.dispof(w)
	if w.raw_word ~= nil then
		local d = std.call(w, 'raw_word')
		return d, true
	end
	if w.word ~= nil then
		local d = std.call(w, 'word')
		return d
	end
	return std.titleof(w) or std.nameof(w)
end

local obj_cache = { hash = {}, list = {}, len = 128 }

function mrd:obj(w, n, nn)
	local hint = ''
	local hint2, disp, ob, raw
	if type(w) == 'string' then
		w, hint = str_hint(w)
	elseif type(n) == 'string' then
		hint = n
		n = nn
	end
	if type(w) ~= 'string' then
--		w = std.object(w)
		ob = w
		disp, raw = self.dispof(w)
	else
		disp = w
	end
	local d = obj_cache.hash[disp]
	if not d then
		d = str_split(disp, '|')
		if #d == 0 then
			std.err("Wrong object display: ".. (disp or 'nil'), 2)
		end
	-- normalize
		local nd = {}
		for k, v in ipairs(d) do
			w, hint2 = str_hint(v)
			local dd = raw and { w } or str_split(w, ',')
			for _, vv in ipairs(dd) do
				table.insert(nd, { word = vv, hint = hint2 or '', alias = k, idx = _ })
--				for w in vv:gmatch("[^ ]+") do
--					table.insert(nd, { word = w, hint = hint2 or '', alias = k, idx = _ })
--				end
			end
		end
		d = nd
		cache_add(obj_cache, disp, d)
	end
	if type(n) == 'table' then
		local ret = n
		for _, v in ipairs(d) do
			table.insert(ret, { word = v.word, hint = hint_append(hint, v.hint), alias = v.alias, idx = v.idx });
		end
		return ob, ret
	end
	n = n or (ob and ob.__word_alias) or 1
	for k, v in ipairs(d) do
		if v.alias == n then
			n = k
			break
		end
	end
	if not d[n] then n = 1  end
	w = d[n].word
	hint2 = d[n].hint
	return ob, w, hint_append(hint, hint2)
end

local function noun_append(rc, tab, w)
--	w = mrd.lang.norm(w)
	if tab then
		table.insert(tab, w)
	else
		if rc ~= '' then rc = rc .. '|' end
		rc = rc .. w
	end
	return rc
end

function mrd:noun_hint(ob, n)
	if not ob then
		return ''
	end
	if not ob.__hint_cache then
		std.rawset(ob, '__hint_cache', {
			list = {},
			hash = {},
			len = 16,
		})
	end
	local key = n or ob.__word_alias or 1
	local c
	if type(ob.word) == 'string' then -- do not use caching if function
		c = ob.__hint_cache.hash[key]
	end
	if c then
		return c
	end
	local g = ob and ob:gram('noun', n) or {}
	local hint = ''
	local lang = self.lang
	for _, v in ipairs { lang.gram_t.male, lang.gram_t.female,
		lang.gram_t.neuter, lang.gram_t.plural,
		lang.gram_t.live } do
		if g[v] then
			hint = hint_append(hint, v)
		end
	end
	if not g[self.lang.gram_t.live] then
		hint = hint_append(hint, lang.gram_t.nonlive)
	end
	if ob then
		hint = hint_append(hint, "noun")
	end
	cache_add(ob.__hint_cache, key, hint)
	return hint
end

function mrd:noun(w, n, nn)
	local hint, ob
	local rc = ''
	local tab = false
	ob, w, hint = self:obj(w, n, nn)
	if type(w) ~= 'table' then
		local alias = nn
		if type(alias) ~= 'number' then alias = n end
		if type(alias) ~= 'number' then alias = nil end
		w = {{ word = w, hint = hint, alias = alias }}
	else
		tab = {}
	end
	for _, v in ipairs(w) do
		local hint2 = self:noun_hint(ob, v.alias)
		local m = self:word(v.word .. '/'.. hint_append(v.hint, hint2), ob)
		rc = noun_append(rc, tab, m)
	end
	return tab and tab or rc
end

local function str_hash(str)
	local sum = 0
	for i = 1, str:len() do
		sum = sum + string.byte(str, i)
	end
	return sum
end

function mrd:init(l)
	self.lang = l
	if type(l.dict) == 'table' then
		std.obj.dict(self, l.dict)
	end
	if self:gramtab(curdir .. "rgramtab.tab") == false then
		msg("Error while opening gramtab.")
		return
	end
	local _, crc = self:load(mrd.dict_file)
	self:create(mrd.dict_file, crc) -- create or update
end

function mrd:create(fname, crc)
	local dict = {}
	if not std.readdir then
		return
	end
	for _, d in ipairs(self.dirs) do
		if d == '' then d = instead.gamepath() end
		local list = {}
		for f in std.readdir(d) do
			if f:find("%.lua$") or f:find("%.LUA$") then
				table.insert(list, f)
			end
		end
		table.sort(list)
		for _, f in ipairs(list) do
			local path = d .. "/" .. f
			mrd:file(path, dict)
		end
	end
	local sum = 0
	for w, _ in pairs(dict) do
		sum = sum + str_hash(w)
		sum = sum % 4294967291;
	end
	if crc ~= sum then
		msg("Generating dict.mrd with sum: ", sum)
		if mrd:load(curdir .. "morphs.mrd", dict) then
			mrd:dump(fname or 'dict.mrd', sum)
		else
			msg("Can not find morph/morphs.mrd")
		end
	else
		msg("Using dict.mrd")
	end
end
if std then
std.obj.noun = function(self, ...)
	return mrd:noun(self, ...)
end

std.obj.Noun = function(self, ...)
	return mrd.lang.cap(mrd:noun(self, ...))
end

std.obj.gram = function(self, ...)
	local hint, w, gram,  _
	_, w, hint = mrd:obj(self, ...)
	_, gram = mrd:word(w .. '/'..hint)
	local thint = ''
	local t = mrd.lang.gram_t.noun
	hint = str_split(hint, ",")
	local g = gram and gram[1] or {}
	for _, v in ipairs(gram or {}) do
		if v.t == t or v[t] then
			g = v
			break
		end
	end
	local gg = std.clone(g)
	for _, v in ipairs(hint) do
		gg[v] = true
	end
	for k, v in pairs(gg) do
		if v then
			thint = hint_append(thint, k)
		end
	end
	gg.hint = thint
	return gg
end

std.obj.dict = function(self, t)
	local idx = std.rawget(self, '__dict') or {}
	for word, v in pairs(t) do
		local w, hints = str_hint(word)
		if type(v) == 'table' then
			idx[w] = v
			v.hints = hints or ""
		else
			if not idx[w] then
				idx[w] = { hints = "", }
			end
			table.insert(idx[w], v .. '/' .. hints)
		end
	end
	std.rawset(self, '__dict', idx)
	return self
end

local onew = std.obj.new
std.obj.new = function(self, v)
	if type(v[1]) == 'string' or type(v[1]) == 'function' then
		v.word = v[1]
		table.remove(v, 1)
	end
	return onew(self, v)
end
end
local mt = getmetatable("")
function mt.__unm(v)
	return v
end

return mrd
--mrd:gramtab()
--mrd.lang = require "lang-ru"
--mrd:load(false, { [mrd.lang.upper "подосиновики"] = true, [mrd.lang.upper "красные"] = true })
--local w = mrd:word(-"красные подосиновики/рд")
--print(w)
--mrd:file("mrd.lua")
local type = type
local kbden = {
	shifted = {
	["1"] = "!",
	["2"] = "@",
	["3"] = "#",
	["4"] = "$",
	["5"] = "%",
	["6"] = "^",
	["7"] = "&",
	["8"] = "*",
	["9"] = "(",
	["0"] = ")",
	["-"] = "_",
	["="] = "+",
	["/"] = "?",
	[","] = "<",
	["."] = ">",
	["`"] = "~",
	["a"] = "A",
	["b"] = "B",
	["c"] = "C",
	["d"] = "D",
	["e"] = "E",
	["f"] = "F",
	["g"] = "G",
	["h"] = "H",
	["i"] = "I",
	["j"] = "J",
	["k"] = "K",
	["l"] = "L",
	["m"] = "M",
	["n"] = "N",
	["o"] = "O",
	["p"] = "P",
	["q"] = "Q",
	["r"] = "R",
	["s"] = "S",
	["t"] = "T",
	["u"] = "U",
	["v"] = "V",
	["w"] = "W",
	["x"] = "X",
	["y"] = "Y",
	["z"] = "Z",
	}
}

local function lower(str)
	if type(str) ~= 'string' then
		return str
	end
	return str:lower()
end

local function upper(str)
	if type(str) ~= 'string' then
		return str
	end
	return str:upper()
end

local function is_cap(str)
	if type(str) ~= 'string' then
		return false
	end
	local s, e
	if str:find("^[A-Z]") then
		s = true
	end
	if str:find("[A-Z]$") then
		e = true
	end
	return s, e
end

local function cap(str)
	if type(str) ~= 'string' then
		return str
	end
	str = str:gsub("^.", function(v) return v:upper() end)
	return str
end

local lang

local function norm(str)
	return str
end

local vowels = {
	["a"] = true,
	["e"] = true,
	["i"] = true,
	["o"] = true,
	["u"] = true,
}

local function is_vowel(l)
	l = lower(l);
	return vowels[l]
end

lang = { yo = false,
	kbd = kbden,
	norm = norm,
	upper = upper,
	lower = lower,
	cap = cap,
	is_cap = is_cap,
	is_vowel = is_vowel,
	flex_filter = function() return false end,
	gram_compat = function() return false end,
	gram_score = function() return 0 end,
	gram_t = {
		noun = '',
		live = 'live',
		nonlive = 'nonlive',
		neuter = 'neutwe',
		male = 'male',
		female = 'female',
		plural = 'plural',
		proper = 'proper',
		surname = 'surname',
		first = 'first',
		second = 'second',
		third = 'third',
	}
}

return lang
local type = type
local kbdru = {
	["q"] = "й",
	["w"] = "ц",
	["e"] = "у",
	["r"] = "к",
	["t"] = "е",
	["y"] = "н",
	["u"] = "г",
	["i"] = "ш",
	["o"] = "щ",
	["p"] = "з",
	["["] = "х",
	["]"] = "ъ",
	["a"] = "ф",
	["s"] = "ы",
	["d"] = "в",
	["f"] = "а",
	["g"] = "п",
	["h"] = "р",
	["j"] = "о",
	["k"] = "л",
	["l"] = "д",
	[";"] = "ж",
	["'"] = "э",
	["z"] = "я",
	["x"] = "ч",
	["c"] = "с",
	["v"] = "м",
	["b"] = "и",
	["n"] = "т",
	["m"] = "ь",
	[","] = "б",
	["."] = "ю",
	["`"] = "ё",
	["/"] = ".",
	shifted = {
	["q"] = "Й",
	["w"] = "Ц",
	["e"] = "У",
	["r"] = "К",
	["t"] = "Е",
	["y"] = "Н",
	["u"] = "Г",
	["i"] = "Ш",
	["o"] = "Щ",
	["p"] = "З",
	["["] = "Х",
	["]"] = "Ъ",
	["a"] = "Ф",
	["s"] = "Ы",
	["d"] = "В",
	["f"] = "А",
	["g"] = "П",
	["h"] = "Р",
	["j"] = "О",
	["k"] = "Л",
	["l"] = "Д",
	[";"] = "Ж",
	["'"] = "Э",
	["z"] = "Я",
	["x"] = "Ч",
	["c"] = "С",
	["v"] = "М",
	["b"] = "И",
	["n"] = "Т",
	["m"] = "Ь",
	[","] = "Б",
	["."] = "Ю",
	["`"] = "Ё",
	["1"] = "!",
	["2"] = "@",
	["3"] = "#",
	["4"] = ";",
	["5"] = "%",
	["6"] = ":",
	["7"] = "?",
	["8"] = "*",
	["9"] = "(",
	["0"] = ")",
	["-"] = "_",
	["="] = "+",
	["/"] = ",",
	}
}

local toupper = {
	["й"] = "Й",
	["ц"] = "Ц",
	["у"] = "У",
	["к"] = "К",
	["е"] = "Е",
	["н"] = "Н",
	["г"] = "Г",
	["ш"] = "Ш",
	["щ"] = "Щ",
	["з"] = "З",
	["х"] = "Х",
	["ъ"] = "Ъ",
	["ф"] = "Ф",
	["ы"] = "Ы",
	["в"] = "В",
	["а"] = "А",
	["п"] = "П",
	["р"] = "Р",
	["о"] = "О",
	["л"] = "Л",
	["д"] = "Д",
	["ж"] = "Ж",
	["э"] = "Э",
	["я"] = "Я",
	["ч"] = "Ч",
	["с"] = "С",
	["м"] = "М",
	["и"] = "И",
	["т"] = "Т",
	["ь"] = "Ь",
	["б"] = "Б",
	["ю"] = "Ю",
	["ё"] = "Ё",
}

local function lower(str)
	if type(str) ~= 'string' then
		return str
	end
	str = str:lower()
	for k, v in pairs(toupper) do
		str = str:gsub(v, k)
	end
	return str
end

local function upper(str)
	if type(str) ~= 'string' then
		return str
	end
	str = str:upper();
	for k, v in pairs(toupper) do
		str = str:gsub(k, v)
	end
	return str
end

local function is_cap(str)
	if type(str) ~= 'string' then
		return false
	end
	local s, e
	for _, v in pairs(toupper) do
		if not s and str:find("^"..v) then
			s = true
		end
		if not e and str:find(v.."$") then
			e = true
		end
		if not s and str:find("^[A-Z]") then
			s = true
		end
		if not e and str:find("[A-Z]$") then
			e = true
		end
	end
	return s, e
end

local function cap(str)
	if type(str) ~= 'string' then
		return str
	end
	if str:find("^[a-z]") then
		str = str:gsub("^.", function(v) return v:upper() end)
		return str
	end
	for k, v in pairs(toupper) do
		local s = str:gsub("^"..k, v)
		if s ~= str then
			return s
		end
	end
	return str
end

local lang

local function norm(str)
	if type(str) ~= 'string' then
		return str
	end
	if not lang.yo then
		str = str:gsub("ё", "е"):gsub("Ё", "Е")
	end
	return str
end

local vowels = {
	["у"] = true,
	["е"] = true,
	["ы"] = true,
	["а"] = true,
	["о"] = true,
	["и"] = true,
	["ю"] = true,
	["ё"] = true,
	["э"] = true,
	["я"] = true,
}

local function is_vowel(l)
	l = lower(l);
	return vowels[l]
end

local gram_tt = {
	["ИНФИНИТИВ"] = true;
	["КР_ПРИЛ"] = true;
	["КР_ПРИЧАСТИЕ"] = true;
	["Г"] = true;
}

local function flex_filter(v)
	local an = v.an
	if an["им"] then
		return true
	end
	if an["рд"] or an["дт"] or an["тв"] or an["пр"] or an["вн"] then
		return false
	end
	if an["0"] then
		return true
	end
	return gram_tt[an.t]
end

local function gram_info(a)
	local t = { }
	if a['мр'] then
		t.gen = 'male'
	elseif a['жр'] then
		t.gen = 'female'
	elseif a['ср'] then
		t.gen = 'neuter'
	else
		t.gen = 'any'
	end

	if a['мн'] then
		t.num = 'singular'
	elseif a['ед'] then
		t.num = 'plural'
	else
		t.num = 'any'
	end

	if a['буд'] then
		t.time = 'future'
	elseif a['прш'] then
		t.time = 'past'
	elseif a['нст'] then
		t.time = 'present'
	else
		t.time = 'any'
	end

	if a['1л'] then
		t.face = 'first'
	elseif a['2л'] then
		t.face = 'second'
	elseif a['3л'] then
		t.face = 'third'
	else
		t.face = 'any'
	end

	return t
end

local function __gram_compat(g1, g2, time)
	if g1.gen ~= g2.gen and g1.gen ~= 'any' and g2.gen ~= 'any' then return false end
	if not time then
		if g1.num ~= g2.num and g1.num ~= 'any' and g2.num ~= 'any' then return false end
	end
	if g1.time ~= g2.time and g1.time ~= 'any' and g2.time ~= 'any' then return false end
	if g1.face ~= g2.face and g1.face ~= 'any' and g2.face ~= 'any' then return false end
	return true
end

local function gram_eq(a, b)
	if not a or not b then return true end
	if a == 'ИНФИНИТИВ' or b == 'ИНФИНИТИВ' then
		return b == a or b == 'Г' or a == 'Г'
	end
	if a == 'КР_ПРИЛ' or b == 'КР_ПРИЛ' then
		return b == a -- or b == 'П'
	end
	if a == 'КР_ПРИЧАСТИЕ' or b == 'КР_ПРИЧАСТИЕ' then
		return b == a
	end
	if a == 'ПРИЧАСТИЕ' or b == 'ПРИЧАСТИЕ' then
		return b == a
	end
	if a == 'Г' or b == 'Г' then return a == b end
	return true
end

local function gram_compat(base, aa, bb)
	if not gram_eq(base.t, aa.t) then
		return false
	end
--	local a, b = aa.t, bb.t
	local g1, g2 = gram_info(aa), gram_info(bb)
	if bb.noun then
		if not base['им'] then
			return false
		end
		local g0 = gram_info(base)
		if not __gram_compat(g0, g1, true) then return false end
		if not __gram_compat(g0, g2, true) then return false end
	end
	return __gram_compat(g1, g2)
end

local function gram_norm(an)
	local a = {}
	local g = {}
	for _, v in ipairs(an) do
		a[v] = true
		table.insert(g, v)
	end
	if not a['1л'] and not a['2л'] and not a['3л'] then
		table.insert(g, '3л')
	end
	return g
end

local function gram_score(an, g)
	local score = 0
	g = gram_norm(g)
	if an["фам"] then score = score - 0.1 end
	if an["арх"] then score = score - 0.1 end
	if not g["од"] and not g["но"] and an["од"] and not an["но"] then score = score - 0.1 end
	for _, vv in ipairs(g or {}) do
		if vv:sub(1, 1) == '~' then
			vv = vv:sub(2)
			if an[vv] then
				score = score - 1
			elseif an.t == vv then
				score = score - 10
			end
		else
			if an[vv] then
				score = score + 1
			elseif an.t == vv then
				score = score + 10
			end
		end
	end
	return score
end

lang = { yo = false,
	kbd = kbdru,
	norm = norm,
	upper = upper,
	lower = lower,
	cap = cap,
	is_cap = is_cap,
	is_vowel = is_vowel,
	flex_filter = flex_filter,
	gram_compat = gram_compat,
	gram_score = gram_score,
	gram_t = {
		noun = 'С',
		nom = 'им',
		live = 'од',
		nonlive = 'но',
		neuter = 'ср',
		male = 'мр',
		female = 'жр',
		plural = 'мн',
		proper = 'имя',
		surname = 'фам',
		first = '1л',
		second = '2л',
		third = '3л',
	};
	dict = {
		["ведро/ср,но,С"] = {
			"ведро/им", "вёдра/им,мн",
			"ведро/вн", "вёдра/вн,мн",
			"ведра/рд", "вёдер/рд,мн",
			"ведру/дт", "ведрам/дт,мн",
			"ведром/тв", "вёдрами/тв,мн",
			"ведре/пр", "вёдрах/пр,мн",
		},
		["деревья/ср,но,мн,С"] = {
			"деревья/им";
			"деревья/вн";
			"деревьев/рд";
			"деревьями/тв";
			"деревьях/пр";
			"деревьям/дт";
		};
		["листья/мр,но,мн,С"] = {
			"листья/им";
			"листья/вн";
			"листьев/рд";
			"листьями/тв";
			"листьях/пр";
			"листьям/дт";
		};
		["дерево/ср,но,С"] = {
			"дерево/им", "деревья/им,мн";
			"дерево/вн", "деревья/вн,мн";
			"дерева/рд", "деревьев/рд,мн";
			"деревом/тв", "деревьями/тв,мн";
			"дереве/пр", "деревьях/пр,мн";
			"дереву/пр", "деревьям/дт,мн";
		};
		["огонь/мр,но,С"] = {
			"огонь/им", "огни/им,мн",
			"огонь/вн", "огни/вн,мн",
			"огня/рд", "огней/рд,мн",
			"огню/дт", "огням/дт,мн",
			"огнём/тв", "огнями/тв,мн",
			"огне/пр", "огнях/пр,мн",
		};
		["цветы/мн,мр,но,С"] = { -- цветки
			"цветы/им",
			"цветы/вн",
			"цветов/рд",
			"цветам/дт",
			"цветами/тв",
			"цветах/пр",
		};
		["хлам/пр,2"] = "хламе";
		["клевер/пр"] = "клевере";
		["песок/пр,2"] = "песке";
	};
}

return lang
//  ======  СУЩЕСТВИТЕЛЬНЫЕ   ========

// существительные мужского рода
аа A С мр,ед,им
аб A С мр,ед,рд
Эф A С мр,ед,рд,2
ав A С мр,ед,дт
аг A С мр,ед,вн
ад A С мр,ед,тв
ае A С мр,ед,пр
Эх A С мр,ед,пр,2
ас A С мр,ед,зв,
аж A С мр,мн,им
аз A С мр,мн,рд
аи A С мр,мн,дт
ай A С мр,мн,вн
ак A С мр,мн,тв
ал A С мр,мн,пр
ам B С мр,0
ан B С мр,ед,0

// =============  разговорный  ================
Юо A С мр,ед,им,разг 
Юп A С мр,ед,рд,разг 
Юр A С мр,ед,дт,разг 
Юс A С мр,ед,вн,разг 
Ют A С мр,ед,тв,разг 
Юф A С мр,ед,пр,разг 
Юх A С мр,ед,зв,разг 
Яб A С мр,мн,им,разг 
Яа A С мр,мн,рд,разг
Яв A С мр,мн,дт,разг
Яг A С мр,мн,вн,разг
Яд A С мр,мн,тв,разг
Яж A С мр,мн,пр,разг


// =============  архаизм  ================
го A С мр,ед,им,арх 
гп A С мр,ед,рд,арх 
гр A С мр,ед,дт,арх 
гс A С мр,ед,вн,арх 
гт A С мр,ед,тв,арх 
гу A С мр,ед,пр,арх 
гф A С мр,мн,им,арх 
гх A С мр,мн,рд,арх
гц A С мр,мн,дт,арх
гч A С мр,мн,вн,арх
гш A С мр,мн,тв,арх
гщ A С мр,мн,пр,арх


// существительные мужского-женского рода

ва E С мр-жр,ед,им
вб E С мр-жр,ед,рд
вв E С мр-жр,ед,дт
вг E С мр-жр,ед,вн
вд E С мр-жр,ед,тв
ве E С мр-жр,ед,пр
вж E С мр-жр,мн,им
вз E С мр-жр,мн,рд
ви E С мр-жр,мн,дт
вй E С мр-жр,мн,вн
вк E С мр-жр,мн,тв
вл E С мр-жр,мн,пр
вм F С мр-жр,0
вн F С мр-жр,ед,0


// существительные мужского-женского рода (архаизм)
во E С арх,мр-жр,ед,им
вп E С арх,мр-жр,ед,рд
вр E С арх,мр-жр,ед,дт
вс E С арх,мр-жр,ед,вн
вт E С арх,мр-жр,ед,тв
ву E С арх,мр-жр,ед,пр
вф E С арх,мр-жр,мн,им
вх E С арх,мр-жр,мн,рд
вц E С арх,мр-жр,мн,дт
вч E С арх,мр-жр,мн,вн
вш E С арх,мр-жр,мн,тв
вщ E С арх,мр-жр,мн,пр

// существительные женского рода
га G С жр,ед,им
гб G С жр,ед,рд
гв G С жр,ед,дт
гг G С жр,ед,вн
гд G С жр,ед,тв
ге G С жр,ед,пр
Эч G С жр,ед,пр,2
Йш G С жр,ед,зв
гж G С жр,мн,им
гз G С жр,мн,рд
ги G С жр,мн,дт
гй G С жр,мн,вн
гк G С жр,мн,тв
гл G С жр,мн,пр
гм H С жр,0
гн H С жр,ед,0

// существительные женского (архаизм)
Йа G С арх,жр,ед,им
Йб G С арх,жр,ед,рд
Йв G С арх,жр,ед,дт
Йг G С арх,жр,ед,вн
Йд G С арх,жр,ед,тв
Йе G С арх,жр,ед,пр
Йж G С арх,жр,мн,им
Йз G С арх,жр,мн,рд
Йи G С арх,жр,мн,дт
Йй G С арх,жр,мн,вн
Йк G С арх,жр,мн,тв
Йл G С арх,жр,мн,пр


// существительные женского (разговорный)
Йм G С разг,жр,ед,им
Йн G С разг,жр,ед,рд
Йо G С разг,жр,ед,дт
Йп G С разг,жр,ед,вн
Йр G С разг,жр,ед,тв
Йс G С разг,жр,ед,пр
Йт G С разг,жр,мн,им
Йу G С разг,жр,мн,рд
Йф G С разг,жр,мн,дт
Йх G С разг,жр,мн,вн
Йц G С разг,жр,мн,тв
Йч G С разг,жр,мн,пр



// существительные среднего рода

еа K С ср,ед,им
еб K С ср,ед,рд
ев K С ср,ед,дт
ег K С ср,ед,вн
ед K С ср,ед,тв
ее K С ср,ед,пр
еж K С ср,мн,им
ез K С ср,мн,рд
еи K С ср,мн,дт
ей K С ср,мн,вн
ек K С ср,мн,тв
ел K С ср,мн,пр
ем L С ср,0
ен L С ср,ед,0

// им. Ленина
Эя K С ср,ед,рд,аббр

// существительные среднего рода (разговорный)
Яз K С разг,ср,ед,им
Яи K С разг,ср,ед,рд
Як K С разг,ср,ед,дт
Ял K С разг,ср,ед,вн
Ям K С разг,ср,ед,тв
Ян K С разг,ср,ед,пр
Яо K С разг,ср,мн,им
Яп K С разг,ср,мн,рд
Яр K С разг,ср,мн,дт
Яс K С разг,ср,мн,вн
Ят K С разг,ср,мн,тв
Яу K С разг,ср,мн,пр

// pluralia tantum
иж Q С мн,мн,им
из Q С мн,мн,рд
ии Q С мн,мн,дт
ий Q С мн,мн,вн
ик Q С мн,мн,тв
ил Q С мн,мн,пр
им R С мн,0

//  аббревиатуры
ао B С мр,аббр,0,
ап B С мр,ед,аббр,0
ат H С жр,аббр,0
ау H С жр,ед,аббр,0
ац H С ср,аббр,0
ач H С ср,ед,аббр,0
аъ R С мн,аббр,0

// имена

бо C С мр,имя,ед,им
бп C С мр,имя,ед,рд
бр C С мр,имя,ед,дт
бс C С мр,имя,ед,вн
бт C С мр,имя,ед,тв
бу C С мр,имя,ед,пр
бь C С мр,имя,ед,зв,разг
бф C С мр,имя,мн,им
бх C С мр,имя,мн,рд
бц C С мр,имя,мн,дт
бч C С мр,имя,мн,вн
бш C С мр,имя,мн,тв
бщ C С мр,имя,мн,пр

бН I С мр,имя,0


вН E С мр-жр,имя,0
вО E С мр-жр,имя,ед,им
вП E С мр-жр,имя,ед,рд
вР E С мр-жр,имя,ед,дт
вС E С мр-жр,имя,ед,вн
вТ E С мр-жр,имя,ед,тв
вУ E С мр-жр,имя,ед,пр
вЬ E С мр-жр,имя,ед,зв,разг
вФ E С мр-жр,имя,мн,им
вХ E С мр-жр,имя,мн,рд
вЦ E С мр-жр,имя,мн,дт
вЧ E С мр-жр,имя,мн,вн
вШ E С мр-жр,имя,мн,тв
вЩ E С мр-жр,имя,мн,пр


до I С жр,имя,ед,им
дп I С жр,имя,ед,рд
др I С жр,имя,ед,дт
дс I С жр,имя,ед,вн
дт I С жр,имя,ед,тв
ду I С жр,имя,ед,пр
дь I С жр,имя,ед,зв,разг
дф I С жр,имя,мн,им
дх I С жр,имя,мн,рд
дц I С жр,имя,мн,дт
дч I С жр,имя,мн,вн
дш I С жр,имя,мн,тв
дщ I С жр,имя,мн,пр


дН I С жр,имя,0



// мужские отчества 

Ра Q С мр,отч,ед,им,
Рб Q С мр,отч,ед,рд,
Рв Q С мр,отч,ед,дт,
Рг Q С мр,отч,ед,вн,
Рд Q С мр,отч,ед,тв,
Ре Q С мр,отч,ед,пр,
Рн Q С мр,отч,мн,им,
Ро Q С мр,отч,мн,рд,
Рп Q С мр,отч,мн,дт,
Рр Q С мр,отч,мн,вн,
Рс Q С мр,отч,мн,тв,
Рт Q С мр,отч,мн,пр,

// женские отчества 

Рж Q С жр,отч,ед,им,
Рз Q С жр,отч,ед,рд,
Ри Q С жр,отч,ед,дт,
Рк Q С жр,отч,ед,вн,
Рл Q С жр,отч,ед,тв,
Рм Q С жр,отч,ед,пр,
Ру Q С жр,отч,мн,им,
Рф Q С жр,отч,мн,рд,
Рх Q С жр,отч,мн,дт,
Рц Q С жр,отч,мн,вн,
Рч Q С жр,отч,мн,тв,
Рш Q С жр,отч,мн,пр,



// мужские отчества  (разг.)

Та Q С мр,отч,разг,ед,им,
Тб Q С мр,отч,разг,ед,рд,
Тв Q С мр,отч,разг,ед,дт,
Тг Q С мр,отч,разг,ед,вн,
Тд Q С мр,отч,разг,ед,тв,
Те Q С мр,отч,разг,ед,пр,
Тн Q С мр,отч,разг,мн,им,
То Q С мр,отч,разг,мн,рд,
Тп Q С мр,отч,разг,мн,дт,
Тр Q С мр,отч,разг,мн,вн,
Тс Q С мр,отч,разг,мн,тв,
Тт Q С мр,отч,разг,мн,пр,

// женские отчества  (разг.)

Тж Q С жр,отч,разг,ед,им,
Тз Q С жр,отч,разг,ед,рд,
Ти Q С жр,отч,разг,ед,дт,
Тк Q С жр,отч,разг,ед,вн,
Тл Q С жр,отч,разг,ед,тв,
Тм Q С жр,отч,разг,ед,пр,
Ту Q С жр,отч,разг,мн,им,
Тф Q С жр,отч,разг,мн,рд,
Тх Q С жр,отч,разг,мн,дт,
Тц Q С жр,отч,разг,мн,вн,
Тч Q С жр,отч,разг,мн,тв,
Тш Q С жр,отч,разг,мн,пр,



//  ======  ПРИЛАГАТЕЛЬНЫЕ   ========

йа Y П мр,ед,им,од,но
йб Y П мр,ед,рд,од,но
йв Y П мр,ед,дт,од,но
йг Y П мр,ед,вн,од
Рщ Y П мр,ед,вн,но
йд Y П мр,ед,тв,од,но
йе Y П мр,ед,пр,од,но
йж Y П жр,ед,им,од,но
йз Y П жр,ед,рд,од,но
йи Y П жр,ед,дт,од,но
йй Y П жр,ед,вн,од,но
йк Y П жр,ед,тв,од,но
йл Y П жр,ед,пр,од,но
йм Y П ср,ед,им,од,но
йн Y П ср,ед,рд,од,но
йо Y П ср,ед,дт,од,но
йп Y П ср,ед,вн,од,но
йр Y П ср,ед,тв,од,но
йс Y П ср,ед,пр,од,но
йт Y П мн,им,од,но
йу Y П мн,рд,од,но
йф Y П мн,дт,од,но
йх Y П мн,вн,од
Рь Y П мн,вн,но
йц Y П мн,тв,од,но
йч Y П мн,пр,од,но
йш Y КР_ПРИЛ мр,ед,од,но
йщ Y КР_ПРИЛ жр,ед,од,но
йы Y КР_ПРИЛ ср,ед,од,но
йэ Y КР_ПРИЛ мн,од,но
йю Y П сравн,од,но
йъ Y П сравн,2,од,но
йь Y П сравн,од,но,разг
йя Z П 0,од,но

//== превосходная степень прилагательного
иа Y П прев,мр,ед,им,од,но
иб Y П прев,мр,ед,рд,од,но
ив Y П прев,мр,ед,дт,од,но
иг Y П прев,мр,ед,вн,од
ид Y П прев,мр,ед,вн,но
ие Y П прев,мр,ед,тв,од,но
Гб Y П прев,мр,ед,пр,од,но
Гв Y П прев,жр,ед,им,од,но
Гг Y П прев,жр,ед,рд,од,но
Гд Y П прев,жр,ед,дт,од,но
Ге Y П прев,жр,ед,вн,од,но
Гж Y П прев,жр,ед,тв,од,но
Гз Y П прев,жр,ед,пр,од,но
ин Y П прев,ср,ед,им,од,но
ио Y П прев,ср,ед,рд,од,но
ип Y П прев,ср,ед,дт,од,но
ир Y П прев,ср,ед,вн,од,но
ис Y П прев,ср,ед,тв,од,но
ит Y П прев,ср,ед,пр,од,но
иу Y П прев,мн,им,од,но
иф Y П прев,мн,рд,од,но
их Y П прев,мн,дт,од,но
иц Y П прев,мн,вн,од
ич Y П прев,мн,вн,но
иш Y П прев,мн,тв,од,но
ищ Y П прев,мн,пр,од,но




//  ========   безличные глаголы  ============
// подуматься,светать
нр a ИНФИНИТИВ безл
// подумается
нс a Г безл,буд 
// подумалось,светало
нт a Г безл,прш
// светает
ну a Г безл,нст



ка a ИНФИНИТИВ дст

//  ========================================
//  ========   личные формы глагола  ============

кб a Г дст,нст,1л,ед
кв a Г дст,нст,1л,мн
кг a Г дст,нст,2л,ед
кд a Г дст,нст,2л,мн
ке a Г дст,нст,3л,ед
кж a Г дст,нст,3л,мн
кз a Г дст,прш,мр,ед
ки a Г дст,прш,жр,ед
кй a Г дст,прш,ср,ед
кк a Г дст,прш,мн
кп a Г дст,буд,1л,ед
кр a Г дст,буд,1л,мн
кс a Г дст,буд,2л,ед
кт a Г дст,буд,2л,мн
ку a Г дст,буд,3л,ед
кф a Г дст,буд,3л,мн


// разговорные формы: "ложу", "ложим","дышут", "ложут", "ложат", "дождуся"
Ръ a Г дст,нст,1л,ед,разг
Ры a Г дст,нст,1л,мн,разг
Рэ a Г дст,нст,2л,ед,разг
Рю a Г дст,нст,2л,мн,разг
Ря a Г дст,нст,3л,ед,разг
кю a Г дст,нст,3л,мн,разг
кя a Г дст,прш,мн,разг

кэ a Г дст,буд,1л,ед,разг
Эа a Г дст,буд,1л,мн,разг
Эб a Г дст,буд,2л,ед,разг
Эв a Г дст,буд,2л,мн,разг
Эг a Г дст,буд,3л,ед,разг
Эд a Г дст,буд,3л,мн,разг



// архаичные формы: "указует", 
Эе a Г дст,нст,1л,ед,арх
Эж a Г дст,нст,1л,мн,арх
Эз a Г дст,нст,2л,ед,арх
Эи a Г дст,нст,2л,мн,арх
Эй a Г дст,нст,3л,ед,арх
Эк a Г дст,нст,3л,мн,арх
Эл a Г дст,прш,мн,арх

Эм a Г дст,буд,1л,ед,арх
Эн a Г дст,буд,1л,мн,арх
Эо a Г дст,буд,2л,ед,арх
Эп a Г дст,буд,2л,мн,арх
Эр a Г дст,буд,3л,ед,арх
Эс a Г дст,буд,3л,мн,арх


// ===================================================
// ==============   ДЕЕПРИЧАСТИЕ ====================
// ===================================================
кн a ДЕЕПРИЧАСТИЕ дст,нст
ко a ДЕЕПРИЧАСТИЕ дст,прш

// ===================================================
// ==============   ДЕЕПРИЧАСТИЕ (архаизм)  ==========
// ===================================================
Эт a ДЕЕПРИЧАСТИЕ дст,нст,арх
Эу a ДЕЕПРИЧАСТИЕ дст,прш,арх

//===================================================
// ==============   ИМПЕРАТИВ    ====================
// "не будем же забывать наших предков!"

нп a Г дст,пвл,1л,мн
къ a Г дст,пвл,1л,ед
кл a Г дст,пвл,2л,ед
км a Г дст,пвл,2л,мн


//  "прощевайте"
ль a Г дст,пвл,2л,ед,разг
кь a Г дст,пвл,2л,мн,разг

// см.
Эю a Г дст,пвл,2л,ед,аббр 

//  "изыди", "изыдите"
фъ a Г дст,пвл,2л,ед,арх
фю a Г дст,пвл,2л,мн,арх


//  действительное причастие настоящего времени
ла a ПРИЧАСТИЕ од,но,нст,дст,ед,мр,им
лб a ПРИЧАСТИЕ од,но,нст,дст,ед,мр,рд
лв a ПРИЧАСТИЕ од,но,нст,дст,ед,мр,дт
лг a ПРИЧАСТИЕ од,нст,дст,ед,мр,вн
Ла a ПРИЧАСТИЕ но,нст,дст,ед,мр,вн
лд a ПРИЧАСТИЕ од,но,нст,дст,ед,мр,тв
ле a ПРИЧАСТИЕ од,но,нст,дст,ед,мр,пр
лз a ПРИЧАСТИЕ од,но,нст,дст,ед,жр,им
ли a ПРИЧАСТИЕ од,но,нст,дст,ед,жр,рд
лй a ПРИЧАСТИЕ од,но,нст,дст,ед,жр,дт
лк a ПРИЧАСТИЕ од,но,нст,дст,ед,жр,вн
лл a ПРИЧАСТИЕ од,но,нст,дст,ед,жр,тв
лм a ПРИЧАСТИЕ од,но,нст,дст,ед,жр,пр
ло a ПРИЧАСТИЕ од,но,нст,дст,ед,ср,им
лп a ПРИЧАСТИЕ од,но,нст,дст,ед,ср,рд
лр a ПРИЧАСТИЕ од,но,нст,дст,ед,ср,дт
лс a ПРИЧАСТИЕ од,но,нст,дст,ед,ср,вн
лт a ПРИЧАСТИЕ од,но,нст,дст,ед,ср,тв
лу a ПРИЧАСТИЕ од,но,нст,дст,ед,ср,пр
лх a ПРИЧАСТИЕ од,но,нст,дст,мн,им
лц a ПРИЧАСТИЕ од,но,нст,дст,мн,рд
лч a ПРИЧАСТИЕ од,но,нст,дст,мн,дт
лш a ПРИЧАСТИЕ од,нст,дст,мн,вн
Лй a ПРИЧАСТИЕ но,нст,дст,мн,вн
лщ a ПРИЧАСТИЕ од,но,нст,дст,мн,тв
лы a ПРИЧАСТИЕ од,но,нст,дст,мн,пр

//  действительное причастие прошедшего времени
ма a ПРИЧАСТИЕ од,но,прш,дст,ед,мр,им
мб a ПРИЧАСТИЕ од,но,прш,дст,ед,мр,рд
мв a ПРИЧАСТИЕ од,но,прш,дст,ед,мр,дт
мг a ПРИЧАСТИЕ од,прш,дст,ед,мр,вн
Лб a ПРИЧАСТИЕ но,прш,дст,ед,мр,вн
мд a ПРИЧАСТИЕ од,но,прш,дст,ед,мр,тв
ме a ПРИЧАСТИЕ од,но,прш,дст,ед,мр,пр
мз a ПРИЧАСТИЕ од,но,прш,дст,ед,жр,им
ми a ПРИЧАСТИЕ од,но,прш,дст,ед,жр,рд
мй a ПРИЧАСТИЕ од,но,прш,дст,ед,жр,дт
мк a ПРИЧАСТИЕ од,но,прш,дст,ед,жр,вн
мл a ПРИЧАСТИЕ од,но,прш,дст,ед,жр,тв
мм a ПРИЧАСТИЕ од,но,прш,дст,ед,жр,пр
мо a ПРИЧАСТИЕ од,но,прш,дст,ед,ср,им
мп a ПРИЧАСТИЕ од,но,прш,дст,ед,ср,рд
мр a ПРИЧАСТИЕ од,но,прш,дст,ед,ср,дт
мс a ПРИЧАСТИЕ од,но,прш,дст,ед,ср,вн
мт a ПРИЧАСТИЕ од,но,прш,дст,ед,ср,тв
му a ПРИЧАСТИЕ од,но,прш,дст,ед,ср,пр
мх a ПРИЧАСТИЕ од,но,прш,дст,мн,им
мц a ПРИЧАСТИЕ од,но,прш,дст,мн,рд
мч a ПРИЧАСТИЕ од,но,прш,дст,мн,дт
мш a ПРИЧАСТИЕ од,прш,дст,мн,вн
Лк a ПРИЧАСТИЕ но,прш,дст,мн,вн
мщ a ПРИЧАСТИЕ од,но,прш,дст,мн,тв
мы a ПРИЧАСТИЕ од,но,прш,дст,мн,пр

//  страдательное причастие настоящего времени
па b ПРИЧАСТИЕ од,но,нст,стр,ед,мр,им
пб b ПРИЧАСТИЕ од,но,нст,стр,ед,мр,рд
пв b ПРИЧАСТИЕ од,но,нст,стр,ед,мр,дт
пг b ПРИЧАСТИЕ од,нст,стр,ед,мр,вн
Лг b ПРИЧАСТИЕ но,нст,стр,ед,мр,вн
пд b ПРИЧАСТИЕ од,но,нст,стр,ед,мр,тв
пе b ПРИЧАСТИЕ од,но,нст,стр,ед,мр,пр
пж b КР_ПРИЧАСТИЕ од,но,нст,стр,ед,мр
пз b ПРИЧАСТИЕ од,но,нст,стр,ед,жр,им
пи b ПРИЧАСТИЕ од,но,нст,стр,ед,жр,рд
пй b ПРИЧАСТИЕ од,но,нст,стр,ед,жр,дт
пк b ПРИЧАСТИЕ од,но,нст,стр,ед,жр,вн
пл b ПРИЧАСТИЕ од,но,нст,стр,ед,жр,тв
пм b ПРИЧАСТИЕ од,но,нст,стр,ед,жр,пр
пн b КР_ПРИЧАСТИЕ од,но,нст,стр,ед,жр
по b ПРИЧАСТИЕ од,но,нст,стр,ед,ср,им
пп b ПРИЧАСТИЕ од,но,нст,стр,ед,ср,рд
пр b ПРИЧАСТИЕ од,но,нст,стр,ед,ср,дт
пс b ПРИЧАСТИЕ од,но,нст,стр,ед,ср,вн
пт b ПРИЧАСТИЕ од,но,нст,стр,ед,ср,тв
пу b ПРИЧАСТИЕ од,но,нст,стр,ед,ср,пр
пф b КР_ПРИЧАСТИЕ од,но,нст,стр,ед,ср
пх b ПРИЧАСТИЕ од,но,нст,стр,мн,им
пц b ПРИЧАСТИЕ од,но,нст,стр,мн,рд
пч b ПРИЧАСТИЕ од,но,нст,стр,мн,дт
пш b ПРИЧАСТИЕ од,нст,стр,мн,вн
Лм b ПРИЧАСТИЕ но,нст,стр,мн,вн
пщ b ПРИЧАСТИЕ од,но,нст,стр,мн,тв
пы b ПРИЧАСТИЕ од,но,нст,стр,мн,пр
пэ b КР_ПРИЧАСТИЕ од,но,нст,стр,мн

//  страдательное причастие прошедшего времени
са b ПРИЧАСТИЕ од,но,прш,стр,ед,мр,им
сб b ПРИЧАСТИЕ од,но,прш,стр,ед,мр,рд
св b ПРИЧАСТИЕ од,но,прш,стр,ед,мр,дт
сг b ПРИЧАСТИЕ од,прш,стр,ед,мр,вн
Ле b ПРИЧАСТИЕ но,прш,стр,ед,мр,вн
сд b ПРИЧАСТИЕ од,но,прш,стр,ед,мр,тв
се b ПРИЧАСТИЕ од,но,прш,стр,ед,мр,пр
сж b КР_ПРИЧАСТИЕ од,но,прш,стр,ед,мр
сз b ПРИЧАСТИЕ од,но,прш,стр,ед,жр,им
си b ПРИЧАСТИЕ од,но,прш,стр,ед,жр,рд
сй b ПРИЧАСТИЕ од,но,прш,стр,ед,жр,дт
ск b ПРИЧАСТИЕ од,но,прш,стр,ед,жр,вн
сл b ПРИЧАСТИЕ од,но,прш,стр,ед,жр,тв
см b ПРИЧАСТИЕ од,но,прш,стр,ед,жр,пр
сн b КР_ПРИЧАСТИЕ од,но,прш,стр,ед,жр
со b ПРИЧАСТИЕ од,но,прш,стр,ед,ср,им
сп b ПРИЧАСТИЕ од,но,прш,стр,ед,ср,рд
ср b ПРИЧАСТИЕ од,но,прш,стр,ед,ср,дт
сс b ПРИЧАСТИЕ од,но,прш,стр,ед,ср,вн
ст b ПРИЧАСТИЕ од,но,прш,стр,ед,ср,тв
су b ПРИЧАСТИЕ од,но,прш,стр,ед,ср,пр
сф b КР_ПРИЧАСТИЕ од,но,прш,стр,ед,ср
сх b ПРИЧАСТИЕ од,но,прш,стр,мн,им
сц b ПРИЧАСТИЕ од,но,прш,стр,мн,рд
сч b ПРИЧАСТИЕ од,но,прш,стр,мн,дт
сш b ПРИЧАСТИЕ од,прш,стр,мн,вн
Ло b ПРИЧАСТИЕ но,прш,стр,мн,вн
сщ b ПРИЧАСТИЕ од,но,прш,стр,мн,тв
сы b ПРИЧАСТИЕ од,но,прш,стр,мн,пр
сэ b КР_ПРИЧАСТИЕ од,но,прш,стр,мн


ча e МС 1л,ед,им
чб e МС 1л,ед,рд
чв e МС 1л,ед,дт
чг e МС 1л,ед,вн
чд e МС 1л,ед,тв
че e МС 1л,ед,пр
чж e МС 1л,мн,им
чз e МС 1л,мн,рд
чи e МС 1л,мн,дт
чй e МС 1л,мн,вн
чк e МС 1л,мн,тв
чл e МС 1л,мн,пр
чм e МС 2л,ед,им
чн e МС 2л,ед,рд
чо e МС 2л,ед,дт
чп e МС 2л,ед,вн
чр e МС 2л,ед,тв
чс e МС 2л,ед,пр
чт e МС 2л,мн,им
чу e МС 2л,мн,рд
чф e МС 2л,мн,дт
чх e МС 2л,мн,вн
чц e МС 2л,мн,тв
чч e МС 2л,мн,пр
ша e МС 3л,мр,ед,им
шб e МС 3л,мр,ед,рд
шв e МС 3л,мр,ед,дт
шг e МС 3л,мр,ед,вн
шд e МС 3л,мр,ед,тв
ше e МС 3л,мр,ед,пр
шж e МС 3л,жр,ед,им
шз e МС 3л,жр,ед,рд
ши e МС 3л,жр,ед,дт
шй e МС 3л,жр,ед,вн
шк e МС 3л,жр,ед,тв
шл e МС 3л,жр,ед,пр
шм e МС 3л,ср,ед,им
шн e МС 3л,ср,ед,рд
шо e МС 3л,ср,ед,дт
шп e МС 3л,ср,ед,вн
шр e МС 3л,ср,ед,тв
шс e МС 3л,ср,ед,пр
шт e МС 3л,мн,им
шу e МС 3л,мн,рд
шф e МС 3л,мн,дт
шх e МС 3л,мн,вн
шц e МС 3л,мн,тв
шч e МС 3л,мн,пр
ща e МС мр,ед,им
щб e МС мр,ед,рд
щв e МС мр,ед,дт
щг e МС мр,ед,вн
щд e МС мр,ед,тв
ще e МС мр,ед,пр
щж e МС жр,ед,им
щз e МС жр,ед,рд
щи e МС жр,ед,дт
щй e МС жр,ед,вн
щк e МС жр,ед,тв
щл e МС жр,ед,пр
щм e МС ср,ед,им
щн e МС ср,ед,рд
що e МС ср,ед,дт
щп e МС ср,ед,вн
щр e МС ср,ед,тв
щс e МС ср,ед,пр
щт e МС мн,им
щу e МС мн,рд
щф e МС мн,дт
щх e МС мн,вн
щц e МС мн,тв
щч e МС мн,пр
щщ e МС рд
щы e МС дт
щэ e МС вн
щю e МС тв
щя e МС пр
ыа f МС-П мр,ед,им,од,но
ыб f МС-П мр,ед,рд,од,но
ыв f МС-П мр,ед,дт,од,но
ыг f МС-П мр,ед,вн,но
Лф f МС-П мр,ед,вн,од
ыд f МС-П мр,ед,тв,од,но
ые f МС-П мр,ед,пр,од,но
ыж f МС-П жр,ед,им,од,но
ыз f МС-П жр,ед,рд,од,но
ыи f МС-П жр,ед,дт,од,но
ый f МС-П жр,ед,вн,од,но
ык f МС-П жр,ед,тв,од,но
ыл f МС-П жр,ед,пр,од,но
ым f МС-П ср,ед,им,од,но
ын f МС-П ср,ед,рд,од,но
ыо f МС-П ср,ед,дт,од,но
ып f МС-П ср,ед,вн,од,но
ыр f МС-П ср,ед,тв,од,но
ыс f МС-П ср,ед,пр,од,но
ыт f МС-П мн,им,од,но
ыу f МС-П мн,рд,од,но
ыф f МС-П мн,дт,од,но
ых f МС-П мн,вн,но
Лх f МС-П мн,вн,од
ыц f МС-П мн,тв,од,но
ыч f МС-П мн,пр,од,но
ыш f МС-П 0,од,но
ыщ g МС-ПРЕДК ед,рд
ыы g МС-ПРЕДК ед,дт
ыэ g МС-ПРЕДК ед,вн
ыю g МС-ПРЕДК ед,тв

// это анал. форма "не о  ком"
ыь g МС-ПРЕДК ед,пр

ыя g МС-ПРЕДК
эа h ЧИСЛ им
эб h ЧИСЛ рд
эв h ЧИСЛ дт
эг h ЧИСЛ вн
эд h ЧИСЛ тв
эе h ЧИСЛ пр

Ца h ЧИСЛ им,арх
Цб h ЧИСЛ рд,арх
Цв h ЧИСЛ дт,арх
Цг h ЧИСЛ вн,арх
Цд h ЧИСЛ тв,арх
Це h ЧИСЛ пр,арх


эж h ЧИСЛ мр,им
эз h ЧИСЛ мр,рд
эи h ЧИСЛ мр,дт
эй h ЧИСЛ мр,вн
эк h ЧИСЛ мр,тв
эл h ЧИСЛ мр,пр
эм h ЧИСЛ жр,им
эн h ЧИСЛ жр,рд
эо h ЧИСЛ жр,дт
эп h ЧИСЛ жр,вн
эр h ЧИСЛ жр,тв
эс h ЧИСЛ жр,пр
эт h ЧИСЛ ср,им
эу h ЧИСЛ ср,рд
эф h ЧИСЛ ср,дт
эх h ЧИСЛ ср,вн
эц h ЧИСЛ ср,тв
эч h ЧИСЛ ср,пр
эш h ЧИСЛ сравн
юа i ЧИСЛ-П мр,ед,им,од,но
юб i ЧИСЛ-П мр,ед,рд,од,но
юв i ЧИСЛ-П мр,ед,дт,од,но
юг i ЧИСЛ-П мр,ед,вн,но
Лт i ЧИСЛ-П мр,ед,вн,од
юд i ЧИСЛ-П мр,ед,тв,од,но
юе i ЧИСЛ-П мр,ед,пр,од,но
юж i ЧИСЛ-П жр,ед,им,од,но
юз i ЧИСЛ-П жр,ед,рд,од,но
юи i ЧИСЛ-П жр,ед,дт,од,но
юй i ЧИСЛ-П жр,ед,вн,од,но
юк i ЧИСЛ-П жр,ед,тв,од,но
юл i ЧИСЛ-П жр,ед,пр,од,но
юм i ЧИСЛ-П ср,ед,им,од,но
юн i ЧИСЛ-П ср,ед,рд,од,но
юо i ЧИСЛ-П ср,ед,дт,од,но
юп i ЧИСЛ-П ср,ед,вн,од,но
юр i ЧИСЛ-П ср,ед,тв,од,но
юс i ЧИСЛ-П ср,ед,пр,од,но
ют i ЧИСЛ-П мн,им,од,но
юу i ЧИСЛ-П мн,рд,од,но
юф i ЧИСЛ-П мн,дт,од,но
юх i ЧИСЛ-П мн,вн,но
Лу i ЧИСЛ-П мн,вн,од
юц i ЧИСЛ-П мн,тв,од,но
юч i ЧИСЛ-П мн,пр,од,но
ющ i ЧИСЛ-П рд,од,но

//  наречия
яа j Н
ян j Н вопр
яо j Н указат
яп j Н разг

// "мне интересно","мне было страшно"
яб k ПРЕДК нст
як k ПРЕДК прш
ял k ПРЕДК 
// мне лучше
яр k ПРЕДК сравн,нст

//  "вот", "хрусть" (нет анал. форм)
ям k ПРЕДК 0

яв l ПРЕДЛ
яг m ПОСЛ
яд n СОЮЗ
яе o МЕЖД
яё o МЕЖД разг
яж p ЧАСТ
яз q ВВОДН
яй s ФРАЗ
Пп b Г стр,буд,1л,ед
Пр b Г стр,буд,1л,мн
Пс b Г стр,буд,2л,ед
Пт b Г стр,буд,2л,мн
Пу b Г стр,буд,3л,ед
Пф b Г стр,буд,3л,мн




// общие граммемы (словообразовательные)
Уа a * лок
// Уб a * 
// Ув a * 
// Уг a * 
// Уд a * 
Уе a * кач
Уж a * дфст
Уз a * дфст,орг
Уи a * дфст,лок
//Ук a * 
Ул a * св,пе
Ум a * св,нп
Ун a * нс,пе
Уо a * нс,нп
Уп a * св,нс,пе
Ур a * св,нс,нп


// для безличных глаголов
Ус a * нс
Ут a * св

Уф a * жарг
Ух a * опч
Уч a * жарг,опч
Уц a * орг,жарг
Уш a * лок,жарг

Ущ a * но,лок
Уь a * но,орг
Уы a * од,фам
Уъ a * но,дфст,лок
Уэ a * но,дфст,орг
Ую a * но,жарг
Уя a * но,опч,
Фа a * но,
Фб a * од,
Фв a * орг,жарг,но
Фг a * дфст,но
Фд a * дфст,од
Фж a * од,жарг
Фз a * имя,притяж
Фи a * притяж
Фк a * св,пе,разг
Фл a * св,нп,разг
Фн a * нс,пе,разг
Фо a * нс,нп,разг
Фп a * но,разг
Фр a * од,разг
Фс a * св,пе,жарг
Фт a * св,нп,жарг
Фу a * нс,пе,жарг
Фф a * нс,нп,жарг
Фх a * разг
Фц a * арх
Фч a * св,пе,арх
Фш a * св,нп,арх
Фщ a * нс,пе,арх
Фь a * нс,нп,арх
Фы a * но,арх
Фъ a * од,арх
Фэ a * нс,арх
Фю a * св,арх
Фя a * кач,арх
Фё a * но,од
Ха a * од,опч,
Хб a * лок,опч,



яю F С мр,жр,ср,ед,им,рд,дт,вн,тв,пр
яя F С мр,жр,ср,,ед,мн,им,рд,дт,вн,тв,пр
--luacheck: no self
local lang = require "morph/lang-en"
require "parser/mp"
require "parser/mplib"

local mp = _'@metaparser'
local mrd = require "morph/mrd"

function mrd:init(l)  -- no dictionary!
	self.lang = l
end

std.mod_init(
	function()
	mp:init(lang)
end)
game.dsc = function()
	p ([[METAPARSER3 Version: ]]..mp.version.."^")
	p [[http://instead-hub.github.io^^
Enter "HELP" for help.
^]]
end
local utf = mp.utf

std.obj.the_noun = function(s, ...)
	local t = s:noun(...)
	if s:hint'proper' or s:hint'surname' then
		return t
	end
	return "the "..t
end

std.obj.a_noun = function(s, ...)
	local t = s:noun(...)
	if s:hint'plural' then
		return t
	end
	if lang.is_vowel(utf.char(t, 1)) then
		return "an "..t
	else
		return "a "..t
	end
end

_'@all'.word = -"all"

_'@darkness'.word = "darkness"
_'@darkness'.before_Any = "Darkness, noun.  An absence of light to see by."
_'@darkness':attr 'persist'

_'@n_to'.word = "north";
_'@ne_to'.word = "northeasr";
_'@e_to'.word = "east";
_'@se_to'.word = "southeast";
_'@s_to'.word = "south";
_'@sw_to'.word = "southwest";
_'@w_to'.word = "west";
_'@nw_to'.word = "northwest";
_'@u_to'.word = "up,above";
_'@d_to'.word = "down";
_'@out_to'.word = "out,outside";
_'@in_to'.word = "in,inside"

mp.shorten = {
	["n"] = "north";
	["e"] = "east";
	["w"] = "west";
	["s"] = "south";
	["ne"] = "northeast";
	["se"] = "southeast";
	["sw"] = "southwest";
	["nw"] = "northwest";
	["u"] = "up";
	["d"] = "down";
}

mp.shorten_expert = {
	["x"] = "examine";
	["i"] = "inventory";
	["z"] = "wait";
}

function mp:skip_filter(w)
	for _, v in ipairs(w) do
		if v == 'no' or v == 'not' then
			return false
		end
	end
	return true
end
function mp:ignore_filter(w)
	if w == 'the' or w == 'a' or w == 'an' then
		return true
	end
	return false
end
_'@compass'.before_Default = function() p('"{#First}" is the direction. You can not ', mp.parsed[1], ' {#firstit}.') end

function mp.msg.SCORE(d)
	if d > 0 then
		pn ("{$fmt em|(Score is increased by ", d, ")}")
	else
		pn ("{$fmt em|(Score is decreased by ", d, ")}")
	end
end

mp.door.word = "door"
mp.msg.TITLE_SCORE = function()
	if mp.maxscore then
		pr ("Score: ", mp.score, "/", mp.maxscore)
	end
	pr ("Score: ", mp.score)
end
mp.msg.TITLE_TURNS = function()
	pr ("Turns: ", game:time() - 1)
end
mp.msg.YES = "Yes"
mp.msg.WHEN_DARK = "Darkness."
mp.msg.UNKNOWN_THEDARK = "Probably, it is because there is no light?"
mp.msg.COMPASS_NOWAY = "{#Me} can't go that way."
mp.msg.COMPASS_EXAM_NO = "Nothing interesting in that direction."
mp.msg.ENUM = "items."
mp.msg.CUTSCENE_HELP = "Press <Enter> or enter {$fmt em|next} to continue."
if instead.tiny then
	mp.msg.CUTSCENE_MORE = "^{$fmt em|(more)}"
end
mp.msg.DLG_HELP = "Enter number to select the phrase."
mp.msg.NO_ALL = "This verb can not be used with all."
mp.msg.DROPPING_ALL = function(w)
	pn (iface:em("(dropping "..w:the_noun()..")"))
end
mp.msg.TAKING_ALL = function(w)
	pn (iface:em("(taking "..w:the_noun()..")"))
end
mp.msg.TAKE_BEFORE = function(w)
	pn (iface:em("(taking "..w:the_noun().." first)"))
end
mp.msg.DISROBE_BEFORE = function(w)
	pn (iface:em("(disrobing "..w:the_noun().." first)"))
end

mp.msg.CLOSE_BEFORE = function(w)
	pn (iface:em("(closing "..w:the_noun() .. " first)"))
end

local function str_split(str, delim)
	local a = std.split(str, delim)
	for k, _ in ipairs(a) do
		a[k] = std.strip(a[k])
	end
	return a
end

function mp.shortcut.thenoun(hint)
	local w = str_split(hint, ",")
	if #w ~= 1 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then
		return ""
	end
	return ob:the_noun()
end

function mp.shortcut.anoun(hint)
	local w = str_split(hint, ",")
	if #w ~= 2 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then
		return ""
	end
	return ob:a_noun()
end

function mp.shortcut.thefirst()
	return mp.first:the_noun()
end

function mp.shortcut.thesecond()
	return mp.second:the_noun()
end

function mp.shortcut.is(hint)
	local w = str_split(hint, ",")
	if #w ~= 1 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then return "" end
	if ob:hint'plural' then
		return 'are'
	end
	return 'is'
end

function mp.shortcut.have(hint)
	local w = str_split(hint, ",")
	if #w ~= 1 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then return "" end
	if ob:hint'plural' or ob:hint'first' or ob:hint'second' then
		return 'have'
	end
	return 'has'
end

function mp.shortcut.does(hint)
	local w = str_split(hint, ",")
	if #w ~= 1 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then return "" end
	if ob:hint'plural' or ob:hint'first' or ob:hint'second' then
		return 'do'
	end
	return 'does'
end

function mp.shortcut.doesnt(hint)
	local w = str_split(hint, ",")
	if #w ~= 1 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then return "" end
	if ob:hint'plural' or ob:hint'first' or ob:hint'second' then
		return "don't"
	end
	return "doesn't"
end

function mp.shortcut.present(hint)
	local w = str_split(hint, ",")
	if #w ~= 2 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then return "" end
	if ob:hint'plural' or ob:hint'first' or ob:hint'second' then
		return w[2]
	end
	return w[2]..'s'
end

function mp.shortcut.yourself(hint)
	local w = str_split(hint, ",")
	if #w ~= 1 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then return "" end
	return mp:myself(ob)[1]
end

function mp.shortcut.thats(hint)
	local w = str_split(hint, ",")
	if #w ~= 1 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then return "" end
	if ob == std.me() then
		if ob:hint'first' then return "i'm" end
		return ob:noun()..(ob:hint'plural' and "'re" or "'s")
	elseif ob:has'plural' then
		return "they're"
	elseif ob:has'female' then
		return "she's"
	elseif ob:has'male' then
		return "he's"
	end
	return "that's"
end

function mp.shortcut.his(hint)
	local w = str_split(hint, ",")
	local ob
	if #w ~= 1 then
		ob = std.me()
	else
		ob = mp:shortcut_obj(w[1])
	end
	if not ob then return "" end
	if ob == std.me() then
		if ob:hint'first' then
			return "my"
		end
		if ob:hint'second' then
			return ob:hint'plural' and "yours" or "your"
		end
	end
	if ob:has'plural' then
		return "their"
	elseif ob:has'female' then
		return "her"
	elseif ob:has'male' then
		return "his"
	end
	return "its"
end

function mp.shortcut.that(hint)
	local w = str_split(hint, ",")
	if #w ~= 1 then
		return ""
	end
	local ob = mp:shortcut_obj(w[1])
	if not ob then return "" end
	if ob == std.me() then
		if ob:hint'first' then return "i" end
		return ob:noun()
	end
	if ob:has'plural' then
		return "those"
	end
	return "that"
end

mp.msg.SCENE = "{#Me} {#is/#me} {#if_has/#here,supporter,on,in} {#thenoun/#here}.";
mp.msg.INSIDE_SCENE = "{#Me} {#is/#me} {#if_has/#where,supporter,on,in} {#thenoun/#where}.";
mp.msg.TITLE_INSIDE = "{#if_has/#where,supporter,on,in} {#thenoun/#where}";

mp.msg.COMPASS_EXAM = function(dir, ob)
	if dir == 'u_to' then
		p "Upwards there"
	elseif dir == 'd_to' then
		p "Downwards there"
	elseif dir == 'out_to' or dir == 'in_to' then
		p "In that direction there"
	else
		p "In the {#first} direction there"
	end
	if ob:hint'plural' then
		p "are"
	else
		p "is"
	end
	p (ob:the_noun(),".")
end

mp.msg.enter = "<Enter>"
mp.msg.EMPTY = 'Excuse me?'
mp.msg.UNKNOWN_VERB = function(w)
	p ("Unknown verb ", iface:em(w), ".")
end
mp.msg.UNKNOWN_VERB_HINT = function(w)
	p ("The most similar word is ", iface:em(w), ".")
end
mp.msg.INCOMPLETE = "The sentence must be supplemented."
mp.msg.INCOMPLETE_NOUN = function(w)
	if w then
		p ('What do you want to apply the command "'..w..'" to?')
	else
		p "What do you want to apply the command to?"
	end
end
mp.msg.INCOMPLETE_SECOND_NOUN = function(w)
	p ('Clarify the command: "', w, '"?')
end
mp.msg.UNKNOWN_OBJ = function(w)
	if not w then
		p "Nothing is known about this thing here."
	else
		p "Nothing is known about this thing here "
		p ("(", w, ").")
	end
end
mp.msg.UNKNOWN_WORD = function(w)
	if not w then
		p "Phrase not recognized."
	else
		p "Phrase not recognized "
		p ("(",w,").")
	end
end
mp.msg.NOTHING_OBJ = "Nothing."
mp.msg.HINT_WORDS = "Maybe you meant"
mp.msg.AND = "and"
mp.msg.OR = "or"
mp.msg.MULTIPLE = "Here is"
mp.msg.LIVE_ACTION = function(w)
	p (mp:It(w), " would not like it.")
end
mp.msg.NO_LIVE_ACTION = "{#Me} can only do that to something animate."
mp.msg.NOTINV = function(t)
	p (lang.cap(t:the_noun()) .. " must be taken first.")
end
mp.msg.HAS_WORN = function(_)
	return "worn"
end
mp.msg.HAS_OPEN = function(_)
	return "opened"
end
mp.msg.HAS_ON = function(_)
	return "switched on"
end
mp.msg.HAS_LIGHT = function(_)
	return "providing light"
end

mp.msg.EXITBEFORE = "May be, {#me} should to {#if_has/#where,supporter,get off,get out of} {#thenoun/#where}."

mp.default_Event = "Exam"
mp.default_Verb = "examine"

mp.msg.ACCESS1 = "{#Thefirst} {#is/#first} not accessible from here."
mp.msg.ACCESS2 = "{#Thesecond} {#is/#second} not accessible from here."

mp.msg.Look.HEREIS = "Here is"
mp.msg.Look.HEREARE = "Here is"

mp.msg.NOROOM = function(w)
	if w == std.me() then
		p ("{#Me} {#is/#me} {#have/#me} too many things.")
	elseif w:has'supporter' then
		p ("There is no space on ", w:the_noun(), ".")
	else
		p ("There is no space in ", w:the_noun(), ".")
	end
end

mp.msg.Exam.SWITCHSTATE = "{#Thefirst} {#is/#first} switched {#if_has/#first,on,on,off}."
mp.msg.Exam.NOTHING = function(w)
	p "There is nothing "
	if w:has 'supporter' then
		mp:pnoun (w, "on {#thefirst}.")
	else
		mp:pnoun (w, "in {#thefirst}.")
	end
end
mp.msg.Exam.CONTENT = function(w, oo)
	local single = not oo[1]:hint 'plural'
	if std.me():where() == w or std.here() == w then
		p "{#Me} can see"
		mp:multidsc(oo)
		p " here."
		return
	end
	if single then
		p "There is"
	else
		p "There are"
	end
	mp:multidsc(oo)
	if w:has 'supporter' then
		mp:pnoun (w, " on {#thefirst}.")
	else
		mp:pnoun (w, " in {#thefirst}.")
	end
end
mp.msg.Exam.DEFAULT = "{#Me} {#does/#me} not see anything unusual in {#thefirst}.";
mp.msg.Exam.SELF = "{#Me} {#does/#me} not see anything unusual in {#yourself/#me}.";

mp.msg.Exam.OPENED = "{#Thefirst} {#is/#first} opened."
mp.msg.Exam.CLOSED = "{#Thefirst} {#is/#first} closed."
mp.msg.LookUnder.NOTHING = "{#Me} find nothing of interest under {#thefirst}."

mp.msg.Enter.ALREADY = "{#Me} {#is/#me} already {#if_has/#first,supporter,on,in} {#thefirst}."
mp.msg.Enter.INV = "{#Me} {#is/#me} unable to enter the thing {#me} {#is/#me} holding."
mp.msg.Enter.IMPOSSIBLE = "But {#me} {#is/#me} unable to enter in/on {#thefirst}."
mp.msg.Enter.CLOSED = "{#Thefirst} {#is/#first} closed and {#me} can't enter there."
mp.msg.Enter.ENTERED = "{#Me} {#present/#me,get} {#if_has/#first,supporter,on,into} {#thefirst}."
mp.msg.Enter.DOOR_NOWHERE = "{#Thefirst} {#present/#first,lead} nowhere."
mp.msg.Enter.DOOR_CLOSED = "{#Thefirst} {#is/#first} closed."

mp.msg.Walk.ALREADY = mp.msg.Enter.ALREADY
mp.msg.Walk.WALK = "But {#thefirst} {#is/#first} already here."
mp.msg.Walk.NOWHERE = "Where?"
mp.msg.Walk.INV = "{#Me} {#is/#me} holding this."

mp.msg.Enter.EXITBEFORE = "{#Me} {#present/#me,need} to "..
	"{#if_has/#where,supporter,get off from,leave} {#thenoun/#where} first."

mp.msg.Exit.NOTHERE = "But {#me} {#is/#me} not {#if_has/#first,supporter,on,in} {#thefirst}."
mp.msg.Exit.NOWHERE = "But {#me} {#have/#me} no way to exit."
mp.msg.Exit.CLOSED = "But {#thefirst} {#is/#first} closed."
mp.msg.Exit.EXITED = "{#Me} {#if_has/#first,supporter,{#present/#me,get} off,{#present/#me,leave}} {#thefirst}."

mp.msg.GetOff.NOWHERE = "But there is nothing to get off from."

mp.msg.Inv.NOTHING = "{#Me} {#have/#me} nothing."
mp.msg.Inv.INV = "{#Me} {#have/#me}"

mp.msg.Open.OPEN = "{#Me} {#present/#me,open} {#thefirst}."
mp.msg.Open.NOTOPENABLE = "{#Thefirst} {#is/#first} not openable."
mp.msg.Open.WHENOPEN = "{#Thenoun/#first} {#is/#first} already opened."
mp.msg.Open.WHENLOCKED = "It's seems that {#thefirst} {#is/#first} locked."

mp.msg.Close.CLOSE = "{#Me} {#present/#me,close} {#thefirst}."
mp.msg.Close.NOTOPENABLE = "{#Thats/#first} not something {#me} can close."
mp.msg.Close.WHENCLOSED = "{#Thefirst} {#is/#first} already closed."

mp.msg.Lock.IMPOSSIBLE = "{#Firstit} {#doesnt/#first} seem to be something {#me} can lock."
mp.msg.Lock.LOCKED = "{#Thefirst} {#is/#first} already locked."
mp.msg.Lock.OPEN = "{#Me} should close {#thefirst} first."
mp.msg.Lock.WRONGKEY = "{#That/#second} {#doesnt/#second} seem to fit the lock."
mp.msg.Lock.LOCK = "{#Me} {#present/#me,lock} {#thefirst}."

mp.msg.Unlock.IMPOSSIBLE = "{#Firstit} {#doesnt/#first} seem to be something {#me} can unlock."
mp.msg.Unlock.NOTLOCKED = "{#Thefirst} {#is/#first} not locked."
mp.msg.Unlock.WRONGKEY = "{#That/#second} {#doesnt/#second} seem to fit the lock."
mp.msg.Unlock.UNLOCK = "{#Me} {#present/#me,unlock} {#thefirst}."

mp.msg.Take.HAVE = "{#Me} already {#have/#me} {#thefirst}."
mp.msg.Take.TAKE = "{#Me} {#present/#me,take} {#thefirst}."
mp.msg.Take.SELF = "{#Me} always {#have/#me} {#yourself/#me}."

mp.msg.Take.WHERE = "It is impossible to take the thing {#me} {#is/#me} standing in/on."

mp.msg.Take.LIFE = "{#Firstit}'ll not like it."
mp.msg.Take.STATIC = "{#Thats/#first} fixed in place."
mp.msg.Take.SCENERY = "{#Thats/#first} hardly portable."

mp.msg.Take.WORN = "{#Thefirst} {#is/#first} worn on {#thenoun/#firstwhere}."
mp.msg.Take.PARTOF = "{#Thefirst} {#is/#first} part of {#thenoun/#firstwhere}."

mp.msg.Remove.WHERE = "But {#firstit} {#is/#first} not there now."
mp.msg.Remove.REMOVE = "{#Thefirst} {#is/#first} {#if_has/#second,supporter,taken,removed} from {#thesecond}."

mp.msg.Drop.SELF = "{#Me} can't {#does/#me} that."
mp.msg.Drop.WORN = "{#Me}'ll to take off {#thefirst} first."

mp.msg.Insert.INSERT = "{#Me} {#present/#me,put} {#thefirst} into {#thesecond}."
mp.msg.Insert.CLOSED = "{#Thesecond} {#is/#second} closed."
mp.msg.Insert.NOTCONTAINER = "{#Thesecond} can't contain things."
mp.msg.Insert.WHERE = "{#Me} can't put something inside itself."
mp.msg.Insert.ALREADY = "But {#thefirst} {#is/#first} already there."

mp.msg.PutOn.NOTSUPPORTER = "Putting things on {#thesecond} would achieve nothing."
mp.msg.PutOn.PUTON = "{#Me} {#present/#me,put} {#thefirst} on {#thesecond}."
mp.msg.PutOn.WHERE = "{#Me} can't put something on top of itself."

mp.msg.Drop.DROP = "{#Thefirst} {#is/#first} dropped."

mp.msg.ThrowAt.NOTLIFE = "Futile."
mp.msg.ThrowAt.THROW = "You lack the nerve when it comes to the crucial moment."

mp.msg.Wear.NOTCLOTHES = "{#Me} can't wear {#thefirst}."
mp.msg.Wear.WORN = "{#Me} {#is/#me} already wearing {#thefirst}."
mp.msg.Wear.WEAR = "{#Me} {#present/#me,put} on {#thefirst}."

mp.msg.Disrobe.NOTWORN = "{#Me} {#is/#me} not wearing {#thefirst}."
mp.msg.Disrobe.DISROBE = "{#Me} {#present/#me,take} off {#thefirst}."

mp.msg.SwitchOn.NONSWITCHABLE = "{#Thats/#first} not something {#me} can switch."
mp.msg.SwitchOn.ALREADY = "{#Thefirst} {#is/#first} already on"
mp.msg.SwitchOn.SWITCHON = "{#Me} {#present/#me,switch} on {#thefirst}."

mp.msg.SwitchOff.NONSWITCHABLE = "{#Thats/#first} not something {#me} can switch."
mp.msg.SwitchOff.ALREADY = "{#Thefirst} {#is/#first} already off"
mp.msg.SwitchOff.SWITCHOFF = "{#Me} {#present/#me,switch} off {#thefirst}."

mp.msg.Eat.NOTEDIBLE = "{#Thefirst} {#is/#first} plainly inedible."
mp.msg.Eat.EAT = "{#Me} {#present/#me,eat} {#thefirst}. Not bad."

mp.msg.Taste.TASTE = "You taste nothing unexpected.";

mp.msg.Drink.IMPOSSIBLE = "There's nothing suitable to drink here.";

mp.msg.Push.STATIC = "{#Thefirst} {#is/#first} fixed in place."
mp.msg.Push.SCENERY = "{#Me} {#is/#first} unable to."
mp.msg.Push.PUSH = "Nothing obvious happens."

mp.msg.Pull.STATIC = "{#Thefirst} {#is/#first} fixed in place."
mp.msg.Pull.SCENERY = "{#Me} {#is/#first} unable to."
mp.msg.Pull.PULL = "Nothing obvious happens."

mp.msg.Turn.STATIC = "{#Thefirst} {#is/#first} fixed in place."
mp.msg.Turn.SCENERY = "{#Me} {#is/#first} unable to."
mp.msg.Turn.TURN = "Nothing obvious happens."

mp.msg.Wait.WAIT = "Time passes."

mp.msg.Touch.LIVE = "Keep your hands to yourself!"
mp.msg.Touch.TOUCH = "You feel nothing unexpected."
mp.msg.Touch.MYSELF = "{#Me} {#is/#me} here."

mp.msg.Rub.RUB = "{#Me} {#present/#me,achieve} nothing by this."
mp.msg.Sing.SING = "{#His/#me} singing is abominable.";

mp.msg.Give.MYSELF = "{#Me} already {#have/#me} {#firstit}."
mp.msg.Give.GIVE = "{#Thesecond} {#doesnt/#second} seem interested."

mp.msg.Show.SHOW = "{#Thesecond} {#is/#second} unimpressed."

mp.msg.Burn.BURN = "This dangerous act would achieve little."
mp.msg.Burn.BURN2 = "This dangerous act would achieve little."

mp.msg.Wake.WAKE = "The dreadful truth is, this is not a dream."

mp.msg.WakeOther.WAKE = "That seems unnecessary."
mp.msg.WakeOther.NOTLIVE = "{#Thefirst} {#is/#first} not sleeping."

mp.msg.PushDir.PUSH = "Is that the best {#me} can think of?"

mp.msg.Kiss.NOTLIVE = "Keep your mind on the game."
mp.msg.Kiss.KISS = "{#Firstit} would not like it."
mp.msg.Kiss.MYSELF = "Impossible."

mp.msg.Think.THINK = "What a good idea."

mp.msg.Smell.SMELL = "{#Me} {#present/#me,smell} nothing unexpected."
mp.msg.Smell.SMELL2 = "{#present/#first,Smell} as {#anoun/#first}."

mp.msg.Listen.LISTEN = "{#Me} {#present/#me,hear} nothing unexpected."
mp.msg.Listen.LISTEN2 = "{#Me} {#present/#me,hears} {#thefirst}. Nothing unexpected."

mp.msg.Dig.DIG = "Digging would achieve nothing here."
mp.msg.Dig.DIG2 = "Digging {#thefirst} would achieve nothing."
mp.msg.Dig.DIG3 = "Digging {#thefirst} with {#thesecond} would achieve nothing."

mp.msg.Cut.CUT = "Cutting {#that/#first} up would achieve little."
mp.msg.Cut.CUT2 = "Cutting {#that/#first} up with {#thesecond} would achieve little."

mp.msg.Tear.TEAR = "Tearing {#firstit} would achieve nothing."

mp.msg.Tie.TIE = "{#Me} would achieve nothing by this."
mp.msg.Tie.TIE2 = "{#Me} would achieve nothing by this."

mp.msg.Blow.BLOW = "{#Me} can't usefully blow {#that}."

mp.msg.Attack.LIFE = "Violence isn't the answer to {#thefirst}."
mp.msg.Attack.ATTACK = "Violence isn't the answer."

mp.msg.Sleep.SLEEP =  "{#Me} {#is/#me} not feeling especially drowsy."

mp.msg.Swim.SWIM = "There's not enough water to swim in."

mp.msg.Fill.FILL = "It's useless to fill {#thefirst}."

mp.msg.Jump.JUMP = "{#Me} {#present/#me,jump} on the spot, fruitlessly."

mp.msg.JumpOver.JUMPOVER = "{#Me} would achieve nothing by jumping over {#thefirst}."

mp.msg.Consult.CONSULT = "{#Me} {#present/#me,discover} nothing of interest."

mp.msg.WaveHands.WAVE = "{#Me} {#present/#me,wave}, feeling foolish."

mp.msg.Wave.WAVE = "{#Me} {#present/#me,wave} to {#thefirst}, feeling foolish."

mp.msg.Talk.SELF = "No dialog happens."
mp.msg.Talk.NOTLIVE = "{#Thefirst} can't speak."
mp.msg.Talk.LIVE = "No reaction from {#thefirst}."

mp.msg.Tell.SELF = "No dialog happens."

mp.msg.Tell.NOTLIVE = "Silence."
mp.msg.Tell.LIVE = "No reaction from {#thefirst}."
mp.msg.Tell.EMPTY = "{#Me} can't find words to tell."

mp.msg.Ask.NOTLIVE = "No answer."
mp.msg.Ask.LIVE = "{#Firstit} {#doesnt/#first} answer."
mp.msg.Ask.EMPTY = "{#Me} can't find anything to ask."
mp.msg.Ask.SELF = "Good question."

mp.msg.Answer.NOTLIVE = "No reaction."
mp.msg.Answer.LIVE = "{#Firstit} {#doesnt/#first} say anything."
mp.msg.Answer.EMPTY = "{#Me} can't find anything to answer."
mp.msg.Answer.SELF = "Good answer."

mp.msg.Yes.YES = "That was a rhetorical question."
mp.msg.Buy.BUY = "Nothing is on sale."
mp.msg.Use.USE = "How exactly?"

mp.keyboard_space = '<space>'
mp.keyboard_backspace = '<backspace>'

mp.msg.GAMEOVER_HELP = [[Use restart to restart game.]];

function mp:myself(ob)
	if ob:hint'first' then
		return { "myself", "self", "me" }
	end
	if ob:hint'second' then
		return { "yourself", "myself", "self", "me" }
	end
	if ob:hint'plural' then
		return { "themselves", "ourselves", "self" }
	end
	if ob:hint'female' then
		return { "herself", "myself", "self", "me" }
	end
	if ob:hint'male' then
		return { "himself", "myself", "self", "me" }
	end
	return { "itself", "myself", "self", "me" }
end

function mp:it(w)
	if w == std.me() then
		if w:hint'first' then
			return "me"
		elseif w:hint'second' then
			return "you"
		end
	end
	if w:hint'plural' then
		return "they"
	elseif w:hint'female' then
		return "she"
	elseif w:hint'male' then
		return "he"
	end
	return "it"
end

function mp:synonyms(w, hint)
	local t = self:it(w, hint)
	w = { t }
	if t == 'he' then
		w[2] = 'him'
	elseif t == 'she' then
		w[2] = 'her'
	elseif t == 'they' then
		w[2] = 'them'
	end
	return w
end

mp.keyboard = {
	'A','B','C','D','E','F','G','H','I','J','K',
	'L','M','N','O','P','Q','R','S','T','U','V',
	'W','X','Y','Z'
}

function mp:err_noun(noun)
	if noun == '*' then return "{$fmt em|<word>}" end
	return "{$fmt em|noun}"
end

function mp:before_Enter(w)
	if mp:compass_dir(w) then
		mp:xaction("Walk", w)
		return
	end
	return false
end

mp.msg.HELP = function()
	p [[{$fmt b|INSTRUCTIONS}^^

Enter your actions in verb noun form. For example:^
> open door^
> unlock door with key^
> go north^
> take cap^
^
To examine a thing, enter "exam book" or just "book".^
^
To examine whole scene, enter "exam" or press "Enter".^
^
To exam your inventory, enter "inv".^
^
Use compass directions to walk. For example: "go north" or "north" or just "n". There are also up and down directions, outside and inside.]]
	if not instead.tiny then
		p [[^^You may use the "TAB" key for autocompletion.]]
	else
		p [[^^Use "save" and "load" to save and load game.]]
		if instead.tiny then
			p [[For ex. "save 1".]]
		end
		p [[Restart game: "restart".]]
		if instead.reinstead then
			p [[^^Also available: !restart, !quit, !info, !save, !load and !font <size>.]]
		end
	end

end

function mp.token.compass1(_)
	return "{noun_obj}/@n_to,compass|{noun_obj}/@ne_to,compass|"..
		"{noun_obj}/@e_to,compass|{noun_obj}/@se_to,compass|"..
		"{noun_obj}/@s_to,compass|{noun_obj}/@sw_to,compass|"..
		"{noun_obj}/@w_to,compass|{noun_obj}/@nw_to,compass"
end

function mp.token.compass2(_)
	return "{noun_obj}/@u_to,compass|{noun_obj}/@d_to,compass|{noun_obj}/@in_to,compass|{noun_obj}/@out_to,compass"
end

std.mod_init(function(_)
Verb { "#Walk",
	"go,walk,run,enter,come",
	"{compass1} : Walk",
	"in|into|inside|on {noun}/scene,enterable : Enter",
	"{noun}/scene : Walk",
	"{compass2}: Walk",
	"outside|out|away: Exit"
}

Verb { "#Enter",
	"enter",
	"{noun}/scene,enterable : Enter"
}

Verb { "#Sit",
	"sit,stand",
	"?down in|into|inside|on {noun}/scene,enterable : Enter" }

Verb { "#Lie",
	"lie",
	"down in|into|inside|on {noun}/scene,enterable : Enter" }

Verb { "#Exit",
	"exit,out,leave",
	"?from {noun}/scene : Exit",
	": Exit"}

Verb { "#Exam",
	"examine,exam,check,describe,watch,look",
	"{noun} : Exam",
	" : Look",
	"inventory : Inv",
	"~ under {noun} : LookUnder",
	"~ in|inside|into|through|on {noun} : Search",
	"~ ?at {noun} : Exam",
	"~ up * in {noun} : Consult reverse",
}

Verb { "#Search",
	"search,investigate",
	"{noun} : Search",
	"in|into|inside|on|through {noun} : Search",
	"under {noun} : LookUnder",
}

Verb { "#Open",
	"open",
	"{noun} : Open",
	"{noun} with {noun}/held : Unlock"
}

Verb { "#Unlock",
	"unlock",
	"{noun} with {noun}/held : Unlock"
}

Verb { "#Close",
	"close",
	"{noun} : Close",
	"{noun} with {noun}/held : Lock",
}

Verb { "#Lock",
	"lock",
	"{noun} with {noun}/held : Lock",
}

Verb { "#Inv",
	"inv/entory",
	"Inv" }

Verb { "#Take",
	"take,get,pick,hold,carry,peel",
	"{noun}/scene : Take",
	"{noun}/scene from {noun}/inside,holder : Remove",
	"off {noun}/worn : Disrobe",
}

Verb { "#Drop",
	"drop,discard",
	"{noun}/held : Drop",
	"{noun}/held in|into|down {noun}/inside : Insert",
	"{noun}/held on|onto {noun} : PutOn",
}

Verb { "#Insert",
	"insert",
	"{noun}/held in|into|inside {noun}/inside : Insert",
}

Verb { "#Put",
	"~put",
	"~ {noun}/held : Drop",
	"~ {noun}/held in|into|inside {noun}/inside : Insert",
	"~ {noun}/held on|onto {noun} : PutOn",
	"~ on {noun}/held : Wear",
	"~ down {noun}/held : Drop",
	"~ {noun}/held down: Drop",
}

Verb {
	"#ThrowAt",
	"throw",
	"{noun}/held at|against|in|into|on|onto {noun} : ThrowAt",
	"~ {noun}/held : Drop",
}

Verb {
	"#Wear",
	"wear,don",
	"{noun}/held : Wear",
}

Verb {
	"#Disrobe",
	"disrobe,shed,doff",
	"{noun}/worn : Disrobe",
}

Verb {
	"#Remove",
	"remove",
	"~ {noun}/held : Disrobe",
	"{noun} from {noun} : Remove",
	"~ {noun}/scene : Take",
}

Verb {
	"#SwitchOn",
	"switch",
	"on {noun}: SwitchOn",
	"~ {noun} : SwitchOn",
	"~ {noun} on : SwitchOn",
}

Verb {
	"#SwitchOff",
	"switch",
	"off {noun}: SwitchOff",
	"~ {noun} off : SwitchOff",
}

Verb {
	"#Eat",
	"eat",
	"{noun}/held : Eat",
}

Verb {
	"#Taste",
	"taste,lick",
	"{noun} : Taste"
}

Verb {
	"#Drink",
	"drink,sip,swallow",
	"{noun}/held : Drink",
}

Verb {
	"#Push",
	"push,move,press,shift,clear",
	"{noun} : Push",
	"{noun} to {noun} : Transfer",
	"{noun} ?to {compass2} : Transfer",
}

Verb {
	"#Transfer",
	"transfer",
	"{noun} to {noun} : Transfer",
	"{noun} ?to {compass2} : Transfer",
}

Verb {
	"#Pull",
	"pull,drag",
	"{noun} : Pull",
}

Verb {
	"#Turn",
	"turn,rotate,screw,twist,unscrew",
	"{noun} : Turn",
	"~ {noun} on : SwitchOn",
	"~ {noun} off : SwitchOff",
	"~ on {noun} : SwitchOn",
	"~ off {noun} : SwitchOff",
}

Verb {
	"#Wait",
	"wait",
	"Wait"
}

Verb {
	"#Rub",
	"rub,clean,dust,polish,scrub,shine,sweep,wipe",
	"{noun} : Rub"
}

Verb {
	"#Sing",
	"sing",
	"Sing"
}

Verb {
	"#Touch",
	"touch,feel,fondle,grope",
	"{noun} : Touch",
}

Verb {
	"#Give",
	"give,feed,offer,pay",
	"?over {noun}/held to {noun}/live : Give",
	"~ {noun}/live {noun}/held : Give reverse",
}

Verb {
	"#Show",
	"show,display,present",
	"{noun}/held to {noun}/live : Show",
	"~ {noun}/live {noun}/held : Show reverse",
}

Verb {
	"#Burn",
	"burn,light",
	"{noun} : Burn",
	"{noun} with {noun}/held : Burn",
}

Verb {
	"#Wake",
	"wake,awake,awaken",
	"?up : Wake",
	"?up {noun}/вн ?up : WakeOther",
}

Verb {
	"#Kiss",
	"kiss,embrace,hug",
	"{noun}/live : Kiss"
}

Verb {
	"#Think",
	"think",
	"Think"
}

Verb {
	"#Smell",
	"smell,sniff",
	"Smell",
	"{noun} : Smell"
}

Verb {
	"#Listen",
	"listen,hear",
	"Listen",
	"?to {noun}: Listen",
}

Verb {
	"#Dig",
	"dig",
	"Dig",
	"{noun}/scene : Dig",
	"{noun}/scene with {noun}/held : Dig",
}

Verb {
	"#Cut",
	"cut,chop,prune,slice",
	"{noun} : Cut",
	"{noun} with {noun}/held: Cut",
}

Verb {
	"#Tear",
	"tear",
	"?apart {noun} : Tear",
}

Verb {
	"#Tie",
	"tie,attach,fasten,fix",
	"{noun} : Tie",
	"{noun} to {noun} : Tie",
}

Verb {
	"#Blow",
	"blow",
	"{noun} : Blow",
}

Verb {
	"#Attack",
	"attack,break,crack,destroy,fight,hit,kill,murder,punch,smash,thump,torture,wreck,kick",
	"{noun} : Attack"
}

Verb {
	"#Sleep",
	"sleep,nap",
	"Sleep",
}

Verb {
	"#Swim",
	"swim,dive",
	"Swim",
}

Verb {
	"#Consult",
	"read",
	"* in {noun}: Consult reverse",
	"~ {noun} : Exam",
}

Verb {
	"#Fill",
	"fill",
	"{noun} : Fill",
}

Verb {
	"#Jump",
	"jump,hop,skip",
	"Jump",
	"over {noun}/scene : JumpOver",
	"~ {compass2} : Walk",
}

Verb {
	"#Wave",
	"wave",
	"WaveHands",
	"{noun}/held : Wave"
}

Verb {
	"#Climb",
	"climb,scale",
	"{noun}/scene : Climb",
	"~ up|over {noun}/scene : Climb",
	"~ in|into {noun}/scene : Enter",
	"~ {compass2}: Walk",
}

Verb {
	"#GetOff",
	"get",
	"off {noun}/scene : GetOff",
	"~ out|off|up : Exit",
	"~ in|into|on|onto {noun} : Enter",
}

Verb {
	"#Buy",
	"buy,purchase",
	"{noun}/scene : Buy"
}

Verb {
	"#Talk",
	"talk",
	"with|to {noun}/live : Talk"
}

Verb {
	"#Tell",
	"tell",
	"{noun}/live about * : Tell",
	"~ {noun}/live to * : AskTo",
}

Verb {
	"#Ask",
	"ask",
	"{noun}/live about * : Ask",
	"~ {noun}/live to * : AskTo",
	"~ that {noun}/live to * : AskTo",
}

Verb {
	"#AskFor",
	"ask",
	"{noun}/live for * : AskFor",
}

Verb {
	"#Answer",
	"answer,say,shout,speak",
	"* to {noun}/live : Answer reverse",
}

Verb {
	"#Yes",
	"yes",
	"Yes",
}

Verb {
	"#No",
	"no",
	"No",
}

Verb {
    "~ use",
    "{noun} : Use",
}

if DEBUG then
	MetaVerb {
		"#MetaWord",
		"~_word",
		"* : MetaWord"
	}
	MetaVerb {
		"#MetaNoun",
		"~_noun",
		"* : MetaNoun"
	}
	MetaVerb {
		"#MetaTrace",
		"~_trace",
		"on : MetaTraceOn",
		"off : MetaTraceOff",
	}
	MetaVerb {
		"#MetaDump",
		"~_dump",
		"MetaDump"
	}
end

mp.msg.MetaTranscript.ON = function(file)
	p ("Logging is started: ", file)
end

mp.msg.MetaTranscript.OFF = function(file)
	p ("Logging is stopped: ", file)
end

mp.msg.MetaTranscript.FILE = function(file)
	p ("Log file: ", file)
end

MetaVerb {
	"#MetaTranscript",
	"~transcript",
	"on : MetaTranscriptOn",
	"off : MetaTranscriptOff",
	"MetaTranscript",
}

MetaVerb {
	"#MetaSave",
	"~save",
	"MetaSave"
}

MetaVerb {
	"#MetaExpert",
	"~parser",
	"expert on : MetaExpertOn",
	"expert off : MetaExpertOff",
	"verbs : MetaVerbs",
	"version : MetaVersion",
}

MetaVerb {
	"#MetaLoad",
	"~load",
	"MetaLoad"
}

if DEBUG then
MetaVerb {
	"#MetaAutoplay",
	"~autoplay",
	"MetaAutoplay"
}
end

mp.msg.MetaRestart.RESTART = "Restart?";

MetaVerb {
	"#MetaRestart",
	"~restart",
	"MetaRestart"
}
MetaVerb {
	"#MetaHelp",
	"~help,instructions",
	"MetaHelp",
}
end, 1)

std.mod_start(function()
	if mp.undo > 0 then
		mp.msg.MetaUndo.EMPTY = "Nothing to undo."
		MetaVerb {
			"#MetaUndo",
			"~undo",
			"MetaUndo",
		}
	end
	if mp.score then
		MetaVerb {
		"~ счёт",
		"MetaScore",
		}
	end
end)
-- Dialog
std.phr.default_Event = "Exam"

Verb ({"~ say", "{select} : Exam" }, std.dlg)
Verb ({'#Next', "more,next", "Next" }, mp.cutscene)
Verb ({'#Exam', "~ exam/ine", "Look" }, std.dlg)

mp.cutscene.default_Verb = "more"
mp.cutscene.help = fmt.em "<more>";

std.dlg.default_Verb = "examine"

std.player.word = "you/plural,second"
local curdir = std.getinfo(1).source:gsub("^(.+[\\/])[^\\/]+$", "%1"):gsub("^@", "");
local table = std.table
require "fmt"
require "snapshots"

local tostring = std.tostr

--luacheck: no self
if std.ref'@theme' then
	std.ref'@theme'.set ('win.scroll.mode', 3)
end

local mrd = require "morph/mrd"

local input = std.ref '@input'

local function utf_bb(b, pos)
	if type(b) ~= 'string' or b:len() == 0 then
		return 0
	end
	local utf8 = (std.game.codepage == 'UTF-8' or std.game.codepage == 'utf-8')
	if not utf8 then return 1 end
	local i = pos or b:len()
	local l = 0
	while b:byte(i) >= 0x80 and b:byte(i) <= 0xbf do
		i = i - 1
		l = l + 1
		if i <= 1 then
			break
		end
	end
	return l + 1
end

local function utf_ff(b, pos)
	if type(b) ~= 'string' or b:len() == 0 then
		return 0
	end
	local utf8 = (std.game.codepage == 'UTF-8' or std.game.codepage == 'utf-8')
	if not utf8 then return 1 end
	local i = pos or 1
	local l = 0
	if b:byte(i) < 0x80 then
		return 1
	end
	i = i + 1
	l = l + 1
	while b:byte(i) and b:byte(i) >= 0x80 and b:byte(i) <= 0xbf do
		i = i + 1
		l = l + 1
		if i > b:len() then
			break
		end
	end
	return l
end

local function utf_len(b)
	local i = 1
	local n = 0
	if not b or b:len() == 0 then
		return 0
	end
	while i <= b:len() do
		i = i + utf_ff(b, i)
		n = n + 1
	end
	return n
end

local function utf_char(b, c)
	local i = 1
	local n = 0
	local s
	while i <= b:len() do
		s = i
		i = i + utf_ff(b, i)
		n = n + 1
		if n == c then
			return b:sub(s, i - 1)
		end
	end
	return
end

local function utf_chars(b)
	local i = 1
	local s
	local res = {}
	local ff = std.rawget(_G, 'utf8_next') or utf_ff
	while i <= b:len() do
		s = i
		i = i + ff(b, i)
		table.insert(res,  b:sub(s, i - 1))
	end
	return res
end

local function utf_similar(str1, str2, lev)
	local chars1 = utf_chars(str1)
	local chars2 = utf_chars(str2)
	local len1 = #chars1
	local len2 = #chars2
	if len1 < lev or len2 < lev then
		return false
	end

	for i = 0, len2 - lev do
		local ok = true
		for k = 1, lev do
			if chars1[k] ~= chars2[i + k] then
				ok = false
				break
			end
		end
		if ok then return true end
	end

	for i = 0, len1 - lev do
		local ok = true
		for k = 1, lev do
			if chars2[k] ~= chars1[i + k] then
				ok = false
				break
			end
		end
		if ok then return true end
	end
	return false
end
--- Returns the Levenshtein distance between the two given strings.
-- https://gist.github.com/Badgerati/3261142

-- @param str1 string1
-- @param str2 string2
local function utf_lev(str1, str2)
	str1 = str1 or ''
	str2 = str2 or ''
	local chars1 = utf_chars(str1)
	local chars2 = utf_chars(str2)
	local len1 = #chars1
	local len2 = #chars2
	local matrix = {}
	local cost

        -- quick cut-offs to save time
	if (len1 == 0) then
		return len2
	elseif (len2 == 0) then
		return len1
	elseif (str1 == str2) then
		return 0
	end

        -- initialise the base matrix values
	for i = 0, len1, 1 do
		matrix[i] = {}
		matrix[i][0] = i
	end
	for j = 0, len2, 1 do
		matrix[0][j] = j
	end

        -- actual Levenshtein algorithm
	for i = 1, len1, 1 do
		for j = 1, len2, 1 do
			if (chars1[i] == chars2[j]) then
				cost = 0
			else
				cost = 1
			end

			matrix[i][j] = math.min(matrix[i-1][j] + 1, matrix[i][j-1] + 1, matrix[i-1][j-1] + cost)
		end
	end

        -- return the last value - this is the Levenshtein distance
	return matrix[len1][len2]
end
local okey = input.key
local mp

local function use_text_event()
	return instead.text_input and instead.text_input()
end

if PLATFORM == "ANDROID" or PLATFORM == "IOS" or PLATFORM == "SFOS" then
local oclick = input.click

function input:click(press, mb, x, y, ...)
	local theme = std.ref'@theme'

	if not instead.text_input or not press or mb ~= 1 or not theme or mp.autohelp then
		if oclick then
			return oclick(self, press, mb, x, y, ...)
		end
		return false
	end

	local xx = std.tonum(theme.get 'inv.x')
	local yy = std.tonum(theme.get 'inv.y')
	local ww = std.tonum(theme.get 'inv.w')
	local hh = std.tonum(theme.get 'inv.h')
	if x >= xx and y >= yy and x < xx + ww and y < yy + hh then
		instead.text_input(not instead.text_input())
	end
	if oclick then
		return oclick(self, press, mb, x, y, ...)
	end
	return false
end
end

function input:text(sym)
	if sym == " " then -- in old key logic
		return false
	end
	if iface:raw_mode() then
		return false
	end
	mp:inp_insert(sym)
	mp:post_inp()
	return '@mp_key '..tostring(sym)
end

function input:key(press, key)
	local mod
	if mp:noparser() then
		return false
	end
	if key:find("alt") then
		mp.alt = press
		mod = true
	elseif key:find("ctrl") then
		mp.ctrl = press
		mod = true
	elseif key:find("shift") then
		mp.shift = press
		mod = true
	end
	if key:find("enter") or key:find("return") then key = 'enter' end

	if press and not mod and not (mp.ctrl or mp.alt) then
		if mp:key(key) then
			mp:post_inp()
			if key == 'f6' and mp.autoplay then key = 'enter' end
			return '@mp_key '..tostring(key)
		end
	end
	if okey then
		return okey(self, press, key)
	end
end

mp = std.obj {
	nam = '@metaparser';
	started = false;
	score = false;
	maxscore = false;
	expert_mode = true;
	strict_mode = false;
	autohelp = false;
	autohelp_limit = 1000;
	autohelp_noverbs = false;
	togglehelp = true;
	errhints = true;
	autocompl = true;
	undo = 0;
	compl_thresh = 0;
	compare_len = 3;
	detailed_inv = false;
	last_gfx = false;
	inp_delim = " :.,!?-";
	daemons = std.list {};
	{
		version = "2.4";
		cache = { tokens = {}, nouns = false };
		scope = std.list {};
		logfile = false;
		lognum = 0;
		clear_on_move = true;
		auto_animate = true;
		autoplay = false;
		pushed = {};
		autoplay_command = false;
		inp = '';
		cur = 1;
		utf = {
			bb = std.rawget(_G, 'utf8_prev') or utf_bb;
			ff = std.rawget(_G, 'utf8_next') or utf_ff;
			len = std.rawget(_G, 'utf8_len') or utf_len;
			char = std.rawget(_G, 'utf8_char') or utf_char;
			chars = utf_chars;
		};
		lev_thresh = 3;
		lev_ratio = 0.20;
		history = {};
		persistent = std.list {};
		winsize = 16 * 1024;
		history_len = 100;
		history_pos = 0;
		cursor = fmt.b("|");
		prompt = "> ";
		ctrl = false;
		shift = false;
		alt = false;
		words = {};
		parsed = {};
		hints = {};
		unknown = {};
		multi = {};
		token = {};
		shortcut = {};
		snapshot = false;
		reaction = false;
		redirect = false;
		msg = {};
		mrd = mrd;
		args = {};
		vargs = {};
		debug = { trace_action = false };
		completions = {};
		event = false;
		xevent = false;
		aliases = {};
		first = false;
		first_it = false;
		second_it = false;
		second = false;
		first_hint = '';
		second_hint = '';
		hint = {
			live = 'live',
			neuter = 'neuter',
			male = 'male',
			female = 'female',
			plural = 'plural',
		};
		shorten = {};
		shorten_expert = {};
		_pager_mode = false;
	};
	text = '';
	-- dict = {};
}

function mp:post_inp()
	if mp.autohelp then
		mp:compl_fill(mp:compl(mp.inp))
	elseif mp.autocompl then
		mp:compl(mp.inp)
	end
end

function mp:onedit()
end

function mp:trim()
	if self.winsize == 0 then
		self.text = ""
		return
	end
	local text = self.text
	while text:len() > self.winsize do
		local text2 = text:gsub("^%^?[^%^]*%^%^", "")
		if text2 == text then
			break
		end
		text = text2
	end
	self.text = text
end

function mp:key(key)
	if key == 'f1' and (self.togglehelp or DEBUG) then
		self.autohelp = not self.autohelp
		return true
	end
	if key == 'f6' and DEBUG then
		self:autoscript()
		return true
	end
	if key == 'home' or key == '[7]' then
		self.cur = 1
		return true
	end
	if key == 'end' or key == '[1]' then
		self.cur = self.inp:len() + 1
		return true
	end
	if key == 'left' then
		return self:inp_left()
	end
	if key == 'right' then
		return self:inp_right()
	end
	if key == 'up' then
		return self:key_history_prev()
	end
	if key == 'down' then
		return self:key_history_next()
	end
	if key == 'space' then
--		local inp = mp:docompl(self.inp)
--		if inp == self.inp then
			mp:inp_insert(' ')
--		else
--			self.inp = inp
--			self.cur = self.inp:len() + 1
--		end
		return true
	end
	if key == 'tab' then
		self.inp = mp:docompl(self.inp)
		self.cur = self.inp:len() + 1
		return true
	end
	if key == 'backspace' then
		if self:inp_remove() then
			return true
		end
		return true -- avoid scrolling
	end
	if key == 'enter' then
		return true
	end
	if use_text_event() then
		return false
	end
	if key:len() > 1 then
		return false
	end
	key = mp.shift and mrd.lang.kbd.shifted[key] or mrd.lang.kbd[key] or key
	if key then
		mp:inp_insert(key)
		return true
	end
	return false
end

function mp:inp_left()
	if self.cur > 1 then
		local i = mp.utf.bb(self.inp, self.cur - 1)
		self.cur = self.cur - i
		return true
	end
end

function mp:inp_right()
	if self.cur <= self.inp:len() then
		local i = mp.utf.ff(self.inp, self.cur)
		self.cur = self.cur + i
		return true
	end
end

function mp:inp_split()
	local pre = self.inp:sub(1, self.cur - 1);
	local post = self.inp:sub(self.cur);
	return pre, post
end

function mp:inp_insert(k)
	local pre, post = self:inp_split()
	self.cur = self.cur + k:len()
	self.inp = pre .. k .. post
end

function mp:inp_remove()
	local pre, post = self:inp_split()
	if not pre or pre == '' then
		return false
	end
	local i = mp.utf.bb(pre)
	self.inp = self.inp:sub(1, pre:len() - i) .. post
	self.cur = self.cur - i
	return true
end

function mp:esc(s)
	local rep = function(str)
		return fmt.nb(str)
	end
	if not s then return end
	local r = s:gsub("[<>]+", rep):gsub("[ \t]", rep);
	return r
end

local keys_en = {
	"A", "B", "C", "D", "E", "F",
	"G", "H", "I", "J", "K", "L",
	"M", "N", "O", "P", "Q", "R",
	"S", "T", "U", "V", "W", "X",
	"Y", "Z"
}

local function str_strip(str)
	return std.strip(str)
end

local function str_split(str, delim)
	local a = std.split(str, delim)
	for k, _ in ipairs(a) do
		a[k] = str_strip(a[k])
	end
	return a
end

--- Returns true if parser mode is disabled
function mp:noparser()
	return std.here().noparser or game.noparser
end

instead.get_inv = std.cacheable('inv', function(horiz)
	if mp:noparser() then
		return
	end
	local delim = instead.hinv_delim
	if not horiz then
		delim = instead.inv_delim
	end
	local pre, post = mp:inp_split()
	local ret = iface:bold(mp.prompt) .. mp:esc(pre)..mp.cursor..mp:esc(post) .. '\n'
	if mp.autohelp then
		ret = iface:xref(ret, mp, "<clear>")
	end
	if not mp.autohelp and not std.here().forcehelp then
		local r = std.call(std.here(), 'help')
		return ret .. (r or '')
	end

	if mp.autohelp_noverbs and mp.inp:find("^[ \t]*$") then
		return ret
	end

	delim = delim or ' | '

	for _, v in ipairs(mp.completions) do
		local t = iface:xref(std.fmt(v.word), mp, v.word)
		if v.ob and have(v.ob) then t = iface:em(t) end
		if _ >= mp.autohelp_limit then
			ret = ret .. t .. ' ...' .. delim
			break
		end
		ret = ret .. t .. delim
	end
	if #mp.completions == 0 or mp.completions.eol then
		ret = ret .. iface:xref(mp.msg.enter or "<enter>", mp, "<enter>") .. delim
		if mp.completions.vargs then
			ret = ret .. iface:xref(mp.keyboard_space or "<space>", mp, "<space>") .. delim
			ret = ret .. iface:xref(mp.keyboard_backspace or "<backspace>", mp, "<backspace>") .. delim
			for _, v in ipairs(mp.keyboard or keys_en) do
				ret = ret .. iface:xref(v, mp, v, 'letter') .. delim
			end
		end
	end

	ret = ret:gsub(delim .."$", "")
	return ret
end)

--- Returns (add to) table with scope objects
-- @param wh where to start scope
-- @param oo table
-- @param recurs recursive flag
-- @param scope scope list (optional)

function mp:objects(wh, oo, recurs, scope)
	wh:for_each(function(v)
		if v:disabled() then return nil, false end
		if v:visible() or (scope and scope:lookup(v)) then
			table.insert(oo, v)
			if scope and v.scope then
				if std.is_obj(v.scope, 'list') then
					scope:cat(v.scope)
				elseif type(v.scope) == 'function' then
					v:scope(scope)
				end
			end
		end
		if recurs == false or v:closed() then
			if std.is_obj(wh, 'list') then
				return -- just skip
			end
			return nil, false
		end
		if std.is_obj(wh, 'list') then
			self:objects(v, oo, recurs, scope)
		end
	end)
end

local darkness = std.obj {
	nam = '@darkness';
}

function mp:nouns()
	local scope = self.scope
	scope:zap()
	if type(std.here().nouns) == 'function' then
		return std.here():nouns()
	end
	local oo = {}
	self:objects(std.me():inroom(), oo, true, scope)
	self:objects(std.list { std.me() }, oo, true, scope)
	self:objects(self.persistent, oo, true, scope)
	local ob = std.list {}
	if std.here().word then
		ob:add(std.here())
	end
	if self:thedark() then
		ob:add(darkness)
	end
	self:objects(ob, oo, false, scope)
	local dups = {}
	scope:for_each(function(v)
		if not dups[v] then
			table.insert(oo, v)
			dups[v] = true
		end
	end)
	return oo
end

function mp.token.noun_obj(w)
	return mp.token.noun(w)
end

function mp.token.noun(w)
	local attr = w.morph or ''
	local oo
	local ww = {}
	if w.pat == '{noun_obj}' then
		local hint = str_split(w.morph, ",")
		local o = std.ref(hint[1])
		oo = {}
		if o:visible() and not o:disabled() then
			table.insert(oo, o)
			mp:objects(o, oo)
		end
	else
		oo = mp.cache.nouns or {}
	end

	local sm_dup = {
	}
	local syms = {}
	for _, o in ipairs(oo) do
		local d = {}
		local r = o:noun(attr, d)
		if o == std.me() and mp.myself then
			for _, vm in ipairs(mp:myself(o, w.morph) or {}) do
				table.insert(ww, { optional = w.optional, word = vm, morph = attr, ob = o, alias = o.alias,
					hidden = w.hidden or _ ~= 1 })
			end
		end
		if o ~= std.me() or (not o:hint'first' and not o:hint'second') then
			for k, v in ipairs(d) do
				local hidden = (k ~= 1) or w.hidden
				if o:has 'multi' then
					hidden = w.hidden or (v.idx ~= 1)
				end
				table.insert(ww,
					{ optional = w.optional,
						word = r[k], ob = o,
						morph = attr, alias = v.alias,
						hidden = hidden })
			end
			if o == mp.first_it then
				table.insert(syms, 1, o)
			elseif o == mp.second_it then
				table.insert(syms, o)
			end
		end
	end

--	for k = 1, #syms do
--		table.insert(oo, k, syms[k])
--	end

	oo = syms

	for _, o in ipairs(oo) do
		for _, v in ipairs(mp:synonyms(o, w.morph)) do
			if not sm_dup[v] then
				table.insert(ww, { optional = w.optional, word = v, ob = o, morph = attr,
					alias = o.alias, hidden = true, synonym = true })
				sm_dup[v] = true
			end
		end
	end

	return ww
end

function mp.token.select(w)
	return mp.token.noun(w)
end

local norm_cache = { hash = {}, list = {}}

function mp:norm(t)
	local key = t
	local cc = norm_cache.hash[t]
	if cc then return cc end
	t = mrd.lang.lower(mrd.lang.norm(t)):gsub("[ \t]+", " ")
	table.insert(norm_cache.list, 1, t)
	norm_cache.hash[key] = t
	local len = #norm_cache.list
	if len > 512 then
		cc = norm_cache.list[len]
		table.remove(norm_cache.list, len)
		norm_cache.hash[cc] = nil
	end
	return t
end

--- Check if two strings are equal, using two possible check modes.
-- If lev is set, use it as Levenstein equality threshold.
-- If not, normalize the strings and check equality.
--
-- @see word_search
-- @see mp:lookup_noun
-- @param t1 first string
-- @param t2 second string
-- @param lev use levenstein or just normalize and compare
function mp:eq(t1, t2, lev)
	if t1:find("%*$") then
		local t = t1:gsub("%*$", "")
		t = self:norm(t)
		return self:__startswith(t2, t)
	end
	if lev then
		t1 = self:norm(t1)
		t2 = self:norm(t2)
		if not utf_similar(t1, t2, 3) then -- 3 is hardcoded
			return false
		end
		local l = utf_lev(t1, t2)
		if l < lev and l / (utf_len(t1) + utf_len(t2)) <= self.lev_ratio then
			return l
		end
		return false
	end
	return self:norm(t1) == self:norm(t2)
end

local function starteq(t1, t2)
	if t2:len() >= t1:len() or mp.utf.len(t2) < mp.compare_len then
		return mp:eq(t1, t2)
	end
	t1 = t1:sub(1, t2:len())
	return mp:norm(t1) == mp:norm(t2)
end

function mp:pattern(t, delim)
	local words = {}
	local pat = str_split(t, delim or "|")
	for _, v in ipairs(pat) do
		local w = { }
		local ov = v
		if v:sub(1, 1) == '~' then
			v = v:sub(2)
			v = str_strip(v)
			w.hidden = true
		end
		if v:sub(1, 1) == '+' then
			v = v:sub(2)
			v = str_strip(v)
			w.optional = true
			w.default = true
		end
		if v:sub(1, 1) == '?' then
			v = v:sub(2)
			v = str_strip(v)
			w.optional = true
		end
		v = v:gsub("%+", " ") -- spaces
		if v:find("[^/]+/[^/]*$") then
			local s, e = v:find("/[^/]*$")
			w.morph = v:sub(s + 1, e)
			v = v:sub(1, s - 1)
			v = str_strip(v)
		end
		w.pat = v
		if v:find("^{[^}]+}$") then -- completion function
			v = v:gsub("^{", ""):gsub("}$", "")
			if type(self.token[v]) ~= 'function' then
				std.err("Wrong subst function: ".. v, 2);
			end
			local key = ov --  .. '/' .. (w.morph or '')
			local tok = self.cache.tokens[key]
			if not tok then
				tok = self.token[v](w)
				self.cache.tokens[key] = tok
			end
			while type(tok) == 'string' do
				tok = self:pattern(tok)
			end
			if type(tok) == 'table' then
				for _, xw in ipairs(tok) do
					table.insert(words, xw)
				end
			end
		else
			local vv = {}
			for _, w in ipairs(mp:pref_pattern(v)) do
				for _, w in ipairs(mp:suff_pattern(w)) do
					table.insert(vv, w)
				end
			end
			if #vv == 1 then
				w.word = v
				table.insert(words, w)
			else
				for _, exv in ipairs(vv) do
					local ww = std.clone(w)
					ww.word = exv
					table.insert(words, ww)
				end
			end
		end
	end
	return words
end

function mp:verb_find(tag, w)
	w = w or game
	for k, v in ipairs(w.__Verbs or {}) do
		if v.tag == tag then
			return v, k
		end
	end
end

function mp:verb_remove(tag, w)
	local v, k = self:verb_find(tag, w)
	if v then
		table.remove((w or game).__Verbs, k)
	end
	return v
end

function mp:pref_pattern(v)
	if not v:find("^%[[^%]]+%]") then
		return { v }
	end
	local _, e = v:find("]", 1, true)
	local pre = v:sub(2, e - 1)
	local post = v:sub(e + 1)
	pre = pre:gsub("^|", " |"):gsub("|$", "| "):gsub("||", "| |");
	pre = str_split(pre, "|")
	local ret = {}
	for _, pref in ipairs(pre) do
		table.insert(ret, pref .. post)
	end
	return ret
end

function mp:suff_pattern(v)
	if not v:find("%[[^%]]+%]$") then
		return { v }
	end
	local s, _ = v:find("[", 1, true)
	local e, _ = v:find("]", 1, true)
	local suff = v:sub(s + 1, e - 1)
	local pref = v:sub(1, s - 1)
	suff = suff:gsub("^|", " |"):gsub("|$", "| "):gsub("||", "| |");
	suff = str_split(suff, "|")
	local ret = {}
	for _, suff in ipairs(suff) do
		table.insert(ret, pref .. suff)
	end
	return ret
end

function mp:verb(t, w, extend, extend_words)
	local rem
	w = w or game
	if type(t) ~= 'table' then
		std.err("Wrong 1-arg to mp:verb()", 2)
	end
	if type(w) ~= 'table' then
		std.err("Wrong 2-arg to mp:verb()", 2)
	end
	if not w.__Verbs then
		std.rawset(w, '__Verbs', {})
	end
	local verb = {}
	local n = 1
	if std.is_tag(t[1]) then
		verb.tag = t[1]
		rem = self:verb_remove(verb.tag, w)
		n = 2
	end
	if extend and (not rem or not verb.tag) then
		std.err("Extending non existing verb "..verb.tag or '#Undefined', 2)
	end
	if extend then
		verb.verb = rem.verb
		verb.dsc = rem.dsc
	end
	if not extend or extend_words then
		if type(t[n]) ~= 'string' then
			std.err("Wrong verb pattern in mp:verb()", 2)
		end
		local verbs = self:pattern(mp.fmt(t[n]), ",")
		if extend then
			for _, v in ipairs(verbs) do
				table.insert(verb.verb, v)
			end
		else
			verb.verb = verbs
		end
		n = n + 1
		if not extend then
			verb.dsc = {}
		end
	end
	if type(t[n]) ~= 'string' then
		if t[n] or not extend_words then
			std.err("Wrong verb descriptor mp:verb()", 2)
		end
	end
	while type(t[n]) == 'string' do
		local dsc = str_split(t[n], ":")
		local pat
		if #dsc == 1 then
			table.insert(verb.dsc, { pat = {}, ev = dsc[1] })
		elseif #dsc == 2 then
			pat = str_split(dsc[1], ' ')
			if pat[1] == '~' then
				table.remove(pat, 1)
				for k, v in ipairs(pat) do
					pat[k] = v:gsub("[^ |]+", function(s) return "~" .. s end)
				end
			end
			table.insert(verb.dsc, { pat = pat, ev = dsc[2] })
		else
			std.err("Wrong verb descriptor: " .. t[n])
		end
		n = n + 1
	end
	verb.hint = t.hint
	table.insert(w.__Verbs, 1, verb)
	return verb
end

function mp:verbs()
	local w = std.here().__Verbs or std.me().__Verbs or game.__Verbs or {}
	local t = {}
	for _, v in ipairs(w) do
		table.insert(t, v)
	end
	for _, v in ipairs(mp.__Verbs or {}) do
		table.insert(t, v)
	end
	return t
end

local function word_search(t, w, lev)
	local rlev
	w = str_split(w, mp.inp_delim)
	for k = 1, #t - #w + 1 do
		local found = true
		for i = 1, #w do
			local found2 = false
			for ii = k, k + #w - 1 do
				if type(lev) == 'function' then
					rlev = lev(w[i], t[ii])
				else
					rlev = mp:eq(w[i], t[ii], lev)
				end
				if rlev then
					found2 = true
					break
				end
			end
			if not found2 then
				found = false
				break
			end
		end
		if found then
			return k, #w, rlev
		end
	end
end

function mp:lookup_short(words, w)
	local ret = { }
	for _,v in ipairs(words) do
		if self:__startswith(v, w) then
			table.insert(ret, { i = _, w = v, pos = #ret })
		end
	end
	table.sort(ret, function(a, b)
		if a.w:len() == b.w:len() then return a.pos < b.pos end
		return a.w:len() < b.w:len()
	end)
	if #ret == 0 then return end
	return ret[1].i, 1
end

--- Return false if unparsed word is critical in parse sense
-- @param w table with skipped words
function mp:skip_filter()
	return true
end

function mp:ignore_filter(w)
	return false
end

function mp:verb_filter(words)
	return true
end

function mp:lookup_verb(words, lev)
	local ret = {}
	local w = self:verbs()
	for _, v in ipairs(w) do -- verbs
		local lev_v = {}
		for _, vv in ipairs(v.verb) do
			local verb = vv.word .. (vv.morph or "")
			local i, len, rlev
			local vwords = mp.strict_mode and { words[1] } or words
			i, len, rlev = word_search(vwords, verb, lev and self.lev_thresh)
			if not i and not lev and vv.morph then
				i, len = self:lookup_short(vwords, vv.word)
				if i then
					local v = {}
					for k = i, i + len - 1 do
						table.insert(v, words[k])
					end
					if verb:find(table.concat(v, ' '), 1, true) ~= 1 and
						not self:verb_filter(v) then
						i = false
					end
				end
			end
			if i and i > 1 and not self:skip_filter({words[i - 1]}) then
				i = nil
			end
			if i then
				if lev then
					table.insert(lev_v, { lev = rlev, verb = v, verb_nr = i, verb_len = len, word_nr = _ } )
				else
					local vc = std.clone(v)
					vc.verb_nr = i
					vc.verb_len = len
					vc.word_nr = _
					table.insert(ret, vc)
				end
			end
		end
		if lev and #lev_v > 0 then
			table.sort(lev_v, function(a, b)
					   if a.lev == b.lev then return a.word_nr < b.word_nr end
					   return a.lev < b.lev
			end)
			lev_v[1].verb.verb_nr = lev_v[1].verb_nr
			lev_v[1].verb.verb_len = lev_v[1].verb_len
			lev_v[1].verb.word_nr = lev_v[1].word_nr
			lev_v[1].verb.lev = lev_v[1].lev
			table.insert(ret, lev_v[1].verb)
		end
	end
	if lev then
		table.sort(ret, function(a, b)
				   if a.lev == b.lev then return a.word_nr < b.word_nr end
				   return a.lev < b.lev
		end)
	elseif #ret > 0 then
		table.sort(ret, function(a, b)
			if a.verb_nr == b.verb_nr then return a.word_nr < b.word_nr end
			return a.verb_nr < b.verb_nr
		end)
		local vlev = ret[1].verb_nr
		local ret2 = {}
		for _, v in ipairs(ret) do
			if v.verb_nr == vlev then
				table.insert(ret2, v)
			else
				break
			end
		end
		ret = ret2
	end
	return ret
end

local function tab_sub(t, s, e)
	local r = {}
	e = e or #t
	for i = s, e do
		table.insert(r, t[i])
	end
	return r
end

--[[
local function tab_exclude(t, s, e)
	local r = {}
	e = e or #t
	for i = 1, #t do
		if i < s or i > e then
			table.insert(r, t[i])
		end
	end
	return r
end
]]--

function mp:docompl(str, maxw)
	local full
	local force = maxw
	local inp, pre = self:compl_ctx()
	if mp.utf.len(pre) < self.compl_thresh then
		return str
	end
	if not maxw then
		full = false
		local compl = self:compl(str)
		for _, v in ipairs(compl) do
			if not maxw then
				full = true
				maxw = v.word
			else
				local maxw2 = ''
				local utf_word = utf_chars(v.word)
				local utf_maxw = utf_chars(maxw)
				for k = 1, #utf_maxw do
					if mrd.lang.norm(utf_maxw[k]) == mrd.lang.norm(utf_word[k]) then
						maxw2 = maxw2 .. utf_maxw[k]
					else
						full = false
						break
					end
				end
				maxw = maxw2
			end
		end
		if full then
			if #compl > 1 then full = false end
		end
	else
		full = true
	end
	if maxw and maxw ~= '' then
		str = inp .. maxw
	end
	if force or full then
		str = str .. ' '
	end
	return str
end

function mp:__startswith(w, v)
	return w:find(v, 1, true) == 1
end

function mp:startswith(w, v)
	return (self:norm(w)):find(self:norm(v), 1, true) == 1
end

function mp:hint_verbs(v)
	if not v.tag then return true end
	if type(v.hint) == 'function' then
		return v:hint()
	end
	local r = true

	if std.here().hint_verbs_only then
		r = false
		for _, vv in ipairs(std.here().hint_verbs_only) do
			if v.tag == vv then
				r = true
				break
			end
		end
		return r
	end

	if game.hint_verbs then
		r = false
		for _, vv in ipairs(game.hint_verbs) do
			if v.tag == vv then
				r = true
				break
			end
		end
	end
	if r then return r end
	if std.here().hint_verbs then
		for _, vv in ipairs(std.here().hint_verbs) do
			if v.tag == vv then
				r = true
				break
			end
		end
	end
	return r
end
function mp:compl_verb(_)
	local poss = {}
	for _, v in ipairs(self:verbs()) do
		local filter = not self:hint_verbs(v)
		for _, vv in ipairs(v.verb) do
			local verb = vv.word .. (vv.morph or "")
			table.insert(poss, { word = verb, hidden = (_ ~= 1) or vv.hidden or filter})
		end
	end
	return poss
end

function mp:animate(w)
	if w:has'animate' == false then
		return false
	end
	return w:has'animate' or (self.auto_animate and w:hint'live')
end

local function holded_by(ob, holder)
	if not holder then
		return true
	end
	local h = holder.ob
	if not h then return false end
	if ob:where() == h then return true end
	for _, hm in ipairs(holder.multi or {}) do
		if ob:where() == hm then
			return true
		end
	end
	return false
end

local function multi_held(ob, attrs)
	if not attrs.held and not attrs.scene then
		return true
	end
	if ((attrs.held and have(ob)) or
		(attrs.scene and not have(ob))) then
		return true
	end
	return false
end

local function multi_select(vv, attrs, holder)
	local res = {}
	local ob = vv.ob
	if holded_by(ob, holder) and multi_held(ob, attrs) then
		table.insert(res, ob)
	end
	for _, h in ipairs(vv.multi or {}) do
		if holded_by(h, holder) then
			ob = h
			if multi_held(ob, attrs) then
				table.insert(res, ob)
			end
		end
	end
	local dist = -1;
	ob = res[1]
	for _, v in ipairs(res) do
		local d = mp:distance(v)
		if d < dist or dist == -1 then
			ob = v
			dist = d
		end
	end
	return ob or vv.ob, res
end

function mp:compl_filter(v)
	local hidden = v.hidden
	if not hidden and v.ob and v.ob.hint_noun ~= nil then
		if type(v.ob.hint_noun) == 'function' then
			hidden = not v.ob:hint_noun(v)
		else
			hidden = not v.ob.hint_noun
		end
	end
	local _, pre = self:compl_ctx()
	local nsym = mp.utf.len(pre)
	if hidden and self.compl_thresh == 0 and nsym == 0 then
		return false
	end
	if nsym < self.compl_thresh then
		return false
	end
	if not v.ob or not v.morph then
		return true
	end
	local attrs = {
		held = false;
		scene = false;
		container = false;
		inside = false;
		enterable = false;
		edible = false;
		supporter = false;
		live = false,
		compass = false,
	}
	for _, h in ipairs(str_split(v.morph, ",")) do
		if attrs[h] ~= nil then attrs[h] = h end
	end
	for _, a in ipairs { 'container', 'enterable', 'supporter', 'edible' } do
		if attrs[a] and not v.ob:has(a) then return false end
	end
	if v.ob and mp:compass_dir(v.ob) and not attrs.compass then
		return false
	end
	if attrs.live and not self:animate(v.ob) then return false end
	if attrs.inside and not v.ob:has'container' and not v.ob:has'supporter' then return false end
	if not attrs.held and not attrs.scene then return true end
	if attrs.held and have(multi_select(v, attrs)) then return true end
	if attrs.scene and (not have(multi_select(v, attrs)) and v.ob ~= std.me()) then return true end
	return false
end

function mp:compl_fill(compl, eol, vargs)
	local ctx = self.completions.ctx
	self.completions = {}
	self.completions.ctx = ctx
	self.completions.eol = eol
	self.completions.vargs = vargs
	for _, v in ipairs(compl) do
		if self:compl_filter(v) then
			table.insert(self.completions, v)
		end
	end
end

function mp:compl_reset()
	self.completions = { ctx = {} }
end

function mp:compl_ctx_current()
	local ctx = self.completions.ctx
	local new = {}
	for _, v in ipairs(ctx) do
		if v.inp == '' and self.inp == '' then break end
		if self:startswith(self.inp, v.inp) then
			table.insert(new, v)
		else
			break
		end
	end
	self.completions.ctx = new
end

function mp:compl_ctx_push(poss)
	if #poss == 0 then
		return
	end
	local ctx = self.completions.ctx
	table.insert(ctx, poss)
	local top = #ctx
	ctx[top].inp = self.inp
end

function mp:compl_ctx()
	local ctx = self.completions.ctx
	local top = #ctx
	if top == 0 then
		return self.inp, ''
	end
	local inp = self.inp
	local ctx_inp = ctx[top].inp
	local _, e = inp:find(ctx_inp, 1, true)
	local pre = ''
	if e then
		pre = inp:sub(e + 1)
	end
	return ctx[top].inp, pre
end

function mp:compl_ctx_poss()
	local ctx = self.completions.ctx
	local top = #ctx
	local res = {}
	if top == 0 then
		return res
	end
	ctx = ctx[top]
	local _, pre = self:compl_ctx()
	for _, v in ipairs(ctx) do
		if self:__startswith(v.word, pre) or
			self:__startswith(self:norm(v.word), pre) then
			table.insert(res, v)
		end
	end
	res.eol = ctx.eol
	return res
end

function mp:compl(str)
	local words = str_split(self:norm(str), mp.inp_delim)
	local poss
	local ret = {}
	local dups = {}
	local eol
	local e = str:find(" $")
	local vargs
	collectgarbage("stop")
	self:compl_ctx_current();
	poss = self:compl_ctx_poss()
	eol = poss.eol
	if (#poss == 0 and e) or #words == 0 then -- no context
		if #words == 0 or (#words == 1 and not e) then -- verb?
			poss, eol = self:compl_verb(words)
			local oo = self:nouns() -- and hidden nouns
			for _, o in ipairs(oo) do
				local ww = {}
				o:noun(ww)
				for _, n in ipairs(ww) do
					local hidden = true
					if o.raw_word then hidden = n.alias ~= 1 and not o:has'multi' end
					table.insert(poss, { word = n.word, hidden = hidden })
				end
			end
		else -- matches
			self.cache.nouns = self:nouns()
			poss, eol = self:compl_match(words)
		end
		poss.eol = eol
		self:compl_ctx_push(poss)
	end
	local _, pre = self:compl_ctx()
	for _, v in ipairs(poss) do
		if v.word == '*' and not v.hidden then
			vargs = true
		end
		if self:startswith(v.word, pre) and not v.word:find("%*$") then
			if not dups[v.word] then
				dups[v.word] = v
				table.insert(ret, v)
			else
				local o = dups[v.word]
				if o.hidden then
					o.hidden = v.hidden
				end
				if v.ob then
					if o.ob then
						o.multi = o.multi or {}
						table.insert(o.multi, v.ob)
					else
						o.ob = v.ob
					end
				end
			end
		end
	end
	table.sort(ret, function(a, b)
			   return a.word < b.word
	end)
	collectgarbage("restart")
	return ret, eol, vargs
end

local function lev_sort(t)
	for _, v in ipairs(t) do v.i = _ end
	table.sort(t, function(a, b)
			if a.lev == b.lev then
				return a.i < b.i
			end
			return a.lev > b.lev
	end)
	local lev = t[1] and t[1].lev
--	local fuzzy = t[1] and t[1].fuzzy

	local fuzzy = {}
	for _, v in ipairs(t) do if v.lev ~= lev then break end if v.fuzzy then table.insert(fuzzy, v) end end
	if #fuzzy > 0 then
		t = fuzzy
		t.fuzzy = true
	end

	local res = { lev = 0, match = #t > 0 and t[1].match }
	local dup = {}

	for _, v in ipairs(t) do
		if v.lev ~= lev then
			break
		end
		res.lev = lev
		if v.word then
			if not dup[v.word] then
				table.insert(res, v.word)
				dup[v.word] = true
			end
		else
			for _, vv in ipairs(v) do
				if not dup[vv] then
					table.insert(res, vv)
					dup[vv] = true
				end
			end
		end
	end
	return res
end

function mp:compl_match(words)
--	local verb = { words[1] }
	local verbs = self:lookup_verb(words)
--	table.remove(words, 1) -- remove verb
	local matches = {}
	local hints = {}
	local res = {}
	local multi
	collectgarbage("stop")
	for _, v in ipairs(verbs) do
		local m, h, _, mu = self:match(v, words, true)
		if #m > 0 then
			table.insert(matches, { verb = v, match = m[1] })
		end
		if #h > 0 then
			table.insert(hints, h)
		end
		multi = multi or (#mu > 0)
	end
	collectgarbage("restart")
	hints = lev_sort(hints)
	if multi then -- #matches > 0 or #hints == 0 or multi then
		return res
	end
	for _, v in ipairs(hints) do
		if #matches > 0 and #matches[1].match > hints.lev then
			return res, false, not not matches[1].match.vargs
		end
		local pat = self:pattern(v)
		for _, p in ipairs(pat) do
			table.insert(res, p)
		end
	end
	if #hints == 0 and #matches > 0 then
		return res, true, not not matches[1].match.vargs
	end
	return res, #matches > 0
end


function mp:match(verb, w, compl)
	local matches = {}
	local found
	local hints = {}
	local unknown = {}
	local multi = {}
	local parsed_verb = {}
	local fixed_verb = verb.verb[verb.word_nr]
	fixed_verb = fixed_verb.word .. (fixed_verb.morph or '')
	table.insert(parsed_verb, fixed_verb)
	for _, d in ipairs(verb.dsc) do -- verb variants
--		local was_noun = false
		local match = { args = {}, vargs = {}, skip = 0, ev = d.ev, wildcards = 0, verb = parsed_verb, defaults = 0 }
		local a = {}
		found = (#d.pat == 0)
		for k, v in ipairs(w) do
			if k < verb.verb_nr or k >= verb.verb_nr + verb.verb_len then
				table.insert(a, v)
			end
		end
		local skip = {}
		local all_optional = true
		local rlev = 1
		local need_required = false
		local default = false
		local vargs
		for lev, v in ipairs(d.pat) do -- pattern arguments
			if v == '*' or v == '~*' then
				vargs = v -- found
				v = '*'
			end
			local noun = not not v:find("^~?{noun}")
			local pat = self:pattern(v) -- pat -- possible words
			local best = #a + 1
			local best_len = 1
			local word
			local required = false
			found = false
			local wildcard = false
			for _, pp in ipairs(pat) do -- single argument
				if v == '*' then break end
				required = not pp.optional
				if not pp.optional then
					need_required = true
					all_optional = false
				end
				default = pp.default
				if default then
					word = pp.word
				end
				local new_wildcard
				local k, len = word_search(a, pp.word)
				if not k and mp.compare_len > 0 and not pp.synonym then
					k, len = word_search(a, pp.word, starteq)
					new_wildcard = true
				else
					new_wildcard = false
				end
				if (not required or mp.strict_mode) and k ~= 1 then k = false end -- ?word is only in 1st pos
				if k and ((k < best or (k == best and len > best_len)) or
					(not new_wildcard and wildcard and k <= best and len >= best_len)) then
					wildcard = new_wildcard
					best = k
					word = pp.word
					found = pp
					best_len = len
					if pp.synonym or word:find("%*$") then -- subst
						word = found.ob:noun(found.morph, found.alias)
						wildcard = true
					end
				end
			end
			if found then
				need_required = false
				if found.ob then
					local exact
					for _, pp in ipairs(pat) do
						if pp.ob and pp.ob ~= found.ob and self:eq(found.word, pp.word) then
							if not found.multi then
								found.multi = {}
							end
							if not exact and pp.ob:noun(found.morph, pp.alias) == pp.word then -- excactly match
								exact = pp.ob
								table.insert(found.multi, found.ob)
							else
								table.insert(found.multi, pp.ob)
							end
							if found.ob:noun(found.alias) ~= pp.ob:noun(pp.alias) then
								table.insert(multi, { word = pp.ob:noun(pp.alias), lev = rlev })
							end
						end
					end
					if exact then
						found = std.clone(found)
						found.ob = exact
						multi = {}
					end
					if #multi > 0 and found.multi then
						table.insert(multi, 1, { word = found.ob:noun(found.alias), lev = rlev })
						found = false
						break
					end
				end
				if vargs then
					for i = 1, best - 1 do
						table.insert(match.vargs, a[i])
						table.insert(match, a[i])
					end
					if #match.vargs == 0 then -- * in the pattern center
						found = false
						break
					end
					rlev = rlev + 1
				end
				if (wildcard or match.wildcards > 0) and best > 1 then -- do not skip words if wildcard used
					found = false
					vargs = false
					break
				end
--				if false then
--					a = tab_exclude(a, best, best + best_len - 1)
--				else
--				if not was_noun then
				if not vargs then
					match.skip = match.skip + (best - 1)
					for i = 1, best - 1 do
						table.insert(skip, a[i])
					end
				end
--				end
					a = tab_sub(a, best + best_len)
--					table.remove(a, 1)
--				end
				vargs = false
				table.insert(match, word)
				table.insert(match.args, found)
				if wildcard then
					match.wildcards = match.wildcards + 1
				end
				rlev = rlev + 1
--				was_noun = not not found.ob
			elseif vargs then
				if lev == #d.pat then -- last?
					if #a == 0 then
						need_required = true
					end
					while #a > 0 do
						table.insert(match.vargs, a[1])
						table.insert(match, a[1])
						table.remove(a, 1)
					end
				else
					need_required = need_required or required
				end
				if not need_required then
					found = true
				else
					found = false
					if #a > 0 or #match.vargs > 0 then
						while #a > 0 do
							table.insert(match.vargs, a[1])
							table.insert(match, a[1])
							table.remove(a, 1)
						end
						table.insert(hints, { word = v, lev = rlev, match = match })
					else
						table.insert(hints, { word = vargs, lev = rlev, match = match })
					end
				end
				if not found then
					break
				end
			elseif required then
				for i = 1, best - 1 do
					table.insert(unknown, { word = a[i], lev = rlev, noun = noun })
				end
				if best <= 1 and #skip > 0 then
					for i = 1, #skip do
						table.insert(unknown, { word = skip[i], lev = rlev, skip = true })
					end
				end
				if not compl and mp.errhints then
					local objs = {}
					for _, pp in ipairs(pat) do -- single argument
						if not pp.synonym and not objs[pp.ob or 0] then
							local k, _ = word_search(a, pp.word, self.lev_thresh)
							if k then
								table.insert(hints, { word = pp.word, lev = rlev, fuzzy = true, match = match })
								objs[pp.ob or 1] = true
							end
						end
					end
				end
				table.insert(hints, { word = v, lev = rlev, match = match })
				break
			else
				if word then
					table.insert(match, word)
					if default then
						match.defaults = match.defaults + 1
					end
				end
				if default then
					table.insert(match.args, { word = word, default = true } )
				else
					table.insert(match.args, { word = false, optional = true } )
				end
--				table.insert(hints, { word = v, lev = rlev })
				found = true
			end
		end
--		if #multi > 0 then
--			matches = {}
--			break
--		end
		if found or all_optional then
			match.extra = (#a ~= 0)
			if not match.extra or match.wildcards == 0 then
				table.insert(match, 1, fixed_verb) -- w[verb.verb_nr])
				if self:skip_filter(skip) then
					table.insert(matches, match)
				end
				if #match.vargs == 0 and not vargs then
					match.vargs = false
				end
			end
		end
	end

	for k, v in ipairs(matches) do
		v.nr = k
--[[
if false then
		print("-----------", k)
		for kk, vv in ipairs(v) do
			print(vv)
		end
end
]]--
	end

	table.sort(matches,
		function(a, b)
			local na, nb = #a - a.defaults, #b - b.defaults
			if not a.extra and a.skip == 0 then
				na = na + 100
			end
			if not b.extra and b.skip == 0 then
				nb = nb + 100
			end
			if na == nb and a.wildcards == b.wildcards then
				return a.nr < b.nr
			end
			if na == nb then
				return a.wildcards < b.wildcards
			end
			return na > nb
		end)

	if #matches > 0 and matches[1].extra then
		local lev = #matches[1]
		if #unknown > 0 then
			for _, v in ipairs(unknown) do
				if v.lev >= lev and not v.skip then -- and v.noun then
					matches = {}
					break
				end
			end
		end
		if #multi > 0 and #matches > 0 then
			for _, v in ipairs(multi) do
				if v.lev >= lev and not v.skip then
					matches = {}
					break
				end
			end
		end
	end
--[[
	if #unknown > 0 then
		local nmatches = {}
		for _, v in ipairs(matches) do
			if not v.extra then
				table.insert(nmatches, v)
			end
		end
		matches = nmatches
	end
end
if false then
	print "MATCHES: "
	for _, v in ipairs(matches) do
		for _, vv in pairs(v) do
			print(_, vv)
		end
	end

--	for _, v in ipairs(hints) do
--		for _, vv in ipairs(hints) do
--			print(vv.word, vv.fuzzy, vv.lev)
--		end
--	end
end
]]--
	hints = lev_sort(hints)
	unknown = lev_sort(unknown)
	multi = lev_sort(multi)
	if #hints > 0 and #unknown > 0 then
		if hints.lev > unknown.lev then
			unknown = {}
		elseif hints.lev < unknown.lev then
			hints = {}
		end
	end
	return matches, hints, unknown, multi
end

local function get_events(self, ev)
	local events = {}
	self.aliases = {}
--	self.first_it = false
--	self.second_it = false
	self.multi = {}
	for _, v in ipairs(ev) do
		local ea = str_split(v)
		local e = ea[1]
		local args = {}
		table.remove(ea, 1)
		local reverse = false
		for _, vv in ipairs(ea) do
			if vv == 'reverse' then
				reverse = true
			end
		end
		local attrs = {}
		local holder
		for k, vv in ipairs(self.args) do
			if vv and std.is_obj(vv.ob) then
				attrs[k] = {}
				for _, h in ipairs(str_split(vv.morph, ",")) do
					attrs[k][h] = true
					if h == 'holder' then
						holder = vv
					end
				end
			end
		end

		for k, vv in ipairs(self.args) do
			if vv and std.is_obj(vv.ob) then
				local ob, m = multi_select(vv, attrs[k], holder)
				self.multi[ob] = m
				if reverse then
					table.insert(args, 1, ob)
				else
					table.insert(args, ob)
				end
				self.aliases[ob] = vv.alias
			end
		end

		if self.vargs and #self.vargs > 0 then
			local varg = ''
			for _, vv in ipairs(self.vargs) do
				if varg ~= '' then varg = varg .. ' ' end
				varg = varg .. vv
			end
			table.insert(args, varg)
		end
		if std.is_obj(args[1]) then
			self.first_it = args[1]
		end
		if std.is_obj(args[2]) then
			self.second_it = args[2]
		end
		table.insert(events, { ev = e, args = args })
	end
	return events
end

--- Take a value or run the function
--- returns two valuses. retval and true if method was called
-- @param wh what
-- @param fn function
function mp:runorval(wh, fn, ...)
	if wh[fn] == nil then
		return nil, false
	end
	if type(wh[fn]) == 'function' then
		local v
		local r = wh[fn](wh, ...)
		if r == false then v = false else v = true end
		return r, v
	end
	return wh[fn], true
end

function mp:call(ob, ev, ...)
--	self.event = ev
	for _, v in ipairs({ob, ...}) do
		if self.aliases[v] then
			std.rawset(v, '__word_alias', self.aliases[v])
		end
	end

--	self.reaction = std.pget() or false
	local r, v = std.call(ob, ev, ...)
--	std.cctx().txt = self.reaction
	self.reaction = self.reaction or v or false

	if self.debug.trace_action and v then
		dprint("mp:call ", ob, ev, ...)
		p("mp:call ", ob, " ", ev, " ")
		for _, t in ipairs {...} do
			pr (tostring(t), " ")
		end
		pn()
	end
	for _, a in ipairs(self.aliases) do
		std.rawset(a, '__word_alias', nil)
	end
	return r, v
end

function mp:events_call(events, oo, t)
	if not t then t = '' else t = t .. '_' end
	for _, o in ipairs(oo) do
		for _, e in ipairs(events) do
			self.event = e.ev
			local meta = self.event and self.event:find("Meta", 1, true)
			local ename = t .. e.ev
			local eany = t .. 'Any'
			local edef = t .. 'Default'
			local ob = o
			self.first = std.is_obj(e.args[1]) and e.args[1]
			self.second = std.is_obj(e.args[2]) and e.args[2]
			self.first_hint = self.first and self.first:gram().hint
			self.second_hint = self.second and self.second:gram().hint
			if o == 'obj' then
				ob = e.args[1]
				table.remove(e.args, 1)
			end
			local r, v
			if (meta and o == mp) or (not meta and std.is_obj(ob) and (o ~= 'obj' or ob ~= std.here())) then
				r, v = self:call(ob, eany, e.ev, std.unpack(e.args))
				if r then std.pn(r) end
				if not v then
					if ob[ename] then
						r, v = self:call(ob, ename, std.unpack(e.args))
						if r then std.pn(r) end
					else
						r, v = self:call(ob, edef, e.ev, std.unpack(e.args))
						if r then std.pn(r) end
					end
				end
			end
			if r then
				pn()
			end
			if o == 'obj' then
				table.insert(e.args, 1, ob)
			end
			if v and t ~= 'post_' then return v end
		end
	end
	return false
end

function mp:__action(events)
	local r
	self.reaction = false
	self.redirect = false
	r = self:events_call(events, { mp, game, std.here(), 'obj' }, 'before')
	if not r then
		r = self:events_call(events, { 'obj', std.here(), game, mp })
		if not r then
			self:events_call(events, { 'obj', std.here(), game, mp }, 'after')
		end
	end
	if not self.redirect then
		self:events_call(events, { 'obj', std.here(), game, mp }, 'post')
	end
end

function mp:save_ctx()
	return {
		first = self.first,
		second = self.second,
		first_hint = self.first_hint,
		second_hint = self.second_hint,
		event = self.event;
		xevent = self.xevent
	}
end

function mp:restore_ctx(ctx)
	self.first, self.second = ctx.first, ctx.second
	self.first_hint, self.second_hint = ctx.first_hint, ctx.second_hint
	self.event = ctx.event
	self.xevent = ctx.xevent
end

--- Execute a method
-- @usage mp:runmethods('before', 'LetGo', wh, w)
function mp:runmethods(t, verb, ...)
	local events = { {ev = verb, args = { ... }}}
	local ctx = self:save_ctx()
	self.xevent = self.event
	local r, v = self:events_call(events, { 'obj' }, t)
	self:restore_ctx(ctx)
	self.reaction = false
	return r, v
end

--- Execute a new sequence without terminating the current one
function mp:subaction(verb, ...)
	local events = { {ev = verb, args = { ... }}}
	local ctx = self:save_ctx()
	self.xevent = self.event
	local r, v = self:__action(events)
	self:restore_ctx(ctx)
	self.reaction = false
	return r, v
end

--- Switch the sequence to a new event
function mp:xaction(verb, ...)
	local events = { {ev = verb, args = { ... }}}
	local r, v = self:__action(events)
	self.redirect = true
	return r, v
end

function mp:action()
	local parsed = self.parsed
	local ev = str_split(parsed.ev, "|")
	local events = get_events(self, ev)
	self:__action(events)
end

function mp:correct(inp)
	if self:comment() then
		return
	end

	local rinp = ''

	for _, v in ipairs(self.parsed) do
		if rinp ~= '' then rinp = rinp .. ' ' end
		rinp = rinp .. v
	end
	local strip_inp = str_split(inp, mp.inp_delim)
	inp = ''
	for _, v in ipairs(strip_inp) do
		if not mp:ignore_filter(v) then
			if inp ~= '' then inp = inp .. ' ' end
			inp = inp .. v
		end
	end
	local cmprinp = rinp:gsub("["..mp.inp_delim.."]+", " ")
	if not self:eq(cmprinp, inp) then
		pn(fmt.em("("..rinp..")"))
	end
end

function mp:log(t)
	if mp.logfile then
		t = std.fmt(t)
		local f = io.open(mp.logfile, "a+b")
		if not f then return end
		f:write((t or '').."\n\n")
		f:close()
	end
end

function mp:show_prompt(inp)
	if std.cmd[1] == 'look' then
		return false
	end
	if std.here():has 'cutscene' or std.here():has 'noprompt' then
		return false
	end
	if self.prompt then
		pn(fmt.b(self.prompt .. inp))
	end
	return true
end

function mp:comment()
	if self.inp:find("^[ \t]*%*") then return true end
end

--- Main parse function. Input goes here
function mp:parse(inp)
	inp = std.strip(inp)

	if self.expert_mode and not self:comment() and not std.here():type'dlg' then
		local multi_inp = str_split(inp, ".\r\n") or {}

		inp = multi_inp[1] or inp

		for i = 2, #multi_inp do
			self:push(multi_inp[i])
		end
	end

	mp:log("> "..inp)

	local prompt = mp:show_prompt(inp)

	inp = inp:gsub("[ ]+", " "):gsub("["..mp.inp_delim.."]+", " "):gsub("[ \t]+$", "")

	local r, v

	if self:comment() then
		r = false
		v = nil
	else
		self.cache.nouns = self:nouns()
		r, v = self:input(self:norm(inp))
	end
	self.cache = { tokens = {} }; -- to completion
	if not r then
		if v then
--			pn()
			self:err(v)
			local s = std.game
			s:reaction(std.pget())
			r = s:display(false)
			s:lastdisp(r)
			std.abort_cmd = true
			return r
		end
	else
		if std.cmd[1] ~= 'look' and prompt ~= false then
			self:correct(inp)
		end
		-- here we do action
		mp:action()
	end
	mp:post_action()
end

std.world.display = function(s, state)
	local l, av, pv, first
	if not mp.started and mp.text == '' and game:time() == 1 and state ~= false then
		local r = std.call(game, 'dsc')
		if type(r) == 'string' then
			first = true
			if mp._pager_mode then
				mp.text = fmt.anchor() .. r .. '^^' -- .. fmt.anchor()
			else
				mp.text = r .. '^^'
			end
		end
		mp.started = true
	end
	if mp.clear_on_move and game:time() ~= 1 then
		if player_moved() then mp:clear() end
	end
--	mp:trim()
	local reaction = s:reaction() or nil
	if reaction == "" then reaction = nil end
	if state then
--		reaction = iface:em(reaction)
		av, pv = s:events()
		av = iface:em(av)
		pv = iface:em(pv)
		if s.player:need_scene() then
--			t = iface:bold(std.titleof(stead.here()))
			l = s.player:look() -- objects [and scene]
		end
	end
	l = std.par(std.scene_delim, reaction or false,
		    av or false, l or false,
		    pv or false) or ''
	if l ~= '' then
		mp:log(l)
	end
	if mp._pager_mode and not first then
		mp.text = mp.text ..  fmt.anchor() .. l .. '^^' -- .. fmt.anchor()
	else
		mp.text = mp.text ..  l .. '^^' -- .. fmt.anchor()
	end
	return mp.text
end

function mp:pager_mode(mode)
	self._pager_mode = not not mode
	if std.ref'@theme' then
		std.ref'@theme'.set ('win.scroll.mode', mode and 1 or 3)
	end
end

function mp:completion(word)
	self.inp = self:docompl(self.inp, word)
	self.cur = self.inp:len() + 1
	self:compl_fill(self:compl(self.inp))
end

function mp:key_history_prev()
	if #self.history == 0 then
		return
	end
	self.history_pos = self.history_pos + 1
	if self.history_pos > #self.history then
		self.history_pos = #self.history
	end
	self.inp = self.history[self.history_pos]
	self.cur = self.inp:len() + 1
	return true
end

function mp:key_history_next()
	if #self.history == 0 then
		return
	end
	self.history_pos = self.history_pos - 1
	if self.history_pos < 1 then
		self.history_pos = 0
		self.inp = ''
		self.cur = 1
		return true
	end
	self.inp = self.history[self.history_pos]
	self.cur = self.inp:len() + 1
	return true
end

--- Add input string to auto execution mode
-- @param cmd input string
function mp:push(cmd)
	if not cmd then
		return false
	end
	table.insert(self.pushed, cmd)
end

--- Returns true if some auto command is pending
function mp:autoplay_pending()
	return self.autoplay or #self.pushed > 0 or self.autoplay_command
end

--- Internal function that gets commands from script or pushed commands
-- @see mp:push
function mp:autoplay_inp()
	local auto_inp = false
	self.autoplay_command = false
	if #self.pushed > 0 then
		auto_inp = table.remove(self.pushed, 1)
	elseif not self.autoplay then
		return false
	end
	self.inp = auto_inp or self.autoplay:read("*line") or false
	if not self.inp then
		self.inp = ''
		self.autoplay:close()
		self.autoplay = false
	else
		if not auto_inp then
			dprint("> ", self.inp)
		end
		self.autoplay_command = true
	end
	return true
end

function mp:key_enter()
	if self:noparser() then
		return
	end
	if not mp:autoplay_pending() and
		(#self.history == 0 or self.history[1] ~= self.inp) and std.strip(self.inp) ~= '' then
		table.insert(self.history, 1, self.inp)
	end
	self.history_pos = 0
	if #self.history > self.history_len then
		table.remove(self.history, #self.history)
	end
	self:compl_reset();
	local r, v = std.call(mp, 'parse', self.inp)
	self.inp = '';
--[[
	if std.here():has'cutscene' then
		self.inp = mp.cutscene.default_Verb or ''
		if self.inp ~= '' then
			self.inp = self.inp .. ' '
		end
	end
]]--
	self:autoplay_inp()

	self.cur = self.inp:len() + 1;
	mp:post_inp()
--	self:completion()
	return r, v
end

function mp:lookup_noun(w, lev)
	local k, len
	local res = {}
	local oo = self.cache.nouns
	for _, o in ipairs(oo) do
		local ww = {}
		o:noun(ww)
		for _, d in ipairs(ww) do
			k, len = word_search(w, d.word, lev)
			if k and len == #w then
				d.ob = o
				table.insert(res, d)
				break
			end
		end
	end
	if #res == 0 then
		return res
	end
	local uniq = {}
	local same
	for _, v in ipairs(res) do
		local t = v.ob:noun(v.alias)
		if not uniq[t] then
			uniq[t] = v
		else
			same = true
		end
	end
	res = {}
	for _, v in pairs(uniq) do
		table.insert(res, v)
	end
	table.sort(res, function(a, b)
		return a.word:len() > b.word:len()
	end)
	if same then
		res = { res[1] }
	end
	self.aliases = {}
	for _, o in ipairs(res) do
		self.aliases[o.ob] = o.alias
	end
	return res
end

function mp:shorten_input(w)
	if #w < 1 or std.here():type 'dlg' then
		return
	end
	local str
	if #w == 1 and self.shorten[w[1]] then
		str = self.shorten[w[1]]
	end
	if self.expert_mode and not str and
		self.shorten_expert[w[1]] then
		str = self.shorten_expert[w[1]]
	end
	if not str then
		return
	end
	local t = str_split(str, mp.inp_delim)
	table.remove(w, 1)
	for i, v in ipairs(t) do
		table.insert(w, i, v)
	end
end

function mp:strip_input(w)
	local i = 1
	local len = #w
	while i < len do
		if mp:ignore_filter(w[i]) then
			table.remove(w, i)
			len = len - 1
		else
			i = i + 1
		end
	end
end

function mp:input(str)
--	self.cache = { tokens = {} };
	local hints = {}
	local unknown = {}
	local multi = {}
	self.hints = hints
	self.unknown = unknown
	self.multi = multi

	if (self.default_Verb or std.here().default_Verb) and str == "" then
		str = std.here().default_Verb or self.default_Verb
	end
	if type(mp.pre_input) == 'function' then
		str = mp:pre_input(str)
		if not str then return false end
	end
	local w = str_split(str, mp.inp_delim)
	mp:strip_input(w)
	mp:shorten_input(w)
	self.words = w
	if #w == 0 then
		return false, "EMPTY_INPUT"
	end
	local ob = self:lookup_noun(w)
	local verbs = {}
	if #ob == 0 then
		verbs = self:lookup_verb(w)
	end
	if #verbs == 0 then
		-- match object?
		if #ob > 1 then
			self.multi = {}
			for _, v in ipairs(ob) do
				table.insert(self.multi, v.ob:noun(v.alias))
			end
			return false, "MULTIPLE"
		end

		if #ob == 0 then -- try fuzzy
			if not mp.errhints then
				return false, "UNKNOWN_VERB"
			end
			ob = self:lookup_noun(w, self.lev_thresh)
			if #ob >= 1 then
				for _, v in ipairs(ob) do
					table.insert(self.hints, v.word)
				end
				return false, "UNKNOWN_WORD"
			end
			return false, "UNKNOWN_VERB"
		end

		-- it is the object!
		if ob[1].ob.default_Event then
			w = std.call(ob[1].ob, 'default_Event')
		else
			w = self.default_Event or "Exam"
		end
--		pn()
		mp.first_it = ob[1].ob
		self:xaction(w, ob[1].ob)
--		verbs = self:lookup_verb(w)
--		if #verbs == 0 then
--			return false, "UNKNOWN_VERB"
--		end
		return
	end
	local matches = {}
	for _, v in ipairs(verbs) do
		local m, h, u, mu = self:match(v, w)
		if #m > 0 then
			table.insert(matches, { verb = v, match = m[1] })
		end
		if #h > 0 then
			table.insert(hints, h)
		end
		if #u > 0 then
			table.insert(unknown, u)
		end
		if #mu > 0 then
			table.insert(multi, mu)
		end
	end
	table.sort(matches, function(a, b) return #a.match > #b.match end)
	hints = lev_sort(hints)
	unknown = lev_sort(unknown)
	multi = lev_sort(multi)
	local mlev = #matches > 0 and #matches[1].match or 0
	if (hints.lev or 0)> mlev or (unknown.lev or 0) > mlev then
		matches = {}
	end

	if #matches == 0 then
		self.hints = hints
		self.unknown = unknown
		self.multi = multi
		if #multi > 0 then
			self.multi = multi
			return false, "MULTIPLE"
		end
		return false, "INCOMPLETE"
	end
	self.parsed = matches[1].match
	self.args = self.parsed.args
	self.vargs = self.parsed.vargs or {}
	return true
end

function MetaVerb(t)
	return mp:verb(t, mp)
end

function Verb(t, w)
	return mp:verb(t, w)
end

function VerbExtend(t, w)
	return mp:verb(t, w or false, true)
end

function VerbExtendWord(t, w)
	return mp:verb(t, w or false, true, true)
end

function VerbRemove(t, w)
	return mp:verb_remove(t, w)
end

function VerbHint(t, fn, w)
	local v = mp:verb_find(t, w)
	if not v then
		dprint("Unknown verb: " .. tostring(t))
		return
	end
	if v then v.hint = fn end
end
std.rawset(_G, 'mp', mp)
std.mod_cmd(
function(cmd)
	if mp.snapshot then
		snapshots:write(mp.snapshot)
		mp.snapshot = false
	end
	if cmd[1] == '@metaparser' then
		mp.inp = cmd[2] or ''
		cmd[1] = '@mp_key'
		cmd[2] = 'enter'
	end
	if cmd[2] == '@metaparser' then
		if cmd[3] == '<clear>' then
			mp.inp = '';
			mp.cur = 1;
			mp:onedit()
			mp:compl_fill(mp:compl(mp.inp))
			return true, false
		elseif cmd[3] == '<enter>' then
			return mp:key_enter()
		end
		if cmd[3] == '<space>' then
			mp:inp_insert(' ')
			mp:onedit()
			mp:compl_fill(mp:compl(mp.inp))
			return true, false
		end
		if cmd[3] == '<backspace>' then
			mp:inp_remove()
			mp:onedit()
			mp:compl_fill(mp:compl(mp.inp))
			return true, false
		end
		if cmd[4] == 'letter' then
			mp.inp = mp.inp .. cmd[3]
			mp.cur = mp.inp:len() + 1
		else
			mp:completion(cmd[3])
		end
		mp:onedit()
		return true, false
	end
	if (cmd[1] == '@mp_key' and cmd[2] == 'enter') or cmd[1] == 'look' then
		mp:trim()
		if not std.game.__started and cmd[1] == 'look' then
			std.game:__start()
		end
		if mp:noparser() then
			return
		end
--		mp.inp = mp:docompl(mp.inp)
		local r, v, n
		repeat
			if n then
				std.busy(true)
				std.abort_cmd = false
				std.me():moved(false)
				std.me():need_scene(false)
			end
			r, v = mp:key_enter(cmd[1] == 'look')
			n = true
		until not mp:autoplay_pending() or mp:noparser()
		std.busy(false)
		mp:onedit()
		return r, v
	end
	if cmd[1] ~= '@mp_key' then
		return
	end
	mp:onedit()
	return true, false
end)

function mp:autoscript(w)
	if self.autoplay then
		self.autoplay:close()
	end
	self.autoplay = io.open(w or 'autoscript') or false
	if self.autoplay then
		-- self:MetaTranscriptOn();
		std.cmd = { 'autoscript' }
		return true
	end
	return false
end

std.mod_init(
function()
	if DEBUG and mp.undo == 0 then mp.undo = 5 end
	mp:pager_mode(true)
	_'game'.__daemons = std.list {}
end)

function mp:init(lang)
	if type(std.SOURCES_DIRS) == 'table' then
		mrd.dirs = std.SOURCES_DIRS
	end
	if type(std.DICT_FILE) == 'string' then
		mrd.dict_file = std.DICT_FILE
	end
	table.insert(mrd.dirs, curdir)
	mrd:init(lang)
	cutscene = mp.cutscene
	gameover = mp.gameover
	door = mp.door
end
std.mod_start(function()
	mp:compl_reset()
	mp:compl_fill(mp:compl(""))
	mp.last_gfx = false
--	if instead.text_input then instead.text_input(true) end
end, 2)
instead.mouse_filter(0)
-- speedup undo
local obusy = std.busy
local busy_count = 0
function std.busy(b)
	busy_count = busy_count + 1
	if not b or (busy_count % 100) == 0 then
		obusy(b)
	end
end
function instead.fading()
	return instead.need_fading() or player_moved()
end

instead.notitle = true

instead.noways = true

local opr = std.pr

local function shortcut(ob, hint)
	return ob:noun(hint)
end

function mp.shortcut.where(hint)
	return shortcut(std.me():where(), hint)
end

function mp.shortcut.firstwhere(hint)
	return shortcut(mp.first:where(), hint)
end

function mp.shortcut.secondwhere(hint)
	return shortcut(mp.second:where(), hint)
end

function mp.shortcut.here(hint)
	return shortcut(std.here(), hint)
end

function mp.shortcut.first(hint)
	return shortcut(mp.first, hint)
end

function mp.shortcut.firstit(hint)
	return mp.first:it(hint)
end

function mp.shortcut.second(hint)
	return shortcut(mp.second, hint)
end

function mp.shortcut.me(hint)
	return shortcut(std.me(), hint)
end

mp.msg.verbs = {}

function mp.shortcut.verb(hint)
	local verb = mp.msg.verbs[hint]
	if not verb then
		return hint
	end
	return mp.shortcut.word(verb)
end

function mp:shortcut_obj(ob)
	if ob == '#first' then
		ob = mp.first
	elseif ob == '#second' then
		ob = mp.second
	elseif ob == '#firstwhere' then
		ob = mp.first:where()
	elseif ob == '#secondwhere' then
		ob = mp.second:where()
	elseif ob == '#me' then
		ob = std.me()
	elseif ob == '#where' then
		ob = std.me():where()
	elseif ob == '#here' then
		ob = std.here()
	else
		ob = false
	end
	return ob
end

local function hint_append(hint, h)
	if h == "" or not h then return hint end
	if hint == "" or not hint then return h end
	return hint .. ',' .. h
end

function mp.shortcut.word(hint)
	local w = str_split(hint, ",")
	if #w == 0 then
		return hint
	end
	local verb = w[1]
	table.remove(w, 1)
	hint = ''
	for _, k in ipairs(w) do
		if k == '#first' then
			hint = hint_append(hint, mp.first_hint)
		elseif k == '#second' then
			hint = hint_append(hint, mp.second_hint)
		elseif k:find("#", 1, true) == 1 then
			local ob = mp:shortcut_obj(k)
			if not ob then
				std.err("Wrong shortcut word: "..k, 2)
			end
			hint = hint_append(hint, ob:gram().hint)
		else
			hint = hint_append(hint, k)
		end
	end
	local t = mp.mrd:noun(verb .. '/' .. hint)
	return t
end

function mp.shortcut.if_hint(hint)
	local w = str_split(hint, ",")
	if #w < 3 then
		return hint
	end
	local attr = w[2]
	local ob = w[1]
	ob = mp:shortcut_obj(ob)
	if not ob then
		std.err("Wrong object in if_has shortcut: "..hint, 2)
	end
	if not ob:hint(attr) then
		return w[4] or ''
	end
	return w[3] or ''
end

function mp.shortcut.if_has(hint)
	local w = str_split(hint, ",")
	if #w < 3 then
		return hint
	end
	local attr = w[2]
	local ob = w[1]
	ob = mp:shortcut_obj(ob)
	if not ob then
		std.err("Wrong object in if_has shortcut: "..hint, 2)
	end
	if not ob:has(attr) then
		return w[4] or ''
	end
	return w[3] or ''
end

function mp.fmt(...)
	local args = {}
	for _, v in ipairs({...}) do
		local finish
		if type(v) == 'string' then
		repeat
			finish = true
			v = v:gsub("{#[^{}]*}", function(w)
				local ww = w
				w = w:gsub("^{#", ""):gsub("}$", "")
				local hint = w:gsub("^[^/]*/?", "")
				w = w:gsub("/[^/]*$", "")
				local cap = mp.mrd.lang.is_cap(w)
				w = w:lower()
				if mp.shortcut[w] then
					w = mp.shortcut[w](hint)
					if cap then
						w = mp.mrd.lang.cap(w)
					end
				else
					std.err("Wrong shortcut: ".. ww, 2)
				end
				finish = false
				return w
			end)
		until finish
		end
		table.insert(args, v)
	end
	local ret
	for i = 1, #args do
		ret = std.par('', ret or false, std.tostr(args[i]));
	end
	return ret
end

function std.pr(...)
	local ctx = std.cctx()
	if not ctx or not ctx.self then
		return opr(...)
	end
	return opr(mp.fmt(...))
end

function std.obj:persist()
	self:attr 'persist'
	mp.persistent:add(self)
	return self
end

function std.obj:hint(hint)
	return self:gram()[mrd.lang.gram_t[hint] or hint]
end

--- Return a pronoun for the object (capitalized).
-- @see mp:it
function mp:It(w, hint)
	local t = self:it(w, hint)
	return mp.mrd.lang.cap(t)
end

--- Return a pronoun for the object.
-- This is language-dependent.
-- @param hint pronoun case
-- @see mp:it
function std.obj:it(hint)
	if mp.it then
		return mp:it(self, hint)
	else
		if self:hint'plural' then
			return 'they'
		elseif self:hint'female' then
			return 'she'
		elseif self:hint 'male' then
			return 'he'
		else
			return "it"
		end
	end
end

function std.obj:It(hint)
	local t = self:it(hint)
	return mp.mrd.lang.cap(t)
end

function mp:traceinside(w, fn)
	local ww = w and w.obj or std.here().obj
	while #ww > 0 do
		local nww = {}
		for _, o in ipairs(ww) do
			local r, v = fn(o)
			if r ~= nil then
				return r
			end
			if v ~= false then
				for _, vv in ipairs(o.obj) do
					table.insert(nww, vv)
				end
			end
		end
		ww = nww
	end
end

--- Trace an object upwards (check every parent)
-- @param w where
-- @param fn function
function mp:trace(w, fn)
	local ww = {}
	w:where(ww)
	while #ww > 0 do
		local nww = {}
		for _, o in ipairs(ww) do
			local r, v = fn(o)
			if r ~= nil then
				return r
			end
			if v ~= false then
				o:where(nww)
			end
		end
		ww = nww
	end
end

function std.obj:attr(str)
	local a = str_split(str, ", ")
	for _, v in ipairs(a) do
		local val =  (v:find("~", 1, true) ~= 1)
		v = v:gsub("^~", "")
		self['__attr__' .. v] = val
	end
	return self
end

function std.obj:hasnt(attr)
	return not self:has(attr)
end

function std.obj:has(attr)
	attr = std.strip(attr)
	local val =  (attr:find("~", 1, true) ~= 1)
	attr = attr:gsub("^~", "")
	if val then
		return self['__attr__' .. attr]
	else
		return not self['__attr__' .. attr]
	end
end

function iface:title(t)
	return(iface:bold(mrd.lang.cap(t)))
end

std.getmt("").__pow = function(a, b)
	if b then
		if std.is_obj(b) then
			return b ^ a
		end
		return std.rawequal(a, b)
	end
	return false
end
--luacheck: no self
local lang = require "morph/lang-ru"
require "parser/mp"
require "parser/mplib"
local mp = _'@metaparser'

std.mod_init(
	function()
	mp:init(lang)
end)
game.dsc = function()
	p ([[МЕТАПАРСЕР3 Версия: ]]..mp.version.."^")
	p [[http://instead-hub.github.io^^
Если вам необходима справка по игре, наберите "помощь".
^]]
end
-- local utf = mp.utf

_'@all'.word = -"всё/~од"

_'@darkness'.word = -"тьма,темнота,темень"
_'@darkness'.before_Any = "Полная, кромешная тьма."
_'@darkness':attr 'persist'

_'@n_to'.word = -"север";
_'@ne_to'.word = -"северо-восток";
_'@e_to'.word = -"восток";
_'@se_to'.word = -"юго-восток";
_'@s_to'.word = -"юг";
_'@sw_to'.word = -"юго-запад";
_'@w_to'.word = -"запад";
_'@nw_to'.word = -"северо-запад";
_'@u_to'.word = -"наверх,вверх,верх";
_'@d_to'.word = -"вниз,низ";
_'@out_to'.word = -"наружу,выход,назад";
_'@in_to'.word = -"внутрь,вход"

mp.shorten = {
	["с"] = "север";
	["в"] = "восток";
	["з"] = "запад";
	["ю"] = "юг";
	["св"] = "северо-восток";
	["юв"] = "юго-восток";
	["юз"] = "юго-запад";
	["сз"] = "северо-запад";
	["вн"] = "вниз";
	["вв"] = "вверх";
}

mp.shorten_expert = {
	["и"] = "инвентарь";
	["ж"] = "ждать";
	["о"] = "осмотреть";
	["осм"] = "осмотреть";
	["вкл"] = "включить";
	["выкл"] = "выключить";
	["см"] = "смотреть";
}

function mp:skip_filter(w)
	for _, v in ipairs(w) do
		if v == 'не' or v == 'кроме' or v == 'вместо' then
			return false
		end
	end
	return true
end

local function endswith(w, t)
	return not not w:find(t..'$')
end

function mp:verb_filter(w)
	if #w > 1 then
		return true
	end
	local utf = mp.utf
	local verb = w[1]
	local t = utf.chars(w[1])
	if endswith(verb, 'ся') or endswith(verb, 'сь') or endswith(verb, 'те') then
		local len = #verb
		len = len - utf.bb(verb, len)
		len = len - utf.bb(verb, len)
		verb = verb:sub(1, len)
	end
	if endswith(verb, 'и') or endswith(verb, 'ь') then
		return true
	end
	local t = utf.chars(verb)
	local a = { ['а'] = true, ['е'] = true, ['и'] = true,
		['о'] = true, ['у'] = true, ['ы'] = true,
		['ю'] = true, ['я'] = true };
	local len = #t
	if len >= 2 and a[t[len - 1]] and t[len] == 'й' then -- or a[t[len]] then
		return true
	end
	return false
end

_'@compass'.before_Default = function()
	p('"{#First}" это направление. {#Firstit/вн} нельзя ', mp.parsed[1], ".")
end

function mp.msg.SCORE(d)
	if d > 0 then
		pn ("{$fmt em|(Счёт увеличился на ", d, ")}")
	else
		pn ("{$fmt em|(Счёт уменьшился на ", d, ")}")
	end
end
mp.door.word = -"дверь";
mp.msg.TITLE_SCORE = function()
	if mp.maxscore then
		pr ("Счёт: ", mp.score, "/", mp.maxscore)
	else
		pr ("Счёт: ", mp.score)
	end
end
mp.msg.TITLE_TURNS = function()
	pr ("Ходы: ", game:time() - 1)
end
mp.msg.YES = "Да"
mp.msg.WHEN_DARK = "Кромешная тьма."
mp.msg.UNKNOWN_THEDARK = "Возможно, это потому что в темноте ничего не видно?"
mp.msg.COMPASS_NOWAY = "Этот путь недоступен."
mp.msg.COMPASS_EXAM_NO = "В этом направлении не видно ничего примечательного."
mp.msg.ENUM = "шт."
mp.msg.CUTSCENE_HELP = "Для продолжения нажмите <ввод> или введите {$fmt em|дальше}."
if instead.tiny then
	mp.msg.CUTSCENE_MORE = "^{$fmt em|(дальше)}"
end
mp.msg.DLG_HELP = "Для выбора фразы введите цифру."
mp.msg.NO_ALL = "Это действие нельзя применить на всё."
mp.msg.DROPPING_ALL = function(w)
	pn (iface:em("(бросить "..w:noun'вн'..")"))
end
mp.msg.TAKING_ALL = function(w)
	pn (iface:em("(взять "..w:noun'вн'..")"))
end
mp.msg.TAKE_BEFORE = function(w)
	pn (iface:em("(сначала взяв "..w:noun'вн'..")"))
end
mp.msg.DISROBE_BEFORE = function(w)
	pn (iface:em("(сначала сняв "..w:noun'вн'..")"))
end

mp.msg.CLOSE_BEFORE = function(w)
	pn (iface:em("(сначала закрыв "..w:noun'вн'..")"))
end

--"находиться"
mp.msg.SCENE = "{#Me} {#word/находиться,#me,нст} {#if_has/#here,supporter,на,в} {#here/пр,2}.";
mp.msg.INSIDE_SCENE = "{#Me} {#word/находиться,#me,нст} {#if_has/#where,supporter,на,в} {#where/пр,2}.";
mp.msg.TITLE_INSIDE = "{#if_has/#where,supporter,на,в} {#where/пр,2}";

mp.msg.COMPASS_EXAM = function(dir, ob)
	if dir == 'u_to' then
		p "Вверху"
	elseif dir == 'd_to' then
		p "Внизу"
	elseif dir == 'out_to' or dir == 'in_to' then
		p "В этом направлении"
	else
		p "На {#first/пр,2}"
	end
	if ob:hint'plural' then
		p "находятся"
	else
		p "находится"
	end
	p (ob:noun(),".")
end

mp.msg.enter = "<ввод>"
mp.msg.EMPTY = 'Простите?'
mp.msg.UNKNOWN_VERB = function(w)
	p ("Непонятный глагол ", iface:em(w), ".")
end
mp.msg.UNKNOWN_VERB_HINT = function(w)
	p ("Самое похожее слово: ", iface:em(w), ".")
end
mp.msg.INCOMPLETE = "Нужно дополнить предложение."
mp.msg.INCOMPLETE_NOUN = function(w)
	if w then
		p('К чему вы хотите применить команду "',w, '"?')
	else
		p"К чему вы хотите применить команду?"
	end
end

mp.msg.INCOMPLETE_SECOND_NOUN = function(w)
	p ('Уточните команду: "',w,'"?')
end

mp.msg.UNKNOWN_OBJ = function(w)
	if not w then
		p "Об этом предмете здесь ничего не известно."
	else
		p "Об этом предмете здесь ничего не известно "
		p ("(",w,").")
	end
end
mp.msg.NOTHING_OBJ = "Ничего подходящего нет."
mp.msg.UNKNOWN_WORD = function(w)
	if not w then
		p "Фраза не распознана."
	else
		p "Фраза не распознана "
		p ("(",w,"?).")
	end
end
mp.msg.HINT_WORDS = "Возможно"
mp.msg.AND = "и"
mp.msg.OR = "или"
mp.msg.MULTIPLE = "Тут есть"
mp.msg.LIVE_ACTION = function(w)
	p (w:It'дт'," это не понравится.")
end
mp.msg.NO_LIVE_ACTION = "Действие применимо только к одушевлённым объектам."

mp.msg.NOTINV = function(t)
	p (lang.cap(t:noun'вн') .. " сначала нужно взять.")
end
--"надет"
mp.msg.HAS_WORN = function(w)
	local hint = w:gram().hint
	return mp.mrd:word('надет/' .. hint)
end
--"открыт"
mp.msg.HAS_OPEN = function(w)
	local hint = w:gram().hint
	return mp.mrd:word('открыт/' .. hint)
end
--"включён"
mp.msg.HAS_ON = function(w)
	local hint = w:gram().hint
	return mp.mrd:word('включён/' .. hint)
end
--"светится"
mp.msg.HAS_LIGHT = function(w)
	local hint = w:gram().hint
	return mp.mrd:word('светится/' .. hint)
end

mp.msg.EXITBEFORE = "Возможно, {#me/дт} нужно сначала "..
	"{#if_has/#where,supporter,слезть {#so/{#where/рд}}.,покинуть {#where/вн}.}"

mp.default_Event = "Exam"
mp.default_Verb = "осмотреть"

--"доступен"
mp.msg.ACCESS1 = "{#First} отсюда не{#word/доступен,#first}."
mp.msg.ACCESS2 = "{#Second} отсюда не{#word/доступен,#second}."

mp.msg.Look.HEREIS = "Здесь находится"
mp.msg.Look.HEREARE = "Здесь находятся"
mp.msg.NOROOM = function(w)
	if w == std.me() then
		p ("У {#me/рд} слишком много вещей.")
	elseif w:has'supporter' then
		p ("На ", w:noun'пр,2', " больше нет места.")
	else
		p ("В ", w:noun'пр,2', " больше нет места.")
	end
end
--"включён"
--"выключен"
mp.msg.Exam.SWITCHSTATE = "{#First} сейчас {#if_has/#first,on,{#word/включён,#first},{#word/выключен,#first}}."

mp.msg.Exam.NOTHING = function(w)
	if w:has 'supporter' then
		mp:pnoun (w, "На {#first/пр,2}")
	else
		mp:pnoun (w, "В {#first/пр,2}")
	end
	p "ничего нет."
end

mp.msg.Exam.CONTENT = function(w, oo)
	local single = #oo == 1 and not oo[1]:hint 'plural'
	if std.me():where() == w or std.here() == w then
if false then
		if single then
			p "Здесь находится"
		else
			p "Здесь находятся"
		end
		mp:multidsc(oo)
else
		p "{#Me} {#word/видеть,#me,нст} здесь";
		mp:multidsc(oo, 'вн')
end
		p "."
		return
	end
	if w:has 'supporter' then
		mp:pnoun (w, "На {#first/пр,2}")
	else
		mp:pnoun (w, "В {#first/пр,2}")
	end
	if single then
		p "находится"
	else
		p "находятся"
	end
	mp:multidsc(oo)
	p "."
end

--"видеть"
mp.msg.Exam.DEFAULT = "{#Me} не {#word/видеть,#me,нст} {#vo/{#first/пр}} ничего необычного.";
mp.msg.Exam.SELF = "{#Me} не {#word/видеть,#me,нст} в себе ничего необычного.";

--"открыт"
mp.msg.Exam.OPENED = "{#First} {#word/открыт,нст,#first}."
--"закрыт"
mp.msg.Exam.CLOSED = "{#First} {#word/закрыт,нст,#first}."
--"находить"
mp.msg.LookUnder.NOTHING = "{#Me} не {#word/находить,нст,#me} под {#first/тв} ничего интересного."
--"могу"
--"закрыт"
--"держать"
--"залезать"
mp.msg.Enter.ALREADY = "{#Me} уже {#if_has/#first,supporter,на,в} {#first/пр,2}."
mp.msg.Enter.INV = "{#Me} не {#word/могу,#me,нст} зайти в то, что {#word/держать,#me,нст} в руках."
mp.msg.Enter.IMPOSSIBLE = "Но в/на {#first/вн} невозможно войти, встать, сесть или лечь."
mp.msg.Enter.CLOSED = "{#First} {#word/закрыт,#first}, и {#me} не {#word/мочь,#me,нст} зайти туда."
mp.msg.Enter.ENTERED = "{#Me} {#word/залезать,нст,#me} {#if_has/#first,supporter,на,в} {#first/вн}."
mp.msg.Enter.DOOR_NOWHERE = "{#First} никуда не ведёт."
--"закрыт"
mp.msg.Enter.DOOR_CLOSED = "{#First} {#word/закрыт,#first}."

mp.msg.Walk.ALREADY = mp.msg.Enter.ALREADY
mp.msg.Walk.WALK = "Но {#first} и так находится здесь."
mp.msg.Walk.NOWHERE = "Куда именно?"
mp.msg.Walk.INV = "Но {#first} у {#me/рд} с собой."

mp.msg.Enter.EXITBEFORE = "Сначала нужно {#if_has/#where,supporter,слезть {#so/{#where/рд}}.,покинуть {#where/вн}.}"

mp.msg.Exit.NOTHERE = "Но {#me} сейчас не {#if_has/#first,supporter,на,в} {#first/пр,2}."
mp.msg.Exit.NOWHERE = "Но {#me/дт} некуда выходить."
mp.msg.Exit.CLOSED = "Но {#first} {#word/закрыт,#first}."

--"покидать"
--"слезать"
mp.msg.Exit.EXITED = "{#Me} {#if_has/#first,supporter,{#word/слезать,#me,нст} {#so/{#first/рд}},"..
	"{#word/покидать,#me,нст} {#first/вн}}."

mp.msg.GetOff.NOWHERE = "Но {#me/дт} не с чего слезать."

mp.msg.Inv.NOTHING = "У {#me/рд} с собой ничего нет."
mp.msg.Inv.INV = "У {#me/рд} с собой"

--"открывать"
mp.msg.Open.OPEN = "{#Me} {#word/открывать,нст,#me} {#first/вн}."
mp.msg.Open.NOTOPENABLE = "{#First/вн} невозможно открыть."
--"открыт"
mp.msg.Open.WHENOPEN = "{#First/} уже {#word/открыт,#first}."
--"заперт"
mp.msg.Open.WHENLOCKED = "Похоже, что {#first/} {#word/заперт,#first}."

--"закрывать"
mp.msg.Close.CLOSE = "{#Me} {#word/закрывать,нст,#me} {#first/вн}."
mp.msg.Close.NOTOPENABLE = "{#First/вн} невозможно закрыть."
--"закрыт"
mp.msg.Close.WHENCLOSED = "{#First/} уже {#word/закрыт,#first}."

mp.msg.Lock.IMPOSSIBLE = "{#First/вн} невозможно запереть."
--"заперт"
mp.msg.Lock.LOCKED = "{#First} уже {#word/заперт,#first}."
--"закрыть"
mp.msg.Lock.OPEN = "Сначала необходимо закрыть {#first/вн}."
--"подходит"
mp.msg.Lock.WRONGKEY = "{#Second} не {#word/подходит,#second} к замку."
--"запирать"
mp.msg.Lock.LOCK = "{#Me} {#word/запирать,#me,нст} {#first/вн}."

mp.msg.Unlock.IMPOSSIBLE = "{#First/вн} невозможно отпереть."
--"заперт"
mp.msg.Unlock.NOTLOCKED = "{#First} не {#word/заперт,#first}."
--"подходит"
mp.msg.Unlock.WRONGKEY = "{#Second} не {#word/подходит,нст,#second} к замку."
--"отпирать"
mp.msg.Unlock.UNLOCK = "{#Me} {#word/отпирать,#me,нст} {#first/вн}."

mp.msg.Take.HAVE = "У {#me/вн} и так {#firstit} уже есть."
mp.msg.Take.TAKE = "{#Me} {#verb/take} {#first/вн}."
mp.msg.Take.SELF = "{#Me} есть у {#me/рд}."
--"находиться"
mp.msg.Take.WHERE = "Нельзя взять то, {#if_hint/#where,supporter,на,в} чём {#me} {#word/находиться,#me}."

mp.msg.Take.LIFE = "{#First/дт} это вряд ли понравится."
--"закреплён"
mp.msg.Take.STATIC = "{#First} жестко {#word/закреплён,#first}."
mp.msg.Take.SCENERY = "{#First/вн} невозможно взять."

--"надет"
mp.msg.Take.WORN = "{#First} {#word/надет,#first} на {#firstwhere/вн}."
mp.msg.Take.PARTOF = "{#First} {#if_hint/#first,plural,являются,является} частью {#firstwhere/рд}."

mp.msg.Remove.WHERE = "{#First} не {#word/находиться,#first,нст} {#if_has/#second,supporter,на,в} {#second/пр,2}."
--"поднят"
--"извлечён"
mp.msg.Remove.REMOVE = "{#First} {#if_has/#second,supporter,{#word/поднят с,#first},"..
	"{#word/извлечён из,#first}} {#second/рд}."

mp.msg.Drop.SELF = "У {#me/рд} не хватит ловкости."
mp.msg.Drop.WORN = "{#First/вн} сначала нужно снять."
--"помещать"
mp.msg.Insert.INSERT = "{#Me} {#word/помещать,нст,#me} {#first/вн} в {#second/вн}."
mp.msg.Insert.CLOSED = "{#Second} {#word/закрыт,#second}."
mp.msg.Insert.NOTCONTAINER = "{#Second} не {#if_hint/#second,plural,могут,может} что-либо содержать."
mp.msg.Insert.WHERE = "Нельзя поместить {#first/вн} внутрь себя."
mp.msg.Insert.ALREADY = "Но {#first} уже и так {#word/находиться,#first} там."
mp.msg.PutOn.NOTSUPPORTER = "Класть что-либо на {#second/вн} бессмысленно."
--"класть"
mp.msg.PutOn.PUTON = "{#Me} {#word/класть,нст,#me} {#first/вн} на {#second/вн}."
mp.msg.PutOn.WHERE = "Нельзя поместить {#first/вн} на себя."

--"брошен"
mp.msg.Drop.DROP = "{#First} {#word/брошен,#first}."

mp.msg.ThrowAt.NOTLIFE = "Бросать {#first/вн} в {#second/вн} бесполезно."
mp.msg.ThrowAt.THROW = "У {#me/рд} не хватает решимости бросить {#first/вн} в {#second/вн}."


mp.msg.Wear.NOTCLOTHES = "Надеть {#first/вн} невозможно."
mp.msg.Wear.WORN = "{#First} уже на {#me/дт}."
--"надевать"
mp.msg.Wear.WEAR = "{#Me} {#word/надевать,#me,нст} {#first/вн}."

mp.msg.Disrobe.NOTWORN = "{#First} не на {#me/дт}."
--"снимать"
mp.msg.Disrobe.DISROBE = "{#Me} {#word/снимать,#me,нст} {#first/вн}."

mp.msg.SwitchOn.NONSWITCHABLE = "{#First/вн} невозможно включить."
--"включён"
mp.msg.SwitchOn.ALREADY = "{#First} уже {#word/включён,#first}."
--"включать"
mp.msg.SwitchOn.SWITCHON = "{#Me} {#word/включать,#me,нст} {#first/вн}."

mp.msg.SwitchOff.NONSWITCHABLE = "{#First/вн} невозможно выключить."
--"выключён"
mp.msg.SwitchOff.ALREADY = "{#First} уже {#word/выключён,#first}."
--"выключать"
mp.msg.SwitchOff.SWITCHOFF = "{#Me} {#word/выключать,#me,нст} {#first/вн}."

--"годится"
mp.msg.Eat.NOTEDIBLE = "{#First} не {#word/годится,#first} в пищу."
mp.msg.Taste.TASTE = "Никакого необычного вкуса нет."

--"съедать"
mp.msg.Eat.EAT = "{#Me} {#word/съедать,нст,#me} {#first/вн}."
mp.msg.Drink.IMPOSSIBLE = "Выпить {#first/вн} невозможно."

mp.msg.Push.STATIC = "{#First/вн} трудно сдвинуть с места."
mp.msg.Push.SCENERY = "{#First/вн} двигать невозможно."
mp.msg.Push.PUSH = "Ничего не произошло."

mp.msg.Pull.STATIC = "{#First/вн} трудно сдвинуть с места."
mp.msg.Pull.SCENERY = "{#First/вн} двигать невозможно."
mp.msg.Pull.PULL = "Ничего не произошло."

mp.msg.Turn.STATIC = "{#First/вн} трудно сдвинуть с места."
mp.msg.Turn.SCENERY = "{#First/вн} двигать невозможно."
mp.msg.Turn.TURN = "Ничего не произошло."

mp.msg.Wait.WAIT = "Проходит немного времени."

mp.msg.Touch.LIVE = "Не стоит давать волю рукам."
mp.msg.Touch.TOUCH = "Никаких необычных ощущений нет."
mp.msg.Touch.MYSELF = "{#Me} на месте."

mp.msg.Rub.RUB = "Тереть {#first/вн} бессмысленно."
mp.msg.Sing.SING = "С таким слухом и голосом как у {#me/рд} этого лучше не делать."

mp.msg.Give.MYSELF = "{#First} и так у {#me/рд} есть."
mp.msg.Give.GIVE = "{#Second/вн} это не заинтересовало."
mp.msg.Show.SHOW = "{#Second/вн} это не впечатлило."

mp.msg.Burn.BURN = "Поджигать {#first/вн} бессмысленно."
mp.msg.Burn.BURN2 = "Поджигать {#first/вн} {#second/тв} бессмысленно."
--"поверь"
mp.msg.Wake.WAKE = "Это не сон, а явь."
mp.msg.WakeOther.WAKE = "Будить {#first/вн} не стоит."
mp.msg.WakeOther.NOTLIVE = "Бессмысленно будить {#first/вн}."

mp.msg.PushDir.PUSH = "Передвигать это нет смысла."

mp.msg.Kiss.NOTLIVE = "Странное желание."
mp.msg.Kiss.KISS = "{#Firstit/дт} это может не понравиться."
mp.msg.Kiss.MYSELF = "Ну уж нет."

mp.msg.Think.THINK = "Отличная идея!"
mp.msg.Smell.SMELL = "Никакого необычного запаха нет."
mp.msg.Smell.SMELL2 = "Пахнет как {#first}."

mp.msg.Listen.LISTEN = "Никаких необычных звуков нет."
--"прислушаться"
mp.msg.Listen.LISTEN2 = "{#Me} {#word/прислушаться,#me,прш} к {#first/дт}. Никаких необычных звуков нет."

--"выкопать"
mp.msg.Dig.DIG = "{#Me} ничего не {#word/выкопать,#me,прш}."
mp.msg.Dig.DIG2 = "Копать {#first/вн} бессмысленно."
mp.msg.Dig.DIG3 = "Копать {#first/вн} {#second/тв} бессмысленно."

mp.msg.Cut.CUT = "Резать {#first/вн} бессмысленно."
mp.msg.Cut.CUT2 = "Резать {#first/вн} {#second/тв} бессмысленно."

mp.msg.Tear.TEAR = "Рвать {#first/вн} бессмысленно."

mp.msg.Tie.TIE = "Привязывать {#first/вн} бессмысленно."
mp.msg.Tie.TIE2 = "Привязывать {#first/вн} к {#second/дт} бессмысленно."

mp.msg.Blow.BLOW = "Дуть на/в {#first/вн} бессмысленно."

mp.msg.Attack.LIFE = "Агрессия к {#first/дт} неоправданна."
mp.msg.Attack.ATTACK = "Сила есть -- ума не надо?"
--"хотеть"
mp.msg.Sleep.SLEEP = "{#Me} не {#word/хотеть,#me,нст} спать."
mp.msg.Swim.SWIM = "Для этого здесь недостаточно воды."
mp.msg.Fill.FILL = "Наполнять {#first/вн} бессмысленно."
--"подпрыгивать"
mp.msg.Jump.JUMP = "{#Me} глупо {#word/подпрыгивать,#me,нст}."
mp.msg.JumpOver.JUMPOVER = "Прыгать через {#first/вн} бессмысленно."

--"находить"
mp.msg.Consult.CONSULT = "{#Me} не {#word/находить,#me,нст} ничего подходящего."

--"помахать"
mp.msg.WaveHands.WAVE = "{#Me} глупо {#word/помахать,прш,#me} руками."
mp.msg.Wave.WAVE = "{#Me} глупо {#word/помахать,прш,#me} {#first/тв}."

mp.msg.Talk.SELF = "Беседы не получилось."
--"уметь"
mp.msg.Talk.NOTLIVE = "{#First} не {#word/уметь,#first,нст} разговаривать."
--"отреагировать"
mp.msg.Talk.LIVE = "{#First} никак не {#word/отреагировать,#first}."

mp.msg.Tell.SELF = "Беседы не получилось."

--"безмолвен"
mp.msg.Tell.NOTLIVE = "{#First} {#word/безмолвен,#first}."
--"отреагировать"
mp.msg.Tell.LIVE = "{#First} никак не {#word/отреагировать,#first}."
--"нашёл"
mp.msg.Tell.EMPTY = "{#Me} не {#word/нашёл,#me,прш} что сказать."

--"отвечать"
mp.msg.Ask.NOTLIVE = "Ответа не последовало."
--"ответить"
mp.msg.Ask.LIVE = "{#First} не {#word/ответить,прш,#first}."
--"придумать"
mp.msg.Ask.EMPTY = "{#Me} не {#word/придумать,#me,прш} что спросить."
mp.msg.Ask.SELF = "Хороший вопрос."

--"отвечать"
mp.msg.Answer.NOTLIVE = "Ответа не последовало."
--"ответить"
mp.msg.Answer.LIVE = "{#First} не {#word/ответить,прш,#first}."
--"придумать"
mp.msg.Answer.EMPTY = "{#Me} не {#word/придумать,#me,прш} что ответить."
mp.msg.Answer.SELF = "Хороший ответ."

mp.msg.Yes.YES = "Вопрос был риторическим."

mp.msg.Use.USE = "Как именно?"

--"продаваться"
mp.msg.Buy.BUY = "{#First} не {#word/продаваться,нст,#first}."

mp.keyboard_space = '<пробел>'
mp.keyboard_backspace = '<удалить>'

mp.msg.verbs.take = -"брать,#me,нст"

mp.msg.GAMEOVER_HELP = [[Чтобы начать заново, введите рестарт.]];

local function dict(t, hint)
	local g = std.split(hint, ",")
	for _, v in ipairs(g) do
		if t[v] then
			return t[v]
		end
	end
end

function mp:myself(_, hint)
	local ww = dict({
			["вн"] = { "себя" };
			["дт"] = { "себе" };
			["тв"] = {"собой" };
			["пр"] = { "себе" };
			["рд"] = { "себя" };
		 }, hint)
	return ww
end

function mp:it(w, hint)
	hint = hint or ''
	if w:hint'plural' then
		return mp.mrd:noun(-"они/"..hint)
	elseif w:hint'neuter' then
		return mp.mrd:noun(-"оно/"..hint)
	elseif w:hint'female' then
		return mp.mrd:noun(-"она/"..hint)
	end
	return mp.mrd:noun(-"он/"..hint)
end

function mp:synonyms(w, hint)
	local nt = {
		['его'] = 'него';
		['её'] = 'неё';
		['ее'] = 'нее';
		['ей'] = 'ней';
		['им'] = 'ним';
		['ими'] = 'ними';
		['их'] = 'них';
		['ему'] = 'нему';
	}
	local t = self:it(w, hint)
	return { t, nt[t] }
end

mp.keyboard = {
	'А','Б','В','Г','Д','Е','Ё','Ж','З','И','Й',
	'К','Л','М','Н','О','П','Р','О','С','Т','У','Ф',
	'Х','Ц','Ч','Ш','Щ','Ь','Ы','Ъ','Э','Ю','Я'
}

local function hints(w)
	local h = std.split(w, ",")
	local ret = {}
	for _, v in ipairs(h) do
		ret[v] = true
	end
	return ret
end

function mp:err_noun(noun)
	if noun == '*' then return "{$fmt em|<любое слово>}" end
	local hint = std.split(noun, "/")
	local rc = "{$fmt em|"
	if #hint == 2 then
		local h = hints(hint[2])
		local acc = 'кто/что'
		if h["им"] then
			acc = 'кто/что'
		elseif h["рд"] then
			acc = 'кого/чего'
		elseif h["дт"] then
			acc = 'кому/чему'
		elseif h["вн"] then
			acc = 'кого/что'
		elseif h["тв"] then
			acc = 'кем/чем'
		elseif h["пр"] or h["пр2"] then
			acc = 'ком/чём'
		end
		rc = rc ..  acc
	else
		rc = rc .. "кто/что"
	end
	rc = rc .. "}"
	return rc
end

function mp.shortcut.vo(hint)
	local w = std.split(mp.mrd.lang.norm(hint))
	local utf = mp.utf
	local vow = lang.is_vowel
	local char = utf.char
	local excl = {
		["льве"] = true,
		["львах"] = true,
		["льду"] = true,
		["льдах"] = true,
		["льне"] = true,
		["льнах"] = true,
		["лбу"] = true,
		["лбах"] = true,
		["лжи"] = true,
		["лжах"] = true,
		["мху"] = true,
		["мхах"] = true,
		["рву"] = true,
		["рвах"] = true,
		["ржи"] = true,
		["ржах"] = true,
		["рту"] = true,
		["ртах"] = true,
		["мне"] = true,
		["что"] = true,
	}
	w = w[#w]
	if mp.utf.len(w) > 2 and
		(vow(char(w, 1) == 'в' or vow(char(w, 1) == 'ф') and
		not vow(char(w, 2)))) or excl[w] then
		return "во ".. hint
	end
	return "в ".. hint
end

function mp.shortcut.so(hint)
	local so = {
		["с"] = true,
		["з"] = true,
		["ш"] = true,
		["ж"] = true,
		["л"] = true,
		["р"] = true,
		["м"] = true,
	}

	local w = std.split(mp.mrd.lang.norm(hint))
	local utf = mp.utf
	w = w[#w]
	if utf.len(w) > 2 and
		((so[utf.char(w, 1)] and
		not lang.is_vowel(utf.char(w, 2))) or utf.char(w, 1) == 'щ') then
		return "со ".. hint
	end
	if utf.len(w) > 2 and utf.char(w, 1) == 'л' and utf.char(w, 2) == 'ь' and
		not lang.is_vowel(utf.char(w, 2)) then
		return "со ".. hint
	end
	return "с ".. hint
end

function mp:before_Enter(w)
	if mp:compass_dir(w) then
		mp:xaction("Walk", w)
		return
	end
	return false
end

mp.msg.HELP = function()
	p [[{$fmt b|КАК ИГРАТЬ?}^^

Вводите ваши действия в виде простых предложений вида: глагол -- существительное. Например:^
> открыть дверь^
> отпереть дверь ключом^
> идти на север^
> взять кепку^
^
Чтобы снова увидеть описание обстановки, введите "осмотреть", "осм" или просто нажмите "ввод".^
^
Чтобы осмотреть предмет, введите "осмотреть книгу" или просто "книга".^
^
Попробуйте "осмотреть себя" и узнать, кто вы.^
^
Чтобы узнать какие предметы у вас с собой, наберите "инвентарь" или "инв".^
^
Для перемещений используйте стороны света, например: "идти на север" или "север" или просто "с". Кроме сторон света можно перемещаться вверх ("вверх" или "вв") и вниз ("вниз" или "вн"), "внутрь" и "наружу".]]
	if not instead.tiny then
		p [[^^Вы можете воспользоваться клавишей "TAB" для автодополнения ввода.]]
	else
		p [[^^Вы можете сокращать названия объектов.]]
		p [[^^Чтобы сохранять и загружать игру используйте "сохранить" и "загрузить".]]
		if instead.tiny then
			p [[Например, "сохранить 1".]]
		end
		p [[Начать заново: "заново".]]
		if instead.reinstead then
			p [[^^Также доступны команды: !restart, !quit, !info, !save, !load и !font <размер>.]]
		end
	end
end

function mp.token.compass1(_)
	return "{noun_obj}/@n_to,compass|{noun_obj}/@ne_to,compass|"..
		"{noun_obj}/@e_to,compass|{noun_obj}/@se_to,compass|"..
		"{noun_obj}/@s_to,compass|{noun_obj}/@sw_to,compass|"..
		"{noun_obj}/@w_to,compass|{noun_obj}/@nw_to,compass"
end

function mp.token.compass2(_)
	return "{noun_obj}/@u_to,compass|{noun_obj}/@d_to,compass|{noun_obj}/@in_to,compass|{noun_obj}/@out_to,compass"
end

function mp.shortcut.pref1()
	return '[по|подо|за|во|про]'
end

function mp.shortcut.pref2()
	return '[по|под|за|в|про]'
end

function mp.shortcut.pref3()
	return 'по|подъ|за|въ|про'
end

std.mod_init(function(_)
Verb { "#Walk",
	"идти,{#pref1}йти,{#pref1}йди,иди,бежать,{#pref2}бежать,бег/и,{#pref2}бег/и,влез/ть,"..
	"[|{#pref3}]ехать,едь,сесть,сядь,лечь,ляг,[в|]стать,[в|]стань[|те]",
	"на {compass1} : Walk",
	"на|в|во {noun}/вн,scene,enterable : Enter",
	"внутрь {noun}/рд,scene,enterable : Enter",
	"к {noun}/дт,scene : Walk",
	"{compass2}: Walk" }

Verb { "#Exit",
	"[вы|у]йти,выйд/и,уйд/и,вылез/ти,выхо/ди,обратно,назад,выбраться,выберись,выбираться",
	"из|с|со {noun}/рд,scene : Exit",
	"в|через|на {noun}/вн,scene,enterable : Enter",
	"?наружу : Exit" }

Verb { "#Exam",
	"[о| |по|рас]смотр/еть,[раз|по]гляд/еть",
	"?на {noun}/вн : Exam",
	" : Look",
	"инвентарь : Inv",
	"~ под {noun}/тв : LookUnder",
	"~ под {noun}/вн : LookUnder",
	"~ в|во|на {noun}/пр,2 : Search",
	"~ внутри {noun}/рд : Search",
	"~ в|во {noun}/вн : Search",
	"~ в|во {noun}/пр,2 ?о|?об|?обо|?про * : Consult",
	"~ ?о|?об|?обо|?про * в|во {noun}/пр,2 : Consult reverse",
}

Verb { "#Search",
	"[|по]искать,обыскать,[|по]ищ/и,обыщ/и,[|по]изуч/ать,[|по]исслед/овать",
	"{noun}/вн : Search",
	"в|во|на {noun}/пр,2 : Search",
	"под {noun}/тв : LookUnder",
	"~ в|во {noun}/пр,2 ?о|?об|?обо|?про * : Consult",
	"~ ?о|?об|?обо|?про * в|во {noun}/пр,2 : Consult reverse",
}

Verb { "#Open",
	"откр/ыть,распах/нуть,раскр/ыть,отвори/ть",
	"{noun}/вн : Open",
	"{noun}/вн {noun}/тв,held : Unlock",
	"~ {noun}/тв,held {noun}/вн : Unlock reverse",
}

Verb { "#Unlock",
	"отпереть,отопр/и",
	"{noun}/вн {noun}/тв,held : Unlock",
	"~ {noun}/тв,held {noun}/вн : Unlock reverse",
}

Verb { "#Close",
	"закры/ть,закро/й",
	"{noun}/вн : Close",
	"{noun}/вн {noun}/тв,held : Lock",
	"~ {noun}/вн на {noun}/вн,held : Lock",
	"~ {noun}/тв,held {noun}/вн : Lock reverse",
}

Verb { "#Lock",
	"запереть",
	"{noun}/вн {noun}/тв,held : Lock",
	"~ {noun}/вн на {noun}/вн,held : Lock",
	"~ {noun}/тв,held {noun}/вн : Lock reverse",
}

Verb { "#Inv",
	"инв/ентарь,с собой",
	"Inv" }

function mp.shortcut.pref4()
	return '[ |за|подо]'
end

function mp.shortcut.pref5()
	return '[ |за|под]'
end

Verb { "#Take",
	"взять,возьм/и,{#pref4}брать,{#pref5}бер/и,доста/ть,схват/ить,"..
	"украсть,украд/и,извле/чь,вын/уть,вытащ/ить",
	"{noun}/вн,scene : Take",
	"{noun}/вн,scene из|с|со|у {noun}/рд,inside,holder: Remove",
	"~ из|с|со|у {noun}/рд,inside,holder {noun}/вн,scene: Remove reverse",
}

Verb { "#Insert",
	"воткн/уть,втык/ать,вставить,влож/ить,"..
	"[|про|за]сун/уть,вставь/",
	"{noun}/вн,held в|во {noun}/вн,inside : Insert",
	"~ {noun}/вн,held внутрь {noun}/рд : Insert",
	"~ в|во {noun}/вн {noun}/вн : Insert reverse",
	"~ внутрь {noun}/рд {noun}/вн : Insert reverse",
}

Verb { "#Drop",
	"полож/ить,постав/ить,посади/ть,класть,клади/,помест/ить",
	"{noun}/вн,held : Drop",
	"{noun}/вн,held в|во {noun}/вн,inside : Insert",
	"~ {noun}/вн,held внутрь {noun}/рд : Insert",
	"{noun}/вн,held на {noun}/вн : PutOn",
	"~ в|во {noun}/вн {noun}/вн : Insert reverse",
	"~ внутрь {noun}/рд {noun}/вн : Insert reverse",
	"~ на {noun}/вн {noun}/вн : PutOn reverse",
}

Verb {
	"#ThrowAt",
	"брос/ить,выбро/сить,кину/ть,кинь/,кида/ть,швыр/нуть,метн/уть,метать",
	"{noun}/вн,held : Drop",
	"{noun}/вн,held в|во|на {noun}/вн : ThrowAt",
	"~ в|во|на {noun}/вн {noun}/вн : ThrowAt reverse",
	"~ {noun}/вн {noun}/дт : ThrowAt",
	"~ {noun}/дт {noun}/вн : ThrowAt reverse",

}

Verb {
	"#Wear",
	"наде/ть,оде/ть",
	"{noun}/вн,held : Wear",
}

Verb {
	"#Disrobe",
	"снять,сним/ать",
	"{noun}/вн,worn : Disrobe",
	"~ {noun}/вн с|со {noun}/рд : Remove",
	"~ с|со {noun}/рд {noun}/вн : Remove reverse"
}

Verb {
	"#SwitchOn",
	"включ/ить,вруб/ить,активи/ровать",
	"{noun}/вн : SwitchOn",
}

Verb {
	"#SwitchOff",
	"выключ/ить,выруб/ить,деактиви/ровать",
	"{noun}/вн : SwitchOff",
}

Verb {
	"#Eat",
	"есть,съе/сть,куша/ть,скуша/ть,сожр/ать,жри,жрать,ешь",
	"{noun}/вн,held : Eat",
}

Verb {
	"#Taste",
	"лизать,лизн/уть,попроб/овать,полиз/ать,сосать,пососа/ть",
	"{noun}/вн : Taste"
}

Verb {
	"#Drink",
	"пить,выпить,выпей,выпью,пью",
	"{noun}/вн,held : Drink",
}

function mp.shortcut.pref6()
	return 'с|по|пере|за'
end

Verb {
	"#Push",
	"толк/ать,пих/ать,нажим/ать,нажм/и,нажать,[{#pref6}]двин/уть,[|{#pref6}]двига/ть,"..
	"запих/нуть,затолк/ать,[|на]давить",
	"?на {noun}/вн : Push",
	"{noun}/вн на|в|во {noun}/вн : Transfer",
	"~ {noun}/вн к {noun}/дт : Transfer",
	"{noun}/вн {compass2} : Transfer",
	"~ на|в|во {noun}/вн {noun}/вн : Transfer reverse",
	"~ {compass2} {noun}/вн : Transfer reverse"
}

Verb {
	"#Pull",
	"[|вы|по]тян/уть,[|вы|по]тащ/ить,тягать,[|по]волоч/ь,[|по]волок/ти,дёрн/уть,дёрг/ать",
	"?за {noun}/вн : Pull",
	"{noun}/вн на|в|во {noun}/вн : Transfer",
	"~ {noun}/вн к {noun}/дт : Transfer",
	"{noun}/вн {compass2} : Transfer",
	"~ на|в|во {noun}/вн {noun}/вн : Transfer reverse",
	"~ {compass2} {noun}/вн : Transfer reverse"
}

Verb {
	"#Turn",
	"враща/ть,поверн/уть,[|за|по]верт/еть,[|за]крути/ть",
	"{noun}/вн : Turn"
}

Verb {
	"#Wait",
	"ждать,жди,подожд/ать,ожид/ать",
	"Wait"
}

function mp.shortcut.pref7()
	return 'за|по|про|пере|вы'
end

Verb {
	"#Rub",
	"[|{#pref7}]тереть,[|{#pref7}]три/,[{#pref7}]тира/ть,",
	"{noun}/вн : Rub"
}

Verb {
	"#Sing",
	"[|с]петь,спой/,пой",
	"Sing"
}

Verb {
	"#Touch",
	"[ |по]трога/ть,трон/уть,дотрон/уться,[ |при]косну/ться,касать/ся,[ |по|о]щупа/ть,[ |по]глад/ить",
	"{noun}/вн : Touch",
	"~ до {noun}/рд : Touch",
	"~ к {noun}/дт : Touch",
	"~ {noun}/рд : Touch",
}

Verb {
	"#Give",
	"дать,отда/ть,предло/жить,предла/гать,дам,даю,дадим",
	"{noun}/вн,held {noun}/дт,live : Give",
	"~ {noun}/дт,live {noun}/вн,held : Give reverse",
}

Verb {
	"#Show",
	"показ/ать,покаж/и",
	"{noun}/вн,held {noun}/дт,live : Show",
	"~ {noun}/дт,live {noun}/вн,held : Show reverse",
}

Verb {
	"#Burn",
	"[|под]жечь,жг/и,подожги/,поджиг/ай,зажг/и,зажиг/ай,зажечь",
	"{noun}/вн : Burn",
	"{noun}/вн {noun}/тв,held : Burn",
	"~ {noun}/тв,held {noun}/вн : Burn reverse",
}

Verb {
	"#Wake",
	"будить,разбуд/ить,просн/уться,бужу",
	"{noun}/вн,live : WakeOther",
	"Wake",
}

Verb {
	"#Kiss",
	"целовать,поцел/овать,чмок/нуть,обним/ать,обнять,целуй",
	"{noun}/вн,live : Kiss"
}

Verb {
	"#Think",
	"дума/ть,мысл/ить,подум/ать,рассужд/ать",
	"Think"
}

Verb {
	"#Smell",
	"нюха/ть,понюха/ть,занюх/ать,нюхн/уть,принюх/аться",
	"Smell",
	"{noun}/вн : Smell"
}

Verb {
	"#Listen",
	"слуша/ть,послуша/ть,прислушать/ся,слыш/ать,слух/",
	"Listen",
	"{noun}/вн : Listen",
	"~ к {noun}/дт : Listen",
}

Verb {
	"#Dig",
	"копа/ть,выкопа/ть,выры/ть,рыть,рой,вырой",
	"Dig",
	"{noun}/вн,scene : Dig",
	"{noun}/вн,scene {noun}/тв,held : Dig",
	"~ {noun}/тв,held {noun}/вн,scene : Dig reverse",
}

function mp.shortcut.pref8()
	return '[|раз|на|по|от|пере|вы]'
end

Verb {
	"#Cut",
	"{#pref8}рез/ать,{#pref8}реж/ь",
	"{noun}/вн : Cut",
	"{noun}/вн {noun}/тв,held: Cut",
	"~ {noun}/тв,held {noun}/вн: Cut reverse"
}

function mp.shortcut.pref9()
	return '[ |по|разо|со]'
end

Verb {
	"#Tear",
	"{#pref9}рвать,{#pref9}рви/,{#pref9}рву",
	"{noun}/вн : Tear",
}

Verb {
	"#Tie",
	"[при|с]вяз/ать,[при|с]вяж/и",
	"{noun}/вн : Tie",
	"{noun}/вн к {noun}/дт : Tie",
	"~ {noun}/вн с|со {noun}/тв : Tie",
	"~ к {noun}/дт {noun}/вн : Tie reverse",
	"~ с|со {noun}/тв {noun}/вн : Tie reverse",
}

Verb {
	"#Blow",
	"дуть,дуй/,дун/ь,задут/ь,задун/ь,задуй/",
	"в|во|на {noun}/вн : Blow",
	"~ {noun}/вн : Blow", -- задуть
}

Verb {
	"#Attack",
	"атак/овать,[|у|вы|раз|по|выши]бить,[|по|раз]бей/,удар/ить,"..
	"[|с|раз|по|вы|вз]лома/ть,разруш/ить,побь/,круш/ить,напасть,напад/ать,пнуть",
	"?на {noun}/вн : Attack"
}

Verb {
	"#Sleep",
	"спать,усн/уть,засн/уть,дрем/ать",
	"Sleep",
}

Verb {
	"#Swim",
	"плыть,плав/ать,ныря/ть,уплы/ть,поплы/ть,нырн/уть,[ |ис]купа/ться",
	"Swim",
}

Verb {
	"#Consult",
	"[|про|по]чита/ть,проч/есть",
	"в|во {noun}/пр,2 о|об|обо|про * : Consult",
	"~ о|об|обо|про * в|во {noun}/пр,2 : Consult reverse",
	"~ {noun}/вн : Exam",
}

Verb {
	"#Fill",
	"наполн/ить,нали/ть",
	"?в {noun}/вн : Fill",
	"~ внутрь {noun}/рд : Fill"
}

Verb {
	"#Jump",
	"[|по]прыг/ать,скак/ать,[|пере|под]прыг/нуть,переско/чить",
	"Jump",
	"через {noun}/вн,scene : JumpOver",
	"~ в {noun}/вн,scene : Enter",
	"~ на {noun}/вн,scene : Climb",
	"~ с|со {noun}/рд,scene : GetOff",
	"~ {compass2} : Walk",
	"~ +через {noun}/вн,scene : JumpOver",
}

Verb {
	"#Wave",
	"[|по]мах/ать,взмахн/уть,помаш/и",
	"WaveHands",
	"~ руками : WaveHands",
	"{noun}/тв,held : Wave"
}

Verb {
	"#Climb",
	"[|за|по|про|в]лез/ть,карабк/аться,взбир/ться,взобраться,взбери/сь",
	"на {noun}/вн,scene : Climb",
	"по {noun}/дт,scene : Climb",
	"~ внутрь {noun}/рд,scene : Enter",
	"~ в|во {noun}/вн,scene : Enter",
	"{compass2}: Walk",
}

Verb {
	"#GetOff",
	"слез/ть,спусти/ться,встать,встан/ь",
	"GetOff",
	"{compass2}: Walk",
	"с|со {noun}/рд,scene : GetOff",
}

Verb {
	"#Buy",
	"купи/ть,покупать",
	"{noun}/вн,scene : Buy"
}

Verb {
	"#Talk",
	"[|по]говор/ить,[|по]бесед/овать,разговарива/ть",
	"с|со {noun}/тв,live : Talk"

}

Verb {
	"#Tell",
	"сказать,сообщи/ть,сообщу,рассказать,расскаж/ите",
	"{noun}/дт,live о|об|обо|про * : Tell",
	"~ * {noun}/дт,live : Tell reverse",
	"~ {noun}/дт * : Tell"
}

Verb {
	"#Ask",
	"спросит/ь,расспросит/ь",
	"{noun}/вн,live о|об|обо|про * : Ask",
	"~ у {noun}/рд,live о|об|обо|про * : Ask",
	"~ о|об|обо|про * у {noun}/рд,live : Ask reverse",
}

Verb {
	"#AskFor",
	"попроси/ть,выпроси/ть,уговори/ть,проси/ть,попрош/у,выпрош/у",
	"у {noun}/рд,live * : AskFor",
	"* у {noun}/рд,live : AskFor reverse",
	"~ {noun}/вн,live * : AskTo",
}

Verb {
	"#Answer",
	"ответ/ить,отвеч/ать",
	"{noun}/дт,live * : Answer",
	"~ * {noun}/дт,live : Answer reverse",
}

Verb {
	"#Yes",
	"да",
	"Yes",
}

Verb {
	"#No",
	"нет",
	"No",
}

Verb {
    "~ использ/овать,воспольз/оваться",
    "{noun}/вн : Use",
    "{noun}/тв : Use",
}

if DEBUG then

function mp:MetaForm(w)
	if not w then return end
	local t, hint
	w = w:gsub("_", "/")
	if w:find "/" then
		hint = true
	end
	for _, f in ipairs { "им", "рд", "дт", "вн", "тв", "пр", "пр,2" } do
		local ww = w
		if hint then
			ww = ww .. ','.. f
		else
			ww = ww .. '/' .. f
		end
		t = self.mrd:word(ww)
		pn(t, " (", f, ")")
	end
end

	MetaVerb {
		"#MetaWord",
		"~_слово",
		"* : MetaWord"
	}
	MetaVerb {
		"#MetaNoun",
		"~_сущ/ествительное",
		"* : MetaNoun"
	}
	MetaVerb {
		"#MetaTrace",
		"~_трассировка",
		"да : MetaTraceOn",
		"нет : MetaTraceOff",
	}
	MetaVerb {
		"#MetaDump",
		"~_дамп",
		"MetaDump"
	}
	MetaVerb {
		"#МетаForm",
		"~_форм/ы",
		"* :MetaForm"
	}
end
mp.msg.MetaTranscript.ON = function(file)
	p ("Запись транскрипта началась: ", file)
end

mp.msg.MetaTranscript.OFF = function(file)
	p ("Транскрипт остановлен: ", file)
end

mp.msg.MetaTranscript.FILE = function(file)
	p ("Файл транскрипта: ", file)
end

MetaVerb {
	"#MetaTranscript",
	"~транскрипт",
	"да : MetaTranscriptOn",
	"нет : MetaTranscriptOff",
	"MetaTranscript",
}

MetaVerb {
	"#MetaExpert",
	"~парсер",
	"эксперт да : MetaExpertOn",
	"эксперт нет : MetaExpertOff",
	"глаголы : MetaVerbs",
	"версия : MetaVersion",
}

MetaVerb {
	"#MetaSave",
	"~сохрани/ть",
	"MetaSave"
}
MetaVerb {
	"#MetaLoad",
	"~загрузи/ть",
	"MetaLoad"
}

if DEBUG then
MetaVerb {
	"#MetaAutoplay",
	"~автоскрипт",
	"MetaAutoplay"
}
end

mp.msg.MetaRestart.RESTART = "Начать заново?";

MetaVerb {
	"#MetaRestart",
	"~заново,~рестарт",
	"MetaRestart"
}
MetaVerb {
	"#MetaHelp",
	"~помощь,помоги/те",
	"MetaHelp",
}
end, 1)

std.mod_start(function()
	if mp.undo > 0 then
		mp.msg.MetaUndo.EMPTY = "Отменять нечего."
		MetaVerb {
			"#MetaUndo",
			"~отмен/а",
			"MetaUndo",
		}
	end
	if mp.score then
		MetaVerb {
			"~ счёт",
			"MetaScore",
		}
	end
end)
-- Dialog
std.phr.default_Event = "Exam"

Verb ({"~ сказать", "{select} : Exam" }, std.dlg)
Verb ({'#Next', "дальше", "Next" }, mp.cutscene)
Verb ({'#Exam', "~ осмотреть", "Look" }, std.dlg)

mp.cutscene.default_Verb = "дальше"
mp.cutscene.help = fmt.em "<дальше>";

std.dlg.default_Verb = "осмотреть"
std.player.word = -"ты/мр,2л"
--luacheck: globals mp
--luacheck: no self

local tostring = std.tostr
local table = std.table
local type = type
local string = string
--- Error handler
-- @param err error code
function mp:err(err)
	local parsed = false
	if self:comment() then
		return
	end
	if std.here().OnError then
		std.here():OnError(err)
		return
	end
	if err == "UNKNOWN_VERB" then
		local verbs
		if mp.errhints then
			verbs = self:lookup_verb(self.words, true)
		end
		local hint = false
		if verbs and #verbs > 0 then
			for _, verb in ipairs(verbs) do
				local fixed = verb.verb[verb.word_nr]
				if verb.verb_nr == 1 then
					hint = true
					mp:message('UNKNOWN_VERB', self.words[verb.verb_nr])
					mp:message('UNKNOWN_VERB_HINT', fixed.word .. (fixed.morph or ""))
					break
				end
			end
		end
		if not hint then
			mp:message('UNKNOWN_VERB', self.words[1])
		end
	elseif err == "EMPTY_INPUT" then
		p (mp:mesg('EMPTY') or "Empty input.")
	elseif err == "INCOMPLETE" or err == "UNKNOWN_WORD" then
		local need_noun
		local second_noun
		for _, v in ipairs(self.hints) do
			local verb = ''
			if self.hints.match then
				for _, vv in pairs(self.hints.match.verb) do
					verb = verb .. vv .. ' '
				end
				verb = verb:gsub(" $", "")
				for _, vv in ipairs(self.hints.match) do
					verb = verb .. ' '.. vv
				end
				for _, vv in pairs(self.hints.match.args) do
					if vv.ob then
						second_noun = true
					end
				end
				if not parsed then
					parsed = verb
				end
				if second_noun then second_noun = verb end
			end
			if v:find("^~?{noun}") then need_noun = v break end
		end
		if #self.unknown > 0 and (not need_noun or
				self.unknown.lev == self.hints.lev) then
			local unk = ''
			for _, v in ipairs(self.unknown) do
				if unk ~= '' then unk = unk .. ' ' end
				unk = unk .. v
			end
			if need_noun then
				if mp.errhints then
					mp:message('UNKNOWN_OBJ', unk);
				else
					mp:message('UNKNOWN_OBJ');
				end
			else
				if mp.errhints then
					mp:message('UNKNOWN_WORD', unk);
				else
					mp:message('UNKNOWN_WORD');
				end
			end
			if mp:thedark() and need_noun then
				mp:message 'UNKNOWN_THEDARK'
				return
			end
			if need_noun then
				if #self.hints == 0 or not self.hints.fuzzy then
					return
				end
			end
		elseif err == "UNKNOWN_WORD" then
			mp:message('UNKNOWN_WORD')
		else
			if need_noun then
				if second_noun then
					mp:message('INCOMPLETE_SECOND_NOUN', second_noun .." " ..mp:err_noun(need_noun))
				else
					mp:message('INCOMPLETE_NOUN', parsed)
				end
			else
				mp:message 'INCOMPLETE'
			end
		end
		if not mp.errhints or need_noun then
			return
		end
		local words = {}
		local dups = {}
		for _, v in ipairs(self.hints) do
			if v:find("^~?{noun}") or v == '*' or v == '~*' then
				if v:sub(1,1) == '~' then v = v:sub(2) end
				v = mp:err_noun(v)
				if not dups[v] then
					table.insert(words, v)
					dups[v] = true
				end
			else
				local pat = self:pattern(v)
				local empty = true
				for _, vv in ipairs(pat) do
					if not vv.hidden then
						empty = false
						break
					end
				end
				for _, vv in ipairs(pat) do
					if (empty or not vv.hidden) and not dups[vv.word] then
						table.insert(words, vv.word)
						dups[vv.word] = true
					end
				end
			end
--			if need_noun then
--				break
--			end
		end
		if #words > 0 then
			if err == 'INCOMPLETE' then
				if #words > 2 and parsed then
					parsed = parsed .. ': '
				end
				p (mp:mesg 'HINT_WORDS', ", ", parsed or '')
			else
				p (mp:mesg 'HINT_WORDS', ", ")
			end
		end

		for k, v in ipairs(words) do
			if k ~= 1 then
				if k == #words then
					pr (" ", mp.msg.OR, " ")
				else
					pr (", ")
				end
			end
			pr(iface:em(v))
		end
		if #words > 0 then
			p "?"
		end
	elseif err == "MULTIPLE" then
		pr (mp:mesg 'MULTIPLE', " ", self.multi[1])
		for k = 2, #self.multi do
			if k == #self.multi then
				pr (" ", mp.msg.AND, " ", self.multi[k])
			else
				pr (", ", self.multi[k])
			end
		end
		pr "."
	elseif err then
		pr (err)
	end
end


local everything = std.obj {
	nam = '@all';
	hint_noun = false;
	before_Any = function(_, ev)
		if ev == 'Exam' then
			mp:xaction("Look")
			return
		end
		if not mp.expert_mode or
			(ev ~= 'Drop' and ev ~= 'Take' and ev ~= 'Remove') then
			mp:message 'NO_ALL'
			return
		end
		return false
	end;
}:attr 'concealed':persist()

--- Clear the metaparser window
function mp:clear()
	self.text = ''
end

--- Clear the metaparser prompt
-- @see mp.clear_on_move
function mp:cls_prompt()
	if std.call_ctx[1] then
		std.call_ctx[1].txt = ''
	end
end

--- Standard door class
mp.door = std.class({
	before_Walk = function(s)
		return s:before_Enter();
	end;
	before_Enter = function(s)
		if mp:check_inside(s) then
			return
		end
		if not s:has 'open' then
			local t = std.call(s, 'when_closed')
			if t then
				p(t)
			else
				mp:message 'Enter.DOOR_CLOSED'
			end
			return
		end
		local r, v = mp:runorval(s, 'door_to')
		if not v then
			mp:message 'Enter.DOOR_NOWHERE'
			return
		end
		if r then
			if not mp:move(std.me(), r) then
				return true
			end
		end
		return v
	end;
}, std.obj):attr 'enterable,openable,door'

function mp:pnoun(noun, msg)
	local ctx = mp:save_ctx()
	mp.first = noun
	mp.first_hint = noun:gram().hint
	std.p(mp.fmt(msg)) -- first is available only here, so fmt is forced
	mp:restore_ctx(ctx)
end

mp.cutscene =
std.class({
	enter = function(s)
		s.__num = 1
	end;
	ini = function(s)
		std.rawset(s, 'text', s.text)
		std.rawset(s.__var, 'text', nil)
		if not s.__num then
			s.__num = 1
		end
	end;
	title = false;
	nouns = function() return {} end;
	dsc = function(s)
		if type(s.text) == 'function' then
			local t = std.call(s, 'text', s.__num)
			if not t then
				s:Next(true)
			end
			p (t)
		else
			if type(s.text) == 'string' then
				p (s.text)
			else
				p (s.text[s.__num])
			end
		end
		if mp.msg.CUTSCENE_MORE then
			p("^", mp.msg.CUTSCENE_MORE)
		end
	end;
	OnError = function(_, _) -- s, err
		mp:message 'CUTSCENE_HELP'
	end;
	Next = function(s, force)
		if game:time() == 0 then
			return
		end
		s.__num = s.__num + 1
		if force or type(s.text) == 'string' or (type(s.text) == 'table' and s.__num > #s.text) then
			local r, v = mp:runorval(s, 'next_to')
			if r then
				walk(r)
			elseif v == false then
				walkback()
			end
			return
		end
		s:dsc()
	end;
}, std.room):attr'cutscene'

mp.gameover =
std.class({
	enter = function()
		getDaemons():zap()
	end;
	before_Default = function()
		mp:message 'GAMEOVER_HELP';
	end;
	before_Look = function()
		mp:message 'GAMEOVER_HELP';
	end;
	OnError = function()
		mp:message 'GAMEOVER_HELP';
	end;
}, std.room):attr'gameover'

-- player
mp.msg.Look = {}

function std.obj:multi_alias(n)
	if n then
		self.__word_alias = n
	end
	return self.__word_alias
end

std.room.dsc = function(_)
	mp:message 'SCENE';
end

local function trace_light(v)
	if v:has 'light' then
		return true
	end
	if v:has 'container' and not v:has 'transparent' and not v:has 'open' then
		return nil, false
	end
end

--- Check if the player or the specified object is in darkness
-- @param what check if this is in darkness; player by default
function mp:thedark(what)
	if std.me():has'light' or mp:traceinside(std.me(), trace_light) then
		return false
	end
	local w = what or std.me():where()
	local h = mp:light_scope(w)
	if h:has'light' then return false end
	return not mp:traceinside(h, trace_light)
end

function std.obj:scene()
	local s = self
	local sc = mp:visible_scope(s)
	local title = iface:title(std.titleof(sc))
	if s ~= sc then
		local r = std.call(std.me():where(), "title")
		title = title .. ' '..mp.fmt("(".. (r or mp:mesg('TITLE_INSIDE')) .. ")")
	end
	return title
end

std.room.scene = std.obj.scene

local owalk = std.player.walk

std.obj.from = std.room.from

function std.player:walk(w, doexit, doenter, dofrom)
	w = std.object(w)
	if std.is_obj(w, 'room') then
		if w == std.here() then
			self.__room_where = false
			self:need_scene(true)
			return nil, true
		end
		local r, v = owalk(self, w, doexit, doenter, dofrom)
		if mp.clear_on_move and player_moved() then
			mp:cls_prompt()
		end
		self.__room_where = false
		return r, v
	end
	if std.is_obj(w) then -- into object
		if dofrom ~= false and std.me():where() ~= w then
			w.__from = std.me():where()
		end
		if w:inroom() == std.ref(self.room) then
			self.__room_where = w
			self:need_scene(true)
			return nil, true
		end
		local r, v = owalk(self, w:inroom(), doexit, doenter, dofrom)
		if mp.clear_on_move and player_moved() then
			mp:cls_prompt()
		end
		self.__room_where = w
		return r, v
	end
	std.err("Can not enter into: "..std.tostr(w), 2)
end

function std.player:walkout(w, ...)
	if w == nil then
		w = self:where():from()
	end
	return self:walk(w, true, false, ...)
end;

std.player.where = function(s, where)
	local inexit = s.__in_onexit or s.__in_exit
	local inwalk = (s.__room_where and s.__room_where:inroom() ~= std.here())
	if inexit or inwalk then -- fallback to room
		if type(where) == 'table' then
			table.insert(where, std.ref(s.room))
		end
		return std.ref(s.room)
	end
	if type(where) == 'table' then
		table.insert(where, std.ref(s.__room_where or s.room))
	end
	return std.ref(s.__room_where or s.room)
end

std.room.display = function(s)
	local c = std.call(mp, 'content', s)
	return c
end

function mp:light_scope(s)
	local h = s
	if not s:has 'container' or s:has 'transparent' or s:has 'open' then
		mp:trace(s, function(v)
				h = v
				if v:has 'container' and not v:has'transparent' and not v:has 'open' then
					return nil, false
				end
		end)
	end
	return h
end

--- Find the maximum visible scope for an object
-- @param s where
function mp:visible_scope(s)
	local h = s
	if s:has 'transparent' or s:has 'supporter' then
		mp:trace(s, function(v)
				 h = v
				 if not v:has'transparent' and not v:has'supporter' then
					 return nil, false
				 end
		end)
	end
	return h
end

std.obj.display = function(s)
	local c = std.call(mp, 'content', mp:visible_scope(s))
	return c
end

std.player.look = function(s)
	local scene, img
	local r = s:where()
	if s:need_scene() then
		local gfx = std.call(std.here(), 'gfx') or std.call(std.game, 'gfx')
		if not gfx and instead.tiny then
			gfx = stead.call(std.here(), 'pic') or stead.call(std.ref 'game', 'pic')
		end
		if gfx and gfx ~= mp.last_gfx then
			img = fmt.c(fmt.img(gfx))
			mp.last_gfx = gfx
		end
		scene = std.par('^', img, r:scene())
	end
	return (std.par(std.scene_delim, scene or false, r:display() or false, std.call(mp, 'footer') or false))
end

--
local function check_persist(w)
	if not w:has 'persist' then
		return false
	end
	if not w.found_in then
		return true
	end
	local _, v = std.call(w, 'found_in')
	return v
end

function std.obj:access()
	local plw = {}
	if std.me():where() == self then
		return true
	end

	if self:has 'persist' then
		if not self.found_in then
			return true
		end
		local _, v = std.call(self, 'found_in')
		return v
	end
	if mp.scope:lookup(self) then
		return true
	end
	mp:trace(std.me(), function(v)
--		if v:has 'concealed' then
--			return nil, false
--		end
		plw[v] = true
		if v:has 'container' then -- or v:has 'supporter' then
			return nil, false
		end
	end)
	return mp:trace(self, function(v)
--		if v:has 'concealed' then
--			return nil, false
--		end
		if check_persist(v) then
			return true
		end
		if plw[v] then
			return true
		end
		if v:has 'container' and not v:has 'open' then
			return nil, false
		end
	end)
end

function mp:distance(v, wh)
	local plw = {}
	wh = wh or std.me()
	local a = 0
	mp:trace(wh, function(s)
		plw[s] = a
		table.insert(plw, s)
		a = a + 1
		if s:has 'container' then
			return nil, false
		end
	end)

	local dist
	if v:where() ~= wh then
		dist = 1
		if not mp:trace(v, function(o)
			if plw[o] then
				dist = dist + plw[o]
				return true
			end
			dist = dist + 1
		end) then
			dist = 10000 -- infinity
		end
	else
		dist = 0
	end
	return dist
end

--- Check if the object is lit
-- @param what
function mp:offerslight(what)
	if what and what:has'light' or what:has'luminous' or mp:inside(what, std.me()) then
		return true
	end
	return not mp:thedark()
end

function std.obj:visible()
	local plw = { }
	if std.me():where() == self then
		return true
	end

	if not mp:offerslight(self) then
		return false
	end

	if check_persist(self) then
		return true
	end

	if mp.scope:lookup(self) then
		return true
	end

	mp:trace(std.me(), function(v)
--		if v:has 'concealed' then
--			return nil, false
--		end
		table.insert(plw, v)
		if v:has 'container' and not v:has 'transparent' and not v:has 'open' then
			return nil, false
		end
	end)
	return mp:trace(self, function(v)
--		if v:has 'concealed' then
--			return nil, false
--		end
		if check_persist(v) then
			return true
		end
		for _, o in ipairs(plw) do
			if v == o then
				return true
			end
		end
		if v:has 'container' and not v:has 'transparent' and not v:has 'open' then
			return nil, false
		end
	end)
end

-- dialogs
std.phr.raw_word = function(s)
	local dsc = std.call(s, 'dsc')
	if type(dsc) ~= 'string' then
		std.err("Empty dsc in phrase", 2)
	end
	return dsc .. '|'.. (tostring(s.__ph_idx) or std.dispof(s))
end

std.phr.Exam = function(s, ...)
	std.me():need_scene(true)
	return s:act(...)
end

std.phr.__xref = function(_, str)
	return str
end

std.dlg.ini = function(s, load)
	if std.here() == s and not visited(s) and not load then
		s:enter()
	end
end
std.dlg.scene = std.obj.scene
std.dlg.title = false
std.dlg.OnError = function(_, _) -- s, err
	mp:message 'DLG_HELP'
end;

std.dlg.nouns = function(s)
	local nr
	local nouns = {}
	nr = 1
	local oo = s.current
	if not oo then -- nothing to show
		return
	end

	for i = 1, #oo.obj do
		local o = oo.obj[i]
		o = o:__alias()
		std.rawset(o, '__ph_idx', nr)
	end

	for i = 1, #oo.obj do
		local o = oo.obj[i]
		o = o:__alias()
		if o:visible() then
			std.rawset(o, '__ph_idx', nr)
			nr = nr + 1
			table.insert(nouns, o)
		end
	end
	return nouns
end;

std.phrase_prefix = function(n)
	if not n then
		return '-- '
	end
	return (string.format("%d) ", n))
end

--- Construct a compass direction from action name.
local function compass_dir(dir)
	return obj {
		nam = '@'..dir;
		default_Event = 'Walk';
		before_Any = function(_, ev, ...)
			return std.object '@compass':action(dir, ev, ...)
		end
	}:attr'light,enterable,concealed':persist()
end

obj {
	nam = '@compass';
	visible = function() return false end;
	action = function(s, dir, ev, ...)
		if ev == 'Exam' then
			local d = dir
			local r, v, _
			_, v = mp:runorval(std.here(), 'compass_look', d)
			if v then
				return
			end
			r, v = mp:runorval(std.here(), d, d)
			if r then -- somewhat?
				if std.object(r):type 'room' then
					mp:message 'COMPASS_EXAM_NO'
					return
				end
				mp:message('COMPASS_EXAM', d, std.object(r))
				return
			end
			if not v then
				mp:message 'COMPASS_EXAM_NO'
				return
			end
			return v
		end
		if ev == 'Walk' or ev == 'Enter' then
			local d = dir
			if not std.me():where():type'room' then
				mp:message 'Enter.EXITBEFORE'
				return
			end
			if std.here()[d] == nil and d == 'out_to' then
				mp:xaction("Exit")
				return
			end
			local r, v = mp:runorval(std.here(), d, d)
			if not v then
				local t, vv = mp:runorval(std.here(), 'cant_go', dir)
				if vv then
					if t then p(t) end
					return
				end
				mp:message 'COMPASS_NOWAY'
				return
			end
			if not r then
				return v
			end
			if std.object(r):type 'room' then
				if not mp:move(std.me(), r) then return true end
			else
				mp:xaction("Enter", std.object(r))
			end
			return
		end
		return std.call(s, 'before_Default', ev, ...)
	end;
}:persist():attr'~light,transparent':with {
	compass_dir 'n_to',
	compass_dir 'ne_to',
	compass_dir 'e_to',
	compass_dir 'se_to',
	compass_dir 's_to',
	compass_dir 'sw_to',
	compass_dir 'w_to',
	compass_dir 'nw_to',
	compass_dir 'd_to',
	compass_dir 'u_to',
	compass_dir 'in_to',
	compass_dir 'out_to',
}


--- Check if object is a compass direction.
-- @param w the object to check
-- @param dir optional arg to check againist selected dir
mp.compass_dir = function(_, w, dir)
	if not w then
		return false
	end
	if not dir then
		local nam = tostring(w.nam):gsub("^@", "")
		return w:where() and w:where() ^ '@compass' and nam
	end
	return w ^ ('@'..dir)
end

mp.msg.INFODSC = function(o)
	return mp:infodsc(o)
end

mp.detailed_attr = {
	{ 'worn' },
	{ 'open', 'openable'},
--	{ 'on', 'switchable'},
--	{ 'light' }
}

function mp:infodsc(ob)
	local info = {}
	for _, v in ipairs(self.detailed_attr) do
		local hit = #v > 0
		for _, vv in ipairs(v) do
			if ob:hasnt(vv) then
				hit = false
				break
			end
		end
		if hit then
			local n = 'HAS_'..string.upper(v[1])
			if mp.msg[n] then
				table.insert(info, mp:mesg(n, ob))
			end
		end
	end

	if #info > 0 then
		pr(" (")
		for k, i in ipairs(info) do
			if #info > 1 and k == #info then
				pr(' ', mp.msg.AND, ' ')
			elseif k > 1 then
				pr(", ")
			end
			pr(i)
		end
		pr(")")
	end
end

function mp:multidsc(oo, inv)
	local t = {}
	local dup = {}
	local hint = type(inv) == 'string' and inv or ''
	for _, v in ipairs(oo) do
		local n
		if not v:has'concealed' then
			if inv == true then
				n = std.call(v, 'inv')
			end
			if type(v.a_noun) == 'function' then
				n = n or v:a_noun(hint, 1)
			else
				n = n or v:noun(hint, 1)
			end
			if dup[n] then
				dup[n] = dup[n] + 1
			else
				table.insert(t, { ob = v, noun = n })
				dup[n] = 1
			end
		end
	end
	for _, vv in ipairs(t) do
		local v = vv.noun
		local ob = vv.ob
		if _ ~= 1 then
			if _ == #t then
				p (" ", mp.msg.AND or "and")
			else
				p ","
			end
		end
		if dup[v] > 1 then
			pr (ob:noun(hint .. ','..self.mrd.lang.gram_t.plural, 1), " (", dup[v], " ", mp:mesg('ENUM', dup[v], ob), ")")
		else
			pr (v)
			pr(mp:mesg('INFODSC', ob))
		end
	end
end

-- Default priority in content
function mp:defpri(w)
	if mp:animate(w) then
		return -1
	end
	return 0
end

mp.msg.Exam = {}
--- Display the object contents
function mp:content(w, exam)
	if w:type 'dlg' then
		return
	end
	local oo = {}
	local ooo = {}
	local expand = {}
	local inside
	if (w == std.me():where() or std.here() == w) and
		(mp.event == 'Look' or mp.event == 'Exam' or std.me():need_scene()) then
		inside = true
		local dsc, v
		-- pn()
		if mp:thedark(w) then
			dsc, v = std.call(w, 'dark_dsc')
			if dsc then p(dsc) end
			if not v then
				mp:message 'WHEN_DARK'
			end
		else
			if w:type'room' and not w:has'visited' and w.init_dsc ~= nil then
				dsc, v = std.call(w, 'init_dsc')
			else
				dsc, v = std.call(w, w:type'room' and 'dsc' or 'inside_dsc')
			end
			if dsc then p(dsc) end
			if not v then
				mp:message 'INSIDE_SCENE'
			end
		end
		p(std.scene_delim)
	end
	self:objects(w, oo, false)
	if w == std.here() then
		self:objects(self.persistent, oo, false)
	end
	std.sort(oo, function (a, b)
		a = std.tonum(a.pri) or mp:defpri(a)
		b = std.tonum(b.pri) or mp:defpri(b)
		if a == b then
			return nil
		end
		return a < b
	end)
	local something
	for _, v in ipairs(oo) do
		local r, rc, desc
		if not v:has'scenery' and not v:has'concealed' then
			if std.me():where() == v then
				r, rc = std.call(v, 'inside_dsc')
				if r then p(r); desc = true; end
			end
			if not rc and not v:has 'moved' then
				r, rc = std.call(v, 'init_dsc')
				if r then p(r); desc = true; end
			end
			if not rc then
				r, rc = std.call(v, 'dsc')
				if r then p(r); desc = true; end
			end
			if not rc and (v:has'openable') then
				if v.when_open ~= nil and v:has'open' then
					r, rc = std.call(v, 'when_open')
				elseif v.when_closed ~= nil and not v:has'open' then
					r, rc = std.call(v, 'when_closed')
				end
				if r then p(r); desc = true; end
			elseif not rc and (v:has'switchable') then
				if v.when_on ~= nil and v:has'on' then
					r, rc = std.call(v, 'when_on')
				elseif v.when_off ~= nil and not v:has'on' then
					r, rc = std.call(v, 'when_off')
				end
				if r then p(r); desc = true; end
			end
			something = something or desc
			if not rc then
				table.insert(expand, v)
				if not desc then
					table.insert(ooo, v)
				end
			end
		end
	end
--	if #ooo > 0 then
--		p(std.scene_delim)
--	end
	oo = ooo
	if #oo == 0 then
		if not inside and exam and mp.first == w and not something then
			mp:message ('Exam.NOTHING', w)
		end
	else
		mp:message('Exam.CONTENT', w, oo)
	end
-- expand?
	for _, o in ipairs(expand) do
		if (o:has'supporter' or o:has'transparent' or (o:has'container' and o:has'open')) and not o:closed() then
			self:content(o)
		end
	end
end

std.room:attr 'enterable,light'

function mp:strip(r)
	if std.strip_call and type(r) == 'string' then
		r = r:gsub("^[%^\n\r\t ]+", "") -- extra heading ^ and spaces
		r = r:gsub("[%^\n\r\t ]+$", "") -- extra trailing ^ and spaces
	end
	return r
end

function mp:step()
	local old_daemons = {}
	game.__daemons:for_each(function(o)
		table.insert(old_daemons, o)
	end)
	for _, o in ipairs(old_daemons) do
		if not o:disabled() then
			local r, v = mp:runorval(o, 'daemon')
			if r == true and v == true then break end
		end
	end
	local oo = mp:nouns()
	std.here():attr 'visited'
	for _, v in ipairs(oo) do
		if v.each_turn ~= nil then
			local r = mp:runorval(v, 'each_turn')
			if r == true then
				break
			end
		end
	end
	local s = std.game -- after reset game is recreated
	local r = mp:strip(std.pget())
	s:reaction(r or false)
	std.pclr()
	s:step()
	r = mp:strip(s:display(true))
	s:lastreact(s:reaction() or false)
	s:lastdisp(r)
	std.pr(r)
	std.abort_cmd = true
end

function mp:post_action()
	if std.abort_cmd then
		return
	end
	if (self.event and self.event:find("Meta", 1, true)) or self:comment() or self:noparser() then
		local s = std.game
		local r = mp:strip(std.pget())
		s:reaction(r or false)
		std.pclr()
		r = mp:strip(s:display(self:noparser()))
		s:lastdisp(r)
		s:lastreact(s:reaction() or false)
		std.pr(r)
		std.abort_cmd = true
		return
	end
	if mp.undo > 0 then
		local nr = #snapshots.data
		if nr > mp.undo  then
			table.remove(snapshots.data, 1)
			nr = nr - 1
		end
		mp.snapshot = nr + 1
	end
	if self.score and (self.score ~= (self.__old_score or 0)) then
		mp:message('SCORE', self.score - (self.__old_score or 0))
		self.__old_score = self.score
	end

	if game.player:need_scene() then
--		pn(iface:nb'')
		local l = game.player:look() -- objects [and scene]
		p(l, std.scene_delim)
		game.player:need_scene(false)
	end
	mp:step()
end
--- Check if mp.first and mp.second objects are in touch zone
-- Returns true if we have to terminate the sequence.
function mp:check_touch()
	if self.first and not self.first:access() and not self.first:type'room' then
		p (mp:mesg('ACCESS1') or "{#First} is not accessible.")
		if std.here() ~= std.me():where() then
			mp:message 'EXITBEFORE'
		end
		return true
	end
	if self.second and not self.second:access() and not self.first:type'room' then
		p (mp:mesg('ACCESS2') or "{#Second} is not accessible.")
		if std.here() ~= std.me():where() then
			mp:message 'EXITBEFORE'
		end
		return true
	end
	return false
end

--[[
function mp:before_Any(ev)
	if ev == 'Exam' then
		return false
	end
	if self.first and not self.first:access() and not self.first:type'room' then
		p (self.msg.ACCESS1 or "{#First} is not accessible.")
		if std.here() ~= std.me():where() then
			mp:message 'EXITBEFORE'
		end
		return
	end

	if self.second and not self.second:access() and not self.first:type'room' then
		p (self.msg.ACCESS2 or "{#Second} is not accessible.")
		if std.here() ~= std.me():where() then
			mp:message 'EXITBEFORE'
		end
		return
	end
	return false
end
]]--
function mp:Look()
	std.me():need_scene(true)
	return false
end

function mp:after_Look()
end
--luacheck: push ignore w wh
function mp:Exam(w)
	return false
end

function mp:after_Exam(w)
	local r, v = std.call(w, 'description')
	local something = false
	if r then
		p(r)
		something = true
	end
	if v then
		return false
	end
	if w:has 'container' and (w:has'transparent' or w:has'open') then
		self:content(w, not something)
	elseif w:has 'supporter' then
		self:content(w, not something)
	else
		if w:has'openable' then
			if w:has 'open' then
				local t = std.call(w, 'when_open')
				if t then
					p(t)
				else
					mp:message 'Exam.OPENED'
				end
			else
				local t = std.call(w, 'when_closed')
				if t then
					p(t)
				else
					mp:message 'Exam.CLOSED'
				end
			end
			return
		end
		if w:has'switchable' then
			local t
			if w:has'on' and w.when_on ~= nil then
				t = std.call(w, 'when_on')
			else
				t = std.call(w, 'when_off')
			end
			if t then
				p(t)
			else
				mp:message 'Exam.SWITCHSTATE'
			end
			return
		end
		if w == std.here() then
			std.me():need_scene(true)
		else
			if w == std.me() then
				mp:message 'Exam.SELF'
			else
				mp:message 'Exam.DEFAULT'
			end
		end
	end
end

mp.msg.Enter = {}

function mp:Enter(w)
	if mp:check_touch() then
		return
	end
	if mp:check_live(w) then
		return
	end
	if w == std.me():where() then
		mp:message 'Enter.ALREADY'
		return
	end

	if w:has'clothing' and not w:has'enterable' then
		mp:xaction ("Wear", w)
		return
	end

	if seen(w, std.me()) then
		mp:message 'Enter.INV'
		return
	end

	if not w:has 'enterable' then
		mp:message 'Enter.IMPOSSIBLE'
		return
	end

	if w:has 'container' and not w:has 'open' then
		mp:message 'Enter.CLOSED'
		return
	end

	if mp:check_inside(w) then
		return
	end

	if not mp:move(std.me(), w) then return true end
	return false
end

function mp:after_Enter(w)
	mp:message 'Enter.ENTERED'
end

mp.msg.Walk = {}

function mp:Walk(w)
	if mp:check_touch() then
		return
	end
	if w == std.me():where() then
		mp:message 'Walk.ALREADY'
		return
	end

	if seen(w, std.me()) then
		mp:message 'Walk.INV'
		return
	end

--	if std.me():where() ~= std.here() then
--		mp:message 'Enter.EXITBEFORE'
--		return
--	end
	return false
end

function mp:after_Walk(w)
	if not w then
		mp:message 'Walk.NOWHERE'
	else
		mp:message 'Walk.WALK'
	end
end

mp.msg.Exit = {}

function mp:before_Exit(w)
	if not w then
		self:xaction('Exit', std.me():where())
		return true
	end
	return false
end

function mp:Exit(w)
	if mp:check_touch() then
		return
	end
	local wh = std.me():where()
	w = w or std.me():where()
	if wh ~= w then
		if have(w) and w:has'worn' then
			mp:xaction ("Disrobe", w)
			return
		end
		if wh:inside(w) then
			mp:message 'Enter.EXITBEFORE'
			return
		end
		mp:message 'Exit.NOTHERE'
		return
	end
	if wh:has'container' and not wh:has'open' then
		mp:message 'Exit.CLOSED'
		return
	end

	if wh:type'room' and wh.out_to ~= nil then
		mp:xaction("Walk", _'@out_to')
		return
	end

	if wh:from() == wh or wh:type 'room' then
		mp:message 'Exit.NOWHERE'
		return
	end
--	if wh:type'room' then
--	local r = std.call(w, 'out_to')
--		mp:move(std.me(), wh:from())
--	else
		if not mp:move(std.me(), wh:where()) then return true end
--	end
	return false
end

function mp:after_Exit(w)
	if w and not w:type 'room' then
		mp:message 'Exit.EXITED'
	end
end

mp.msg.Inv = {}

function mp:detailed_Inv(wh, indent)
	local oo = {}
	self:objects(wh, oo, false)
	for _, o in ipairs(oo) do
		if not o:has'concealed' then
			for _ = 1, indent do pr(iface:nb' ') end
			local inv = std.call(o, 'inv') or o:noun(1)
			pr(inv)
			mp:message('INFODSC', o)
			pn()
			if o:has'supporter' or o:has'container' then
				mp:detailed_Inv(o, indent + 1)
			end
		end
	end
end

function mp:after_Inv()
	local oo = {}
	self:objects(std.me(), oo, false)
	if #oo == 0 then
		mp:message 'Inv.NOTHING'
		return
	end
	local empty = true
	for _, v in ipairs(oo) do
		if not v:has'concealed' then empty = false break end
	end
	if empty then
		mp:message 'Inv.NOTHING'
		return
	end
	pr(mp:mesg 'Inv.INV')
	if mp.detailed_inv then
		pn(":")
		mp:detailed_Inv(std.me(), 1)
	else
		p()
		mp:multidsc(oo, true)
		p "."
	end
end

mp.msg.Open = {}

function mp:Open(w)
	if mp:check_touch() then
		return
	end
	if mp:check_live(w) then
		return
	end
	if not w:has'openable' then
		mp:message 'Open.NOTOPENABLE'
		return
	end
	if w:has'open' then
		mp:message 'Open.WHENOPEN'
		return
	end
	if w:has'locked' then
		mp:message 'Open.WHENLOCKED'
		return
	end
	w:attr'open'
	return false
end

function mp:after_Open(w)
	mp:message 'Open.OPEN'
	if w:has'container' then
		self:content(w)
	end
end

mp.msg.Close = {}

function mp:Close(w)
	if mp:check_touch() then
		return
	end
	if not w:has'openable' then
		mp:message 'Close.NOTOPENABLE'
		return
	end
	if not w:has'open' then
		mp:message 'Close.WHENCLOSED'
		return
	end
	w:attr'~open'
	return false
end

function mp:after_Close(w)
	mp:message 'Close.CLOSE'
end

--- Show mp message using mp.msg constant
-- args uses only for functions
function mp:message(m, ...)
	p(mp:mesg(m, ...))
end

-- same as above, but do not call p
function mp:mesg(m, ...)
	local t = std.split(m, ".")
	m = mp.msg
	for _, n in ipairs(t) do
		m = m[n]
		if not m then
			std.err("Wrong message id: "..tostring(n), 2)
		end
	end
	if type(m) ~= 'function' then
		return m
	else
		std.callpush()
		local v = m(...)
		local r = std.pget()
		std.callpop()
		return r or v
	end
end
--- Check if the object is alive.
-- If yes, return standard message.
-- Returns true if we have to terminate the sequence.
-- @param w object to check
function mp:check_live(w)
	if self:animate(w) then
		mp:message('LIVE_ACTION', w)
		return true
	end
	return false
end

function mp:check_no_live(w)
	if not self:animate(w) then
		mp:message('NO_LIVE_ACTION', w)
		return true
	end
	return false
end

--- Check if the object is held by the player.
-- If not, attempt to take it.
-- Returns true if we have to terminate the sequence.
-- @param t object to check
function mp:check_held(t)
	if have(t) or std.me() == t then
--	if (std:me():lookup(t) and t:visible()) or std.me() == t then
		return false
	end
	mp:message('TAKE_BEFORE', t)
	mp:subaction('Take', t)
	if not have(t) then
--		mp:message('NOTINV', t)
		return true
	end
	return false
end

function mp:check_inside(w)
	if std.me():where() ~= std.here() and not w:inside(std.me():where()) then
		mp:message 'Enter.EXITBEFORE'
		return true
	end
	return false
end

--- Check if the object is worn by the player.
-- If yes, attempt to take it off.
-- Returns true if we have to terminate the sequence.
-- @param w object to check
function mp:check_worn(w)
	if w:has'worn' then
		mp:message('DISROBE_BEFORE', w)
		mp:subaction('Disrobe', w)
		if w:has'worn' then
--			mp:message 'Drop.WORN'
			return true
		end
	end
	return false
end

mp.msg.Lock = {}
function mp:Lock(w, t)
	if mp:check_touch() then
		return
	end
	if mp:check_held(t) then
		return
	end
	local r = std.call(w, 'with_key')
	if not w:has 'lockable' or not r then
		mp:message 'Lock.IMPOSSIBLE'
		return
	end
	if w:has 'locked' then
		mp:message 'Lock.LOCKED'
		return
	end
	if w:has 'open' then
		mp:message('CLOSE_BEFORE', w)
		mp:subaction('Close', w)
		if w:has 'open' then
			mp:message 'Lock.OPEN'
			return
		end
	end
	if std.object(r) ~= t then
		mp:message 'Lock.WRONGKEY'
		return
	end
	w:attr'locked'
	return false
end

function mp:after_Lock(w, wh)
	mp:message 'Lock.LOCK'
end

mp.msg.Unlock = {}
function mp:Unlock(w, t)
	if mp:check_touch() then
		return
	end
	if mp:check_held(t) then
		return
	end
	local r = std.call(w, 'with_key')
	if not w:has 'lockable' or not r then
		mp:message 'Unlock.IMPOSSIBLE'
		return
	end
	if not w:has 'locked' then
		mp:message 'Unlock.NOTLOCKED'
		return
	end
	if std.object(r) ~= t then
		mp:message 'Unlock.WRONGKEY'
		return
	end
	w:attr'~locked'
--	w:attr'open'
	return false
end

function mp:after_Unlock(w, wh)
	mp:message 'Unlock.UNLOCK'
end

--- Check if the object is inside an object.
-- @param w what
-- @param wh where
function mp:inside(w, wh)
	wh = std.object(wh)
	w = std.object(w)
	return mp:trace(w, function(v)
			 if v == wh then return true end
	end)
end
--- Check if the object is inside an object.
-- @see mp:inside
function inside(w, wh)
	return mp:inside(w, wh)
end
--- Check if the object is inside an object.
-- @see mp:inside
std.obj.inside = function(s, wh)
	return mp:inside(s, wh)
end

std.obj.move = function(s, wh)
	return mp:move(s, wh, true)
end

--- Move an object
-- @see mp:move
function move(w, wh)
	return mp:move(w, wh, true)
end
--- Move an object
-- @param w       what
-- @param wh      where
-- @param force   ignore capacity flag if true
function mp:move(w, wh, force)
	wh = wh or std.here()
	wh = std.object(wh)
	w = std.object(w)
	local r
	local ww = {}

	if not force then
		local n = self:runorval(wh, 'capacity')
		local capacity = n and tonumber(n)
		if capacity and #wh.obj >= capacity then
			mp:message('NOROOM', wh)
			return false
		end
		w:where(ww)

		for _, o in ipairs(ww) do
			if mp:runmethods('before', 'LetGo', o, w, wh) then
				return false
			end
		end

		if mp:runmethods('before', 'LetIn', wh, w) then
			return false
		end
	end

	if w:type'player' then
		r = w:walk(wh)
		if r then p(r) end
	else
		local wpl =  mp:inside(std.me(), w)
		place(w, wh)
		if wpl then
			r = std.me():walk(w)
			if r then p(r) end
		end
	end
	w:attr 'moved'
	if wh:type'player' then
		w:attr '~concealed'
	end
	if not force then
		for _, o in ipairs(ww) do
			if mp:runmethods('after', 'LetGo', o, w, wh) then
				return false
			end
		end

		if mp:runmethods('after', 'LetIn', wh, w) then
			return false
		end
	end

	return true
end

mp.msg.Take = {}

local function cont_taken(ob, taken)
	for _, o in ipairs(taken) do
		if ob:inside(o) then
			return true
		end
	end
end

--- Check if object is part of parent
-- @param w       what
function mp:partof(w)
	return w:where() and not w:where():type'room' and
		not w:where():has'container' and
		not w:where():has'supporter'
end

function mp:TakeAll(wh)
	local empty = true
	wh = wh or std.me():where()
	local oo = {}
	mp:objects(wh, oo)
	local taken = {}
	for _, o in ipairs(oo) do
		if o:hasnt 'static' and o:hasnt'scenery' and o:hasnt 'concealed'
			and not mp:animate(o)
			and not cont_taken(o, taken)
			and not mp:partof(o) then
			empty = false
			mp:message('TAKING_ALL', o)
			mp:subaction('Take', o)
			if not have(o) then
				break
			end
			table.insert(taken, o)
		end
	end
	if empty then
		mp:message 'NOTHING_OBJ'
	end
end

function mp:Take(w, wh)
	if w == everything then
		return mp:TakeAll(wh)
	end
	if mp:check_touch() then
		return
	end
	if w == std.me() then
		mp:message 'Take.SELF'
		return
	end
	if have(w) then
		mp:message 'Take.HAVE'
		return
	end
	local n = mp:trace(std.me(), function(v)
		if v == w then return true end
	end)
	if n then
		mp:message 'Take.WHERE'
		return
	end
	if mp:animate(w) then
		mp:message 'Take.LIFE'
		return
	end
	if w:has'static' then
		mp:message 'Take.STATIC'
		return
	end
	if w:has'scenery' then
		mp:message 'Take.SCENERY'
		return
	end
	if mp:partof(w) then
		if w:has'worn' and mp:animate(w:where()) then
			mp:message 'Take.WORN'
		else
			mp:message 'Take.PARTOF'
		end
		return
	end
	if not mp:move(w, std.me()) then return true end
	return false
end

function mp:after_Take(w)
	mp:message 'Take.TAKE'
end

mp.msg.Remove = {}

function mp:Remove(w, wh)
	if mp:check_touch() then
		return
	end
	if w == std.me() then
		mp:xaction("Exit", wh)
		return
	end
	if w:where() ~= wh and w:inroom() ~= wh and w ~= everything then
		mp:message 'Remove.WHERE'
		return
	end
	if wh == std.me() then
		mp:xaction('Disrobe', w, wh)
		return
	end
	mp:xaction('Take', w, wh)
end

function mp:after_Remove(w, wh)
	mp:message 'Remove.REMOVE'
end

mp.msg.Drop = {}
function mp:DropAll(wh)
	local empty = true
	local oo = {}
	mp:objects(std.me(), oo, false)
	for _, o in ipairs(oo) do
		if o:hasnt 'concealed' then
			empty = false
			mp:message('DROPPING_ALL', o)
			mp:subaction('Drop', o)
			if have(o) then
				break
			end
		end
	end
	if empty then
		mp:message 'NOTHING_OBJ'
	end
end

function mp:Drop(w)
	if w == everything then
		return mp:DropAll()
	end
	if mp:check_touch() then
		return
	end
	if mp:check_held(w) then
		return
	end
	if mp:check_worn(w) then
		return
	end
	if w == std.me() then
		mp:message 'Drop.SELF'
		return
	end
	if not mp:move(w, std.me():where()) then return true end
	return false
end

function mp:after_Drop(w)
	mp:message 'Drop.DROP'
end

mp.msg.Insert = {}

function mp:Insert(w, wh)
	if mp:check_touch() then
		return
	end
	if wh == std.me() then
		mp:xaction('Take', w)
		return
	end
	if w == std.me() then
		mp:xaction('Enter', wh)
		return
	end
	if wh == w:where() then
		mp:message 'Insert.ALREADY'
		return
	end
	if wh == std.me():where() or mp:compass_dir(wh, 'd_to') then
		mp:xaction('Drop', w)
		return
	end
	if mp:check_held(w) then
		return
	end
	if mp:check_worn(w) then
		return
	end
	if mp:check_live(wh) then
		return
	end

	local n = mp:trace(wh, function(v)
		if v == w then return true end
	end)
	if n or w == wh then
		mp:message 'Insert.WHERE'
		return
	end

	if mp:runmethods('before', 'Receive', wh, w) then
		return
	end

	if not wh:has'container' then
		if wh:has'supporter' then
			mp:xaction("PutOn", w, wh)
			return
		end
		mp:message 'Insert.NOTCONTAINER'
		return
	end
	if not wh:has'open' then
		mp:message 'Insert.CLOSED'
		return
	end
	if not mp:move(w, wh) then return true end
	return false
end

function mp:after_Insert(w, wh)
	if mp:runmethods('after', 'Receive', wh, w) then
		return
	end
	mp:message 'Insert.INSERT'
end

mp.msg.PutOn = {}

function mp:PutOn(w, wh)
	if mp:check_touch() then
		return
	end
	if wh == std.me() then
		mp:xaction('Take', w)
		return
	end
	if w == std.me() then
		mp:xaction('Climb', wh)
		return
	end
	if wh == std.me():where() or mp:compass_dir(wh, 'd_to') then
		mp:xaction('Drop', w)
		return
	end
	if mp:check_held(w) then
		return
	end
	if mp:check_live(wh) then
		return
	end
	if mp:check_worn(w) then
		return
	end
	local n = mp:trace(wh, function(v)
		if v == w then return true end
	end)
	if n or w == wh then
		mp:message 'PutOn.WHERE'
		return
	end
	if mp:runmethods('before', 'Receive', wh, w) then
		return
	end
	if not wh:has'supporter' then
		mp:message 'PutOn.NOTSUPPORTER'
		return
	end
	if not mp:move(w, wh) then return true end
	return false
end

function mp:after_PutOn(w, wh)
	if mp:runmethods('after', 'Receive', wh, w) then
		return
	end
	mp:message 'PutOn.PUTON'
end

mp.msg.ThrowAt = {}

function mp:ThrowAt(w, wh)
	if mp:check_touch() then
		return
	end
	if wh == std.me():where() or mp:compass_dir(wh, 'd_to') then
		mp:xaction('Drop', w)
		return
	end
	if mp:check_held(w) then
		return
	end
	if mp:check_worn(w) then
		return
	end
	if mp:runmethods('before', 'ThrownAt', wh, w) then
		return
	end
	if mp:runmethods('life', 'ThrowAt', wh, w) then
		return
	end
	if not self:animate(wh) then
		if wh:has'container' then
			mp:xaction("Insert", w, wh)
			return
		end
		if wh:has'supporter' then
			mp:xaction("PutOn", w, wh)
			return
		end
		mp:message 'ThrowAt.NOTLIFE'
		return
	end
	mp:message 'ThrowAt.THROW'
end

mp.msg.Wear = {}

function mp:Wear(w)
	if mp:check_touch() then
		return
	end
	if mp:check_held(w) then
		return
	end
	if not w:has'clothing' then
		mp:message 'Wear.NOTCLOTHES'
		return
	end
	if w:has'worn' then
		mp:message 'Wear.WORN'
		return
	end
	w:attr'worn'
	return false
end

function mp:after_Wear(w)
	mp:message 'Wear.WEAR'
end

mp.msg.Disrobe = {}

function mp:Disrobe(w)
	if mp:check_touch() then
		return
	end
	if not have(w) or not w:has'worn' then
		mp:message 'Disrobe.NOTWORN'
		return
	end
	w:attr'~worn'
	return false
end

function mp:after_Disrobe(w)
	mp:message 'Disrobe.DISROBE'
end

mp.msg.SwitchOn = {}

function mp:SwitchOn(w)
	if mp:check_touch() then
		return
	end
	if not w:has'switchable' then
		mp:message 'SwitchOn.NONSWITCHABLE'
		return
	end
	if w:has'on' then
		mp:message 'SwitchOn.ALREADY'
		return
	end
	w:attr'on'
	return false
end

function mp:after_SwitchOn(w)
	mp:message 'SwitchOn.SWITCHON'
end

mp.msg.SwitchOff = {}

function mp:SwitchOff(w)
	if mp:check_touch() then
		return
	end
	if not w:has'switchable' then
		mp:message 'SwitchOff.NONSWITCHABLE'
		return
	end
	if not w:has'on' then
		mp:message 'SwitchOff.ALREADY'
		return
	end
	w:attr'~on'
	return false
end

function mp:after_SwitchOff(w)
	mp:message 'SwitchOff.SWITCHOFF'
end

mp.msg.Search = {}

function mp:Search(w)
	mp:xaction('Exam', w)
end

mp.msg.LookUnder = {}
function mp:LookUnder(w)
	mp:message 'LookUnder.NOTHING'
end

mp.msg.Eat = {}

function mp:Eat(w)
	if mp:check_touch() then
		return
	end
	if not w:has'edible' then
		mp:message 'Eat.NOTEDIBLE'
		return
	end
	if mp:check_held(w) then
		return
	end
	if mp:check_worn(w) then
		return
	end
	remove(w)
	return false
end

function mp:after_Eat(w)
	mp:message 'Eat.EAT'
end

mp.msg.Taste = {}

function mp:Taste(w)
	if mp:check_touch() then
		return
	end

	if w:has'edible' then
		mp:xaction("Eat", w)
		return
	end

	if mp:check_live(w) then
		return
	end

	return false
end

function mp:after_Taste(w)
	mp:message 'Taste.TASTE'
end

mp.msg.Drink = {}

function mp:after_Drink(w)
	mp:message 'Drink.IMPOSSIBLE'
end

mp.msg.Transfer = {}

function mp:Transfer(w, ww)
	if mp:check_touch() then
		return
	end
	if mp:compass_dir(ww) then
		mp:xaction('PushDir', w, ww)
		return
	end
	if ww:has 'supporter' then
		mp:xaction('PutOn', w, ww)
		return
	end
	mp:xaction('Insert', w, ww)
end

mp.msg.Push = {}

function mp:Push(w)
	if mp:check_touch() then
		return
	end
	if w:has 'switchable' then
		if w:has'on' then
			mp:xaction('SwitchOff', w)
		else
			mp:xaction('SwitchOn', w)
		end
		return
	end
	if w:has 'static' then
		mp:message 'Push.STATIC'
		return
	end
	if w:has 'scenery' then
		mp:message 'Push.SCENERY'
		return
	end
	if mp:check_live(w) then
		return
	end
	return false
end

function mp:after_Push()
	mp:message 'Push.PUSH'
end

mp.msg.Pull = {}

function mp:Pull(w)
	if mp:check_touch() then
		return
	end
	if w:has 'static' then
		mp:message 'Pull.STATIC'
		return
	end
	if w:has 'scenery' then
		mp:message 'Pull.SCENERY'
		return
	end
	if mp:check_live(w) then
		return
	end
	return false
end

function mp:after_Pull()
	mp:message 'Pull.PULL'
end

mp.msg.Turn = {}

function mp:Turn(w)
	if mp:check_touch() then
		return
	end
	if w:has 'static' then
		mp:message 'Turn.STATIC'
		return
	end
	if w:has 'scenery' then
		mp:message 'Turn.SCENERY'
		return
	end
	if mp:check_live(w) then
		return
	end
	return false
end

function mp:after_Turn()
	mp:message 'Turn.TURN'
end

mp.msg.Wait = {}
function mp:after_Wait()
	mp:message 'Wait.WAIT'
end

mp.msg.Rub = {}

function mp:Rub(w)
	if mp:check_touch() then
		return
	end
	return false
end

function mp:after_Rub()
	mp:message 'Rub.RUB'
end

mp.msg.Sing = {}

function mp:after_Sing(w)
	mp:message 'Sing.SING'
end

mp.msg.Touch = {}

function mp:Touch(w)
	if mp:check_touch() then
		return
	end
	if w == std.me() then
		mp:message 'Touch.MYSELF'
		return
	end
	if self:animate(w) then
		mp:message 'Touch.LIVE'
		return
	end
	return false
end

function mp:after_Touch()
	mp:message 'Touch.TOUCH'
end

mp.msg.Give = {}

function mp:Give(w, wh)
	if mp:check_touch() then
		return
	end
	if mp:check_held(w) then
		return
	end
	if wh == std.me() then
		mp:message 'Give.MYSELF'
		return
	end
	if mp:runmethods('life', 'Give', wh, w) then
		return
	end
	if mp:check_no_live(wh) then
		return
	end
	return false
end

function mp:after_Give()
	mp:message 'Give.GIVE'
end

mp.msg.Show = {}

function mp:Show(w, wh)
	if mp:check_touch() then
		return
	end
	if mp:check_held(w) then
		return
	end
	if wh == std.me() then
		mp:xaction("Exam", w)
		return
	end
	if mp:runmethods('life', 'Show', wh, w) then
		return
	end
	if mp:check_no_live(wh) then
		return
	end
	return false
end

function mp:after_Show()
	mp:message 'Show.SHOW'
end

mp.msg.Burn = {}

function mp:Burn(w, wh)
	if mp:check_touch() then
		return
	end
	if wh and mp:check_held(wh) then
		return
	end
	return false
end

function mp:after_Burn(w, wh)
	if wh then
		mp:message 'Burn.BURN2'
	else
		mp:message 'Burn.BURN'
	end
end

mp.msg.Wake = {}

function mp:after_Wake()
	mp:message 'Wake.WAKE'
end

mp.msg.WakeOther = {}

function mp:WakeOther(w)
	if mp:check_touch() then
		return
	end
	if w == std.me() then
		mp:xaction('Wake')
		return
	end
	if mp:runmethods('life', 'WakeOther', w) then
		return
	end
	if not mp:animate(w) then
		mp:message 'WakeOther.NOTLIVE'
		return
	end
	return false
end

function mp:after_WakeOther()
	mp:message 'WakeOther.WAKE'
end

mp.msg.PushDir = {}
function mp:PushDir(w, wh)
	if mp:check_touch() then
		return
	end
	if mp:check_live(w) then
		return
	end
	return false
end

function mp:after_PushDir()
	mp:message 'PushDir.PUSH'
end

mp.msg.Kiss = {}
function mp:Kiss(w)
	if mp:check_touch() then
		return
	end
	if mp:runmethods('life', 'Kiss', w) then
		return
	end
	if not mp:animate(w) then
		mp:message 'Kiss.NOTLIVE'
		return
	end
	if w == std.me() then
		mp:message 'Kiss.MYSELF'
		return
	end
	return false
end

function mp:after_Kiss()
	mp:message 'Kiss.KISS'
end

mp.msg.Think = {}
function mp:after_Think()
	mp:message 'Think.THINK'
end

mp.msg.Smell = {}
function mp:Smell(w)
	if mp:check_touch() then
		return
	end
	return false
end

function mp:after_Smell(w)
	if w then
		mp:message 'Smell.SMELL2'
		return
	end
	mp:message 'Smell.SMELL'
end

mp.msg.Listen = {}
function mp:Listen(w)
	if mp:check_touch() then
		return
	end
	return false
end

function mp:after_Listen(w)
	if w then
		mp:message 'Listen.LISTEN2'
		return
	end
	mp:message 'Listen.LISTEN'
end

mp.msg.Dig = {}
function mp:Dig(w, wh)
	if mp:check_touch() then
		return
	end
	if w and mp:check_live(w) then
		return
	end
	if wh then
		if mp:check_held(wh) then
			return
		end
	end
	return false
end

function mp:after_Dig(w, wh)
	if wh then
		mp:message 'Dig.DIG3'
		return
	end
	if w then
		mp:message 'Dig.DIG2'
		return
	end
	mp:message 'Dig.DIG'
end

mp.msg.Cut = {}
function mp:Cut(w, wh)
	if mp:check_touch() then
		return
	end
	if mp:check_live(w) then
		return
	end

	if wh then
		if mp:check_live(wh) then
			return
		end
		if mp:check_held(wh) then
			return
		end
	end
	return false
end

function mp:after_Cut(w, wh)
	if wh then
		mp:message 'Cut.CUT2'
	else
		mp:message 'Cut.CUT'
	end
end

mp.msg.Tear = {}
function mp:Tear(w)
	if mp:check_touch() then
		return
	end
	if mp:check_live(w) then
		return
	end
	return false
end

function mp:after_Tear()
	mp:message 'Tear.TEAR'
end

mp.msg.Tie = {}

function mp:Tie(w, wh)
	if mp:check_touch() then
		return
	end
	if mp:check_live(w) then
		return
	end
	if wh and mp:check_live(wh) then
		return
	end
	return false
end

function mp:after_Tie(w, wh)
	if wh then
		mp:message 'Tie.TIE2'
		return
	end
	mp:message 'Tie.TIE'
end

mp.msg.Blow = {}

function mp:Blow(w)
	if mp:check_touch() then
		return
	end
	if mp:check_live(w) then
		return
	end
	return false
end

function mp:after_Blow()
	mp:message 'Blow.BLOW'
end

mp.msg.Attack = {}

function mp:Attack(w)
	if mp:check_touch() then
		return
	end
	if mp:runmethods('life', 'Attack', w) then
		return
	end
	return false
end

function mp:after_Attack(w)
	if mp:animate(w) then
		mp:message 'Attack.LIFE'
		return
	end
	mp:message 'Attack.ATTACK'
end

mp.msg.Sleep = {}

function mp:after_Sleep()
	mp:message 'Sleep.SLEEP'
end

mp.msg.Swim = {}

function mp:after_Swim()
	mp:message 'Swim.SWIM'
end

mp.msg.Consult = {}

function mp:Consult(w, wh)
	if mp:check_touch() then
		return
	end
	return false
end

function mp:after_Consult()
	mp:message 'Consult.CONSULT'
end

mp.msg.Fill = {}
function mp:Fill(w)
	if mp:check_touch() then
		return
	end
	return false
end

function mp:after_Fill()
	mp:message 'Fill.FILL'
end

mp.msg.Jump = {}
function mp:after_Jump()
	mp:message 'Jump.JUMP'
end

mp.msg.JumpOver = {}
function mp:JumpOver(w)
	if mp:check_touch() then
		return
	end
	return false
end

function mp:after_JumpOver()
	mp:message 'JumpOver.JUMPOVER'
end

mp.msg.WaveHands = {}
function mp:after_WaveHands()
	mp:message 'WaveHands.WAVE'
end

mp.msg.Wave = {}
function mp:Wave(w)
	if mp:check_touch() then
		return
	end
	if mp:check_held(w) then
		return
	end
	return false
end

function mp:after_Wave()
	mp:message 'Wave.WAVE'
end

function mp:Climb(w)
	mp:xaction('Enter', w)
end

mp.msg.GetOff = {}

function mp:GetOff(w)
	if not w and std.me():where() == std.here() then
		mp:message 'GetOff.NOWHERE'
		return
	end
	mp:xaction('Exit', w)
end

mp.msg.Buy = {}
function mp:Buy(w)
	if mp:check_touch() then
		return
	end
	return false
end

function mp:after_Buy()
	mp:message 'Buy.BUY'
end

mp.msg.Talk = {}
function mp:Talk(w)
	if mp:check_touch() then
		return
	end
	local r, v = mp:runorval(w, 'talk_to')
	if v then
		if r then
			walkin(r)
		end
		return
	end
	if w == std.me() then
		mp:message 'Talk.SELF'
		return
	end
	if mp:runmethods('life', 'Talk', w) then
		return
	end
	return false
end

function mp:after_Talk(w)
	if not mp:animate(w) then
		mp:message 'Talk.NOTLIVE'
		return
	end
	mp:message 'Talk.LIVE'
end

mp.msg.Tell = {}
function mp:Tell(w, t)
	if mp:check_touch() then
		return
	end
	if #self.vargs == 0 then
		mp:message 'Tell.EMPTY'
		return
	end
	if w == std.me() then
		mp:message 'Tell.SELF'
		return
	end
	if mp:runmethods('life', 'Tell', w, t) then
		return
	end
	return false
end

function mp:after_Tell(w)
	if not mp:animate(w) then
		mp:message 'Tell.NOTLIVE'
		return
	end
	mp:message 'Tell.LIVE'
end

mp.msg.Ask = {}
function mp:Ask(w, t)
	if mp:check_touch() then
		return
	end
	if #self.vargs == 0 then
		mp:message 'Ask.EMPTY'
		return
	end
	if w == std.me() then
		mp:message 'Ask.SELF'
		return
	end
	if mp:runmethods('life', 'Ask', w, t) then
		return
	end
	return false
end

function mp:after_Ask(w)
	if not mp:animate(w) then
		mp:message 'Ask.NOTLIVE'
		return
	end
	mp:message 'Ask.LIVE'
end

function mp:AskFor(w, t)
	if w == std.me() then
		mp:xaction('Inv')
		return
	end
	mp:xaction('Ask', w, t)
end

function mp:AskTo(w, t)
	mp:xaction('Ask', w, t)
end

mp.msg.Answer = {}

function mp:Answer(w, t)
	if mp:check_touch() then
		return
	end
	if #self.vargs == 0 then
		mp:message 'Answer.EMPTY'
		return
	end
	if w == std.me() then
		mp:message 'Answer.SELF'
		return
	end
	if mp:runmethods('life', 'Answer', w, t) then
		return
	end
	return false
end

function mp:after_Answer(w)
	if not mp:animate(w) then
		mp:message 'Answer.NOTLIVE'
		return
	end
	mp:message 'Answer.LIVE'
end

mp.msg.Yes = {}

function mp:after_Yes()
	mp:message 'Yes.YES'
end

function mp:after_No()
	mp:message 'Yes.YES'
end

mp.msg.Use = {}

function mp:Use(w)
	if mp:check_touch() then
		return
	end
	return false
end

function mp:after_Use()
	mp:message 'Use.USE'
end

function mp:MetaHelp()
	pn(mp:mesg 'HELP')
end

function mp:MetaScore()
	mp:message'TITLE_TURNS'
	pn()
	mp:message'TITLE_SCORE'
end

mp.msg.MetaTranscript = {}

function mp:MetaTranscript()
	if self.logfile then
		mp:message("MetaTranscript.FILE", self.logfile)
	else
		self:MetaTranscriptOn()
	end
end

function mp:MetaTranscriptOff()
	mp:message("MetaTranscript.OFF", self.logfile)
	self.logfile = false
	self.lognum = self.lognum + 1
end

function mp:MetaTranscriptOn()
	while true do
		local logfile = string.format("%s/log%03d.txt", instead.gamepath(), self.lognum)
		local f = io.open(logfile, "rb")
		if not f then
			self.logfile = logfile
			if std.cctx() then
				mp:message("MetaTranscript.ON", logfile)
			end
			return
		end
		f:close()
		self.lognum = self.lognum + 1
	end
end
function mp:MetaVersion()
	p(mp.version)
end
function mp:MetaVerbs()
	local verbs = {}
	for _, v in ipairs(mp:verbs()) do
		local vv = v.verb[1]
		if vv and not vv.hidden then
			local verb = vv.word .. (vv.morph or "")
			table.insert(verbs, verb)
		end
	end
	table.sort(verbs)
	for _, v in ipairs(verbs) do p(v) end
end

mp.msg.MetaRestart = {}

local old_pre_input

function mp:MetaRestart()
	mp:message 'MetaRestart.RESTART'
	if old_pre_input then return end
	old_pre_input = mp.pre_input
	std.rawset(mp, 'pre_input', function(_, str)
		std.rawset(mp, 'pre_input', old_pre_input)
		old_pre_input = false
		if mp:eq(str, mp.msg.YES) then
			instead.restart()
		end
		return false
	end)
end

function mp:MetaSave()
	instead.menu 'save'
end

function mp:MetaExpertOn()
	mp.autocompl = false
	mp.autohelp = false
	p [[Expert mode on.]]
end

function mp:MetaExpertOff()
	mp.autocompl = true
	mp.autohelp = true
	p [[Expert mode off.]]
end

function mp:MetaLoad()
	instead.menu 'load'
end
--luacheck: pop
local function attr_string(o)
	local a = ''
	for k, _ in pairs(o.__ro) do
		if type(k) == 'string' and k:find("__attr__", 1, true) == 1 then
			if a ~= '' then a = a .. ', ' end
			a = a .. k:sub(9)
		end
	end
	local b = ''
	for k, _ in pairs(o) do
		if type(k) == 'string' and k:find("__attr__", 1, true) == 1 then
			if b ~= '' then b = b .. ', ' end
			b = b .. k:sub(9)
		end
	end
	if b ~= '' then b = '!'..b..'' end
	a = a .. b
	if a ~= '' then a = ' [' .. a .. '] ' end
	return a
end
function mp:MetaDump()
	local oo = mp:nouns()
	for _, o in ipairs(oo) do
		if not std.is_system(o) and o ~= std.me() then
			local d = mp:distance(o)
			if d > 8 then d = 8 end
			for _ = 1, d do pr(fmt.nb' ') end
			local t = '<'..std.tostr(o)..'>'
			t = t .. (std.call(o, 'word') or std.call(o, 'raw_word') or '')
			if have(o) then t = fmt.em(t) end
			pn(t, attr_string(o))
		end
	end
end

function mp:MetaWord(w)
	if not w then return end
	w = w:gsub("_", "/")
	local g
	w, g = self.mrd:word(w)
	pn(w)
	for _, v in ipairs(g) do
		pn (_, ":")
		for k, vv in pairs(v) do
			pn(k, " = ", vv)
		end
	end
end
mp.msg.MetaUndo = {}
function mp:MetaUndo()
	local nr = #snapshots.data
	if nr > 1 then
		snapshots:restore(nr - 1)
		table.remove(snapshots.data, nr)
	else
		mp:message 'MetaUndo.EMPTY'
	end
end

local function getobj(w)
	if std.is_tag(w) then
		return std.here():lookup(w) or std.me():lookup(w)
	end
	return std.ref(w)
end

function mp:MetaNoun(_)
	local varg = self.vargs
	local o = getobj(varg[1])
	if not o then
		p ("Wrong object: ", varg[1])
		return
	end
	local t = {}
	local w
	if #varg == 2 then
		w = o:noun(varg[2], t)
	else
		w = o:noun(t)
	end
	pn "== Words:"
	for _, v in ipairs(w or {}) do
		pn(v)
	end
	pn "== Grams:"
	for _, v in ipairs(t or {}) do
		for kk, vv in pairs(v) do
			pn(kk, " = ", vv)
		end
	end

end
function mp:MetaTraceOn()
	pn "Tracing is on"
	self.debug.trace_action = true
end
function mp:MetaTraceOff()
	pn "Tracing is off"
	self.debug.trace_action = false
end

function mp:MetaAutoplay(w)
	mp:autoscript(w)
	if mp.autoplay then
		pn ([[Script file: ]], w)
	else
		pn ([[Can not open script file: ]], w)
	end
end

local __oini = std.obj.__ini

local function fn_aliases(wh)
	local new = {}
	for k, f in pairs(wh) do -- "before_Take,Drop..."
		if (type(f) == 'function' or type(f) == 'string') and
			type(k) == 'string' and k:find("[a-zA-Z]+,") then
			local ss, ee = k:find("^[a-z]+_")
			local pref = ''
			local str = k
			if ss then
				pref = k:sub(1, ee);
				if pref == 'before_' or pref == 'after_' or pref == 'post_' or pref == 'life_' then
					str = k:sub(ee + 1)
				else
					pref = ''
				end
			end
			local m = std.split(str, ",")
			for _, v in ipairs(m) do
				new[pref .. v] = f
			end
		end
	end
	for k, v in pairs(new) do
		wh[k] = v
	end
end

std.obj.for_plural = function(s, fn)
	fn = fn or function() end
	if not s:hint'plural' then
		fn(s)
		return false
	end
	for _, v in ipairs(mp.multi[s] or { s }) do
		fn(v)
	end
	return true
end

std.obj.__ini = function(s, ...)
	if s.__mp_ini then
		return __oini(s, ...)
	end
	if type(s.found_in) == 'string' then
		s.found_in = { s.found_in }
	end
	if type(s.found_in) == 'table' then
		for _, v in ipairs(s.found_in) do
			local vv = v
			v = std.ref(v)
			if not v then
				std.err("Wrong object in found_in list of: "..tostring(s).."/"..vv, 2)
			end
			v.obj:add(s)
		end
		std.rawset(s, 'found_in', nil)
	elseif type(s.found_in) == 'function' then
		s:persist()
	end
	if type(s.scope) == 'table' and not std.is_obj('list', s.scope) then
		s.scope = std.list (s.scope)
	end
	fn_aliases(s.__ro)
	std.rawset(s, "__mp_ini", true)
	return __oini(s, ...)
end

function parent(w)
	w = std.object(w)
	return w:where()
end

function Class(t, w)
	fn_aliases(t)
	if not w then
		return std.class(t, std.obj)
	end
	return std.class(t, w)
end

local function get_once_tag(n)
	if type(n) == 'string' then
		return '__once_'..n
	else
		return '__once'
	end
end

std.obj.once = function(s, n)
	n = get_once_tag(n)
	if not s[n] then
		s[n] = true
		return true
	end
	return false
end

std.obj.is_once = function(s, n)
	n = get_once_tag(n)
	return not not s[n]
end

std.obj.daemonStart = function(s)
	game.__daemons:add(s)
end

std.obj.daemonStop = function(s)
	game.__daemons:del(s)
end

std.obj.isDaemon = function(s)
	return game.__daemons:lookup(s)
end

function DaemonStart(w)
	std.object(w):daemonStart()
end

function DaemonStop(w)
	std.object(w):daemonStop()
end

function isDaemon(w)
	return std.object(w):isDaemon()
end

function getDaemons()
	return game.__daemons
end

instead.notitle = true

instead.get_title = function(_)
	if instead.notitle then
		return
	end
	local w = instead.theme_var('win.w')
	local title = std.titleof(std.here()) or ''
	local col = instead.theme_var('win.col.fg')
	local score = ''
	if mp.score then
		score = fmt.tab('70%', 'center')..fmt.nb(mp:mesg('TITLE_SCORE'))
	end
	local moves = fmt.tab('100%', 'right')..fmt.nb(mp:mesg('TITLE_TURNS'))
	return iface:left((title.. score .. moves).."\n".. iface:img(string.format("box:%dx1,%s", w, col)))
end

--luacheck: globals content
function content(w, ...)
	w = std.object(w)
	return mp:content(w, ...)
end
